# 面试Q&A

字节的一个面试题，一个东西，settime就出一个，可以随时终止，利用异步的思想。

赛马问题。



### 编译性语言和解释性语言

高级语言若想被计算机执行，都必须将其转换为计算机语言，也就是机器码。而转换的方式有两种：

**编译**与**解释**

所以高级语言也分为**编译型语言（C C++）和解释性语言（Python JS）** 

> JS是脚本语言，脚本语言不需要编译，是由js解释器逐行解释并执行的

**主要区别在于，前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。**

**编译性语言**

特点：

在编译型语言写的程序执行之前，**需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可**，如直接运行exe文件。**因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。**

总结：

1.一次性的编译成平台相关的机器语言文件，**运行时脱离开发环境，运行效率高**；

2.与特定平台相关，一般无法移植到其他平台；

**解释性语言**

特点：

解释型语言**不需要事先编译，其直接将源代码解释成机器码并立即执行**，所以只要**某一平台提供了相应的解释器即可运行该程序。**

总结：

1.解释型语言每次运行都需要将源代码解释称机器码并执行，**效率较低**；

2.只要平台提供相应的解释器，就可以运行源代码，所以可以**方便源程序移植**；

**两者各有利弊**

前者由于**程序执行速度快，同等条件下对系统要求较低**，因此像**开发操作系统、大型应用程序、数据库系统**等时都采用它

而一些网页脚本、服务器脚本及辅助开发接口这样的**对速度要求不高、对不同系统平台间的兼容性有一定要求**的程序则通常使用解释性语言

> JAVA即是编译的，也是解释的。非要归类的话，从概念上来讲，应该会定义到解释性语言中
>
> JAVA先编译，但编译后不能直接运行，要通过JVM来解释运行，所以是解释语言（但现在的JVM有一些有JIT优化，它又会把.class的二进制代码编译为本地的代码直接运行，就又是编译语言了）



### 类的概念

虽然 JavaScript 中有类的概念，但是可能大多数 JavaScript 程序员并不是非常熟悉类，这里对类相关的概念做一个简单的介绍。

- 类（Class）：定义了一件事物的抽象特点，包含它的属性和方法
- 对象（Object）：类的实例，通过 `new` 生成
- 面向对象（OOP）的三大特性：封装、继承、多态
- 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据
- 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性
- 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 `Cat` 和 `Dog` 都继承自 `Animal`，但是分别实现了自己的 `eat` 方法。此时针对某一个实例，我们无需了解它是 `Cat` 还是 `Dog`，就可以直接调用 `eat` 方法，程序会自动判断出来应该如何执行 `eat`
- 存取器（getter & setter）：用以改变属性的读取和赋值行为
- 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 `public` 表示公有属性或方法
- 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现
- 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口



### Git的相关概念

四个区域：

工作目录：敲代码的地方

暂存区：git add之后的地方

本地仓库：git commit了之后的地方

远程仓库：git push了之后的地方，远程大家公用的项目代码仓库

前三个 合并共称为**开发环境**



### 说几个Git常用的命令

git clone 克隆仓库内容到本地

git init + git remote add origin + 仓库地址 	初始化&配置仓库地址

git add 从工作区保存到暂存区

git commit 从暂存区提交到本地仓库

git push 将本地仓库的代码传到远程仓库

git pull 拉取/同步远程仓库的代码

git status -s 查看工作区状态



### Git Merge 和 Git Rebase的区别

共同的作用：**都是把不同分支的提交合并到一起**

**Git Merge**

 把源分支的提交放到目标分支里。在这个过程中，只有目标分支改变，而源分支保持原样

**优点**

- 简单易上手
- 保留了提交历史和时间次序
- 保留了分支的结构

**缺点**

- 提交历史被大量的 merge 提交污染了

- 使用 git bisect 调试变得更困难了

  >  git bisect 是通过二分法找到哪一次代码提交引入了错误
  >
  > ```
  > $ git bisect start [终点] [起点]
  > $ git bisect good
  > $ git bisect bad
  > 通过二分不断重复，找到出现问题的那一次提交
  > $ git bisect reset 退出查错，回到最近一次的代码提交
  > ```

如何使用

使用 checkout 和 merge 命令把 master 分支 merge 到 feature 分支。

```text
$ git checkout feature
$ git merge master

(or)

$ git merge master feature
```

这将会在 feature 分支上创建一个新的 “Merge 提交” 用来保留合并记录。



**GitRebase**

变基命令

Rebase 把所有的提交压缩成一个 “patch”。然后把 patch 添加到目标分支里，生成一个新的分支。

和 merging 不同，rebasing 清除了历史，因为它完全是从一个分支转移到了另一个分支。在这个过程中，多余的记录被移除了。

**优点**

- 把复杂的历史变成优雅的提交线
- 操作单个提交变得很简单（比如，reverting）
- 避免了庞大的仓库、海量的分支以及烦人的 merge 提交
- 线性合并清除了中间的无用提交，对于 DevOps 团队来说是个好消息

**缺点**

- Rebase 后 feature 分支间的上下文模糊了
- 在团队里 rebasing 公共分支是高风险的事
- 工作变多了：feature 分支需要经常更新
- Rebasing 到远程分支需要 force push。最大的问题是人们经常已经 force push 了，才发现忘记了设置 git push 默认值。结果本地远程所有同名的分支都进行了更新，清理起来很要命。

使用

下面的命令把 feature 分支 rebase 到 master 分支上。

```text
$ git checkout feature
$ git rebase master
```

它把整个 feature 分支的提交移动到了 master 分支上。通过给每个源(feature) 分支创建了一个 brand 来 re-writing 项目的历史。

> feature1落后master分支的提交，命令把 feature 分支 rebase 到 master 分支上的过程
>
> 首先，`git` 会把 `feature1` 分支里面的每个 `commit` 取消掉；
> 其次，把上面的操作临时保存成 `patch` 文件，存在 `.git/rebase` 目录下；
> 然后，把 `feature1` 分支更新到最新的 `master` 分支；
> 最后，把上面保存的 `patch` 文件应用到 `feature1` 分支上；

> **Interactive Rebasing**
>
> 这个命令可以在移动 commit 前改变它们。这比普通的 rebase 更加强大，它提供了对分支提交历史的完整控制。另外，在合并 feature 分支到 master 前，还可以用它来清理混乱的提交历史。
>
> ```text
> $ git checkout feature
> $ git rebase -i master
> ```
>
> 他会打开编辑器列出将要被移动的提交。
>
> ```text
> pick 22d6d7c Commit message#1
> pick 44e8a9b Commit message#2
> pick 79f1d2h Commit message#3
> ```
>
> 它清晰地展示了分支在 rebase 后的样子。通过重新调整，提交历史可以变成任何你想要的样子。如，可以把 `pick` 换成 `fixup` , `squash` , `edit` 等命令。

Git Rebase保持了合并记录的整洁，但它是一个危险的命令，它改变了历史。如果是多人合作的一个分支，不建议使用Git Rebase，容易出现提交记录不一致的错误。

参考文章：

- https://chinese.freecodecamp.org/news/an-introduction-to-git-merge-and-rebase-what-they-are-and-how-to-use-them/



### 提交时发生冲突，解释下开发中冲突是如何产生的，你是如何解决的

我们小组开发过程中，我们都有自己的分支，所以冲突发生的并不多，但也碰到过。

**修改公共文件的时候，一个人先提交一个人再提交就会产生冲突的错误**

发生冲突时，我会和同学沟通，将远程仓库中的内容手动修改到本地，提交冲突文件保证与远程的文件一致，这样才会消除冲突，然后再提交自己的部分

通过一些命令进行解决

1. git stash命令，把工作区的修改提交到栈区，目的是保存工作区的修改
2. git pull命令，拉取远程上的文件合并到本地，目的是消除冲突
3. git stash pop命令，把保存在栈区的修改部分合并到最新的工作区

> 什么时候会使用git stash命令？
>
> - 解决冲突文件时，会先执行git stash，然后解决冲突
> - 遇到紧急开发任务但目前任务不能提交时，会先执行git stash，然后进行紧急任务的开发，然后通过git stash pop取出栈区的内容继续开发
> - 切换分支时，当前工作空间内容不能提交时，会先执行git stash再进行分支切换



### Git的撤销与回滚

**在git commit之前**

在git commit之前，未添加添加到暂存区的撤销：git checkout -- filename来撤销修改

在git commit之前，已添加到暂存区的撤销：git reset HEAD file

**在git commit之后**

使用git revert + commit id(通过git log 查看记录，用reset也行)

> 还有就是如果想回到之前某个版本，可以用reset命令，可以回退到某次提交，那该提交之后的提交都会回滚，不过这种覆盖是不可逆的，之前的提交记录都没有了(但git revert 不会)。所以平时开发中尽量注意，避免使用reset。
>
> 用法：git  reset --hard  commit_id



### 网页加载慢，如何进行前端的性能优化

答5点

**减少HTTP请求次数**，每次HTTP请求都有成本的，既包含时间成本也包含资源成本。另外浏览器进行并发请求的请求数量是有上限的，请求数增多，浏览器会进行分批次请求。如何实现减少HTTP请求呢？

1. 从设计层面简化页面，保持页面简洁，减少资源是最直接的方法
2. 设置合理的HTTP缓存。对于很少变化的图片资源可以设置很长的过期时间，对于变化不频繁的资源可以使用Last-Modified或者E-tag进行验证，尽可能让资源在缓存中呆的久一点
3. 资源的合并与压缩，尽量把外部脚本、样式进行合并，多个合为一个。响应的图片、视频、JS文件、CSS文件都可以使用相应的工具压缩
4. 使用CSS 精灵图 CSS Sprites，合并CSS请求的图片，是减少请求次数的一个好办法，background-position
5. 使用懒加载图片，这种情况下能减少页面初始化时HTTP请求数，只有在用户向下滚动屏幕时才会再次请求加载
6. 使用更高版本的HTTP，在HTTP2中会采用多路复用，浏览器推送等优化机制

**在渲染页面时的优化**

解析html时，遇到一些链接资源，会单独开启下载线程去下载资源

1. 对于CSS资源，虽然下载时异步，不会阻止浏览器构建DOM树，但是会阻塞渲染，在构建render树时，要等待CSS下载完毕后才执行（这里是浏览器自带的优化，避免了重复构建），但声明了media query的CSS不会阻塞渲染
2. 对于JS资源，会阻塞浏览器的解析，只有等待脚本下载完并执行后才会继续解析HTML，但加上了async和defer后，脚本就变成异步的了，可以等HTML解析完毕后再执行

> defer和async是有区别的： **defer是延迟执行，而async是异步执行。**但只要是JS执行，就会暂停HTML解析
>
> - `async`是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在`onload`前，但不确定在`DOMContentLoaded`事件的前或后
> - `defer`是延迟执行，在浏览器看起来的效果像是将脚本放在了`body`后面一样，等待HTML解析完毕后才执行脚本（虽然按规范应该是在`DOMContentLoaded`事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）

合理利用光栅线程和合成线程的机制，这里涉及浏览器相关知识

**通过原生JS的技巧来进行性能优化**

1. 在JS代码解析过程中减少**回流和重绘**，每次回流和重绘会造成额外的计算消耗，通过减少回流和重绘，可以提升页面性能
   1. 最小化重绘和回流，多次修改CSS样式可以改成采用cssText和修改css class；
   2. 批量修改DOM，先让DOM脱离文档流，对其进行多次修改，再将元素带回到文档流中。如隐藏文档，拷贝文档
   3. 使用CSS3硬件加速（GPU加速），让一些动画不会引起回流和重绘
   4. 使用虚拟DOM，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。
2. **事件委托**，通过事件委托减少内存消耗，因为访问的DOM减少了，设置事件处理程序所需时间更少, 加快了整个页面的交互就绪时间，还可以动态绑定事件，减少重复的工作

**使用CDN加速**，能够使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率，就算一个服务器或者源服务器宕机了，还有其他CDN缓存服务器可以提供资源。

​	如何做到加速的呢？CDN 网站的内容缓存在网络边缘。不同地区的用户就会访问到离自己最近的相同网络线路上的CDN节点。当请求达到CDN节点后，节点会判断自己的内容缓存是否有效，如果有效，则立即响应缓存内容给用户，从而加快响应速度。

​	CDN是在DNS解析的过程中起作用的，当给一个域名开通了CDN，要先给**这个域名的DNS解析设置的后台**添加一条CDN专用的解析记录，这条解析记录会让域名被解析后指向**一个CDN网络专用的处理DNS请求的服务器**，这个CDN专用的处理DNS请求的服务器会给浏览器返回**一台专门用来给各个请求分配合适CDN服务器的服务器的IP**地址，这种服务器叫负载均衡系统服务器。然后浏览器就会去访问这台负载均衡系统浏览器，负载均衡服务器会根据你浏览器的网络地址，在CDN网络中找**一台在各种条件下都比较适合给你设备提供服务的服务器**，将这个服务器的IP返回给你的浏览器，那么浏览器在收到这个IP地址后，就会去访问这台CDN服务器了，去请求文件资源了

> 不同地区的用户会访问到离自己最近的相同网络线路上的CDN节点，当请求达到CDN节点后，节点会判断自己的内容缓存是否有效，如果有效，则立即响应缓存内容给用户，从而加快响应速度。如果CDN节点的缓存失效，它会根据服务配置去**一层一层的向上**获取最新的资源响应给用户，并将内容缓存下来以便响应给后续访问的用户，这就意味着一个地区的用户只需要访问一次服务器，后续的用户都能因此受益。

**预解析DNS**。通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以**尽快地完成 DNS 解析**。

​	通过设置X-DNS-Prefetch-Control头控制浏览器的DNS预解析功能。先在meta信息告诉浏览器开启X-DNS-Prefetch-Control，再在link里面强制对DNS进行预解析

> 浏览器会对 a 标签的 href 自动启用 DNS Prefetching，所以 a 标签里包含的域名不需要在 head 中手动设置 link。但是在 HTTPS 下不起作用，需要 meta 来强制开启功能



### 什么是负载均衡

负载均衡是一种策略，将外部发来的请求均匀分配到某一台服务器中，接收到请求的服务器独立地回应客户的请求

优点：

1. 解决网络拥塞问题，服务就近提供，实现地理位置无关性；
2. 为用户提供更好的访问质量；
3. 提高服务器响应速度；
4. 提高服务器及其他资源的利用效率。

常见的软件负载均衡技术有：

1. 基于DNS的负载均衡
2. 反向代理负载均衡
3. 基于NAT的负载均衡

> Nginx的负载均衡常用算法
>
> 1. 轮询
> 2. 加权轮询
> 3. IP哈希
> 4. URL_hash



### Cookie与Session的区别：

1. Cookie与Session都是会话技术（跟踪会话），Cookie保存在客户端上，Session保存在服务器端上，当服务器访问量增多，Session会比较占服务器的性能
2. Cookie有大小限制（3K）以及浏览器存在的Cookie的个数也有限制；理论上来说Session是没有大小限制的，Session大小与服务器内存大小有关
3. Cookie存在安全隐患，通过拦截或本地文件能找到受害者的cookie并利用攻击，所以重要的用户数据存储在session中，cookie可以存储其他数据
4. 若未设置过期时间，cookie的生命周期为浏览器会话时间，若设置了有效期的cookie不会随着浏览器的关闭而消失，而是到了有效期才会消失。Session的默认有效期是30min，服务器可以自己配置。

> 存储的位置
>
> cookie：设置了失效时间的话，存在本地；如果没有设置，就存在浏览器里，可以在设置里面找到存储的cookie
>
> localStorage：每个浏览器都会把localStorage存储在自己的UserData中



### 关于Token

token的意思是“令牌”，是服务器生成的一串字符串，**作为客户端进行请求的一个标识**

> 当用户第一次登录后，服务器生成了一个token并返回这个token给客户端，客户端之后只需要带上这个token前来请求数据即可，无需再带上用户名和密码
>
> 简单的token的组成：
>
> uid（用户唯一的身份标识符），time（当前时间的时间戳），sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串，为防止token泄露）

为什么要使用token？

- Token是无状态、可扩展的，可以在多个服务器之间共享
- Token完全由应用管理，所以它可以避开同源策略
- Token可以避免CSRF攻击

因为http协议是无状态的，为了区别每个用户的信息，现在一般网页用户登录使用Token机制进行区别，如果使用session辨别用户，当用户数量过大时，这是对服务器巨大的开销，而且严重限制了服务器的扩展能力。所以使用token让用户自己存储，每次请求携带，服务器通过Hash算法和密钥进行解析判断，这样服务器的资源开销减小了，也更容易进行扩展。



### HTTP1.0 1.1 2

**HTTP/1.1相比HTTP/1.0性能上的改进：**

1. 长连接(Persistent Connection)： HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。
2. 节约带宽：HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。
3. HOST域：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。
4. 缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
5. 错误通知的管理： 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
6. 支持管道(pipeline)网络传输，只要第一个请求发送出去了，**不必等其回来**，就可以发第二个请求出去，可以减少整体的响应时间

HTTP/1.1的**性能瓶颈**

- 请求/响应头**未经过压缩就发送**，首部信息越多延迟越大。只能压缩body部分
- **发送冗长的首部。**每次互相发送相同的首部造成的浪费较多
- 服务器是按请求的顺序响应的，如果服务器响应不到数据，会导致客户端一直请求不到数据，也就是**队头阻塞**
- **没有请求的优先级控制**
- **请求只能从客户端开始，服务器只能被动响应**



**HTTP2基于HTTP1.1的优化**：

HTTP2协议是基于HTTPS的，所以HTTP2的安全性是有保证的。

1. 多路复用：HTTP/2**是在一个连接中并发多个请求或回应，而不用按照顺序一一对应**。移除了HTTP/1.1中串行请求，不需要排队等待，也不会出现队头阻塞问题，降低了延迟，大幅度提高了连接的利用率。

2. 头部数据压缩：HTTP1.1不支持header数据的压缩，HTTP2.0使用**HPACK算法**对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。

   > 如果你同时发送多个请求，它们的头是一样或者相似的，那么协议会帮你**消除重复的部分**。
   >
   > HPACK算法：在客户端和服务器同时维护一张头信息表，所有的字段都会存入这张表，生成一个索引号，以后就不发同样的字段了，**只发索引号**，这样就提高速度了

3. 服务器推送：**服务端推送是一种在客户端请求之前发送数据的机制**。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。**因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的**。为了改善延迟，HTTP2引入了**server push**，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。

4. 二进制协议：HTTP2不再像HTTP/1.1里的纯文本形式的报文，而是全面采用了**二进制模式**，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。虽然这样对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，**无需再将明文的报文转成二进制，而是直接解析二进制报文，这样增加了数据传输的效率**

5. 数据流：HTTP/2的数据包不是按顺序发送的，同一个连接里面连续的数据包，**可能属于不同的回应**。因此必须要对每个数据包做标记，指出它属于哪个回应。所以每个请求或者回应的所有的数据包，被称为一个**数据流**，每个数据流都有独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。**客户端还能指定数据流的优先级。优先级高的请求，服务器就先响应**。



### HTTP/2有哪些缺陷？HTTP/3做了哪些优化？

HTTP/2的主要问题在于，**多个HTTP请求在复用一个TCP连接**，下层的TCP协议是不知道有多少个HTTP请求的。如果**一旦发生了丢包现象**，就会触发TCP的重传机制，这样在一个TCP连接中的**所有的HTTP请求都必须等待这个丢了的包被重传回来**。

- HTTP/1.1中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了
- HTTP/2多个请求复用一个TCP连接，一旦发生丢包，就会阻塞所有的HTTP请求

**优化**

这是基于传输层的问题，所以**HTTP/3把HTTP下层的TCP协议改成了UDP协议！！！**

因为UDP发送不管顺序，也不管丢包的，所以不会出现上述的阻塞问题

虽然UDP是不可靠传输，但基于UDP的**QUIC协议**可以实现类似TCP的可靠性传输

- QUIC有自己的一套机制可以保证传输的可靠性。当某个流发生丢失时，只会阻塞这个流，**不会影响其他流**
- TLS3**升级成了最新的1.3版本**，头部压缩算法**也升级成了QPack**
- HTTPS要建立一次连接，要花费六次交互，先是建立三次握手，然后是TLS/1.3的三次握手。QUIC直接把以前的六次交互合并成了3次，减少了交互次数

> QUIC是一个新协议，是一个在UDP之上的伪TCP+TLS+HTTP/2的多路复用的协议
>
> 对于很多网络设备来说，根本不知道什么是QUIC，只会被当做UDP来处理，所以现在HTTP/3的普及进度非常慢



### HTTP请求的方法有哪些

HTTP/1.0定义了三种请求方法：GET，POST和HEAD方法

HTTP/1.1新增了五种请求方法: OPTIONS,PUT,DELETE,TRACE和CONNECT方法

- GET: **请求指定的页面信息**，并返回实体主体
- HEAD: 类似于get请求，只不过返回的响应中**没有具体的内容**，只用于获取报头
- POST: **向指定资源提交数据进行处理请求**（如表单提交和上传文件）数据被包含在请求体中。POST请求可能会导致新的资源建立或修改已有的资源
- PUT: 从客户端向服务器传送的数据**取代指定文档的内容**
- DELETE: 请求服务器**删除指定页面**
- CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器？
- OPTIONS: 允许客户端**查看服务器性能**
- TRACE: **回显服务器收到的请求，主要用于测试或诊断**

> 注意：
> 1）**方法名称是区分大小写的**，当**某个请求所针对的资源**不支持对应的请求方法的时候，服务器应当返回状态码405（Mothod Not Allowed）；当**服务器**不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented）
> 2）HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持**扩展自定义的方法**。



### Get和Post的区别

Get和Post实质上没有区别，只是报文格式的不同。

Get和Post只是HTTP协议中两种请求方式，而HTTP协议是基于TCP/IP的关于数据如何在网络上通信的协议。

所以GET和Post的底层也是TCP/IP，能做的事是一样的，要给Get加上request body或者要给post带上url参数，技术上是可以实现的（服务端要能处理）。**HTTP只是个行为准则，规定了Get，Post的语法，而TCP才是GET和POST怎么实现的基本**。

> 注意：
>
> 有些说法说的是Get只产生一个TCP数据包，而Post要产生两个数据包。对于get请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于post，浏览器会先发送header，服务器响应100 continue，浏览器才会再次发送data，服务器响应200
>
> 但是不是说post性能就比get差，在网络好的情况下，一次与两次的区别并不大，而网络不好的情况下，两次TCP都会验证数据完整性，是个非常大的优点。而且不是所有的浏览器都会分开发送，比如firefox chrome就不会，这不是post的必然行为
>
> 注意：
>
> Get方法参数写法不是固定的，在?后面写&只是约定中的写法。服务端解析TCP报文，用正则等工具获取Header和Body，从里面获取参数，所以我们可以自定义约定参数的写法

但是Get和Post在使用时确实是有区别的，但这些区别要么是http协议规定的，要么是浏览器、服务器约束的：

- Get的请求在参数在URL上，而Post在Request Body上，所以Get不能用来传递敏感信息（但实际上都不是安全的）
- Get的请求参数有长度限制，而Post的没有（这是个错误的说法，Get和Post都没有限制，只是浏览器有限制）
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
- Get在回退时是无害的，而Post会再次提交请求
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

.....等等 之类的（后面可答可不答）

- GET产生的URL地址可以被Bookmark，而POST不可以
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。



GET和POST方法都是安全和幂等的吗？

- 在HTTP协议里，所谓的`安全`是指请求方法不会`破坏`服务器上的资源
- 所谓的`幂等`，意思就是**多次执行相同的操作，结果都是相同的**

很明显**GET**方法就是**安全且幂等**的，只是因为它是只读操作，无论操作多次，服务器上的数据都是安全的，且每次结果都是相同的

POST因为是**新增或是提交数据**的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以是不幂等的 



### 详解一下Event Loop事件循环工作机制

首先我们说JS是个单线程的语言，在浏览器的单个Tab页，也就是单个**浏览器渲染进程**中**JS引擎线程**只有一个。

然后JS的代码分为**同步任务**和**异步任务**，同步任务都在主线程（JS引擎线程）上，形成一个**执行栈**。

主线程之外，**事件触发线程**管理着**任务队列**，只要异步任务有了结果，就在**任务队列**之中放置该事件。

而任务队列分为**宏队列**（macrotasks）和**微队列**（microtasks），微任务优先级高于宏任务。

所以

首先执行栈中执行一个宏任务（如果没有就去宏任务队列（事件队列？）中获取）

执行过程中，遇到微任务就添加到微任务队列，遇到宏任务就添加到宏任务队列

执行栈中的任务执行完成后，立即开始执行微任务队列中所有的微任务（调入执行栈中执行）

执行完毕后，开始检查渲染，由GUI线程接管渲染

渲染完毕后，JS引擎线程接管，从宏任务队列中取出下一个宏任务，然后开始执行，没有就开始休眠

以上就是Event Loop事件循环机制

> 有哪些任务会放在microtasks，有哪些会放在macrotasks呢？
>
> - microtasks
>   - process.nextTick
>   - promise
>   - Object.observe (废弃)
>   - MutationObserver（用于监听DOM树结构变化的事件，与Mutation Events不一样）
> - macrotasks
>   - 主代码块
>   - setTimeout
>   - setImmediate
>   - setInterval
>   - I/O
>   - UI 渲染
>
> 上述的事件循环的核心是：JS引擎线程和事件触发线程
>
> 然而还会用到一个线程，定时器触发线程。
>
> 什么时候会用到定时器线程？当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。
>
> 注意，是当读到定时器代码后，定时器线程就开始计时推入，而不是说执行栈执行完了之后才开始计时。



### Node中的事件循环

Node的事件循环是由**libuv**提供的，libuv是Node另外一个重要的基石。

libuv引擎中的事件循环分为6个阶段，会按照顺序反复运行。

每当进入某一个阶段的时候，都会从每个阶段对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设置的阈值时，就进入下一个阶段。

六个阶段分别是

- timers阶段：执行setTimeout,setInterval的回调
- I/O callbacks阶段：处理一些上一轮循环中的少数未执行的I/O回调
- idle,prepare阶段：仅供node内部使用
- poll阶段：获取新的I/O事件，适当条件下node将阻塞在这
- check阶段：node专门处理setImmediate的回调
- close callbacks阶段：执行socket的close事件回调

平时我们学习最主要的就是timers,poll和check这三个阶段

而在node中，微任务是不在事件循环阶段中的，node只有process.nextTick和Promise callbacks两个微任务，都有各自的队列，不属于事件循环的一部分。nextTick的优先级比promise要高。

**timers**:

timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，**在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行**。

**poll**:

取出新完成的 `I/O` 事件；执行与 `I/O` 相关的回调（除了关闭回调，计时器调度的回调和 `setImmediate` 之外，几乎所有这些回调） 适当时，`node` 将在此处阻塞。

poll是一个至关重要的阶段，这一阶段中

poll阶段有两个主要的功能：一是执行下限时间已经达到的timers的回调，一是处理poll队列里的事件。



当事件循环进入poll阶段：

- `poll`队列不为空的时候，事件循环肯定是先遍历队列并同步执行回调，直到队列清空或执行回调数达到系统上限。
- `poll`队列为空的时候，这里有两种情况。
  - 如果代码已经被`setImmediate()`设定了回调，那么事件循环直接结束`poll`阶段进入`check`阶段来执行`check`队列里的回调。
  - 如果代码没有被设定`setImmediate()`设定回调：
    - 如果有被设定的timers，那么此时事件循环会检查timers，如果有一个或多个timers下限时间已经到达，那么事件循环将绕回timers阶段，并执行timers的有效回调队列。
    - 如果没有被设定timers，这个时候事件循环是**阻塞**在poll阶段等待事件回调被加入poll队列。

Poll阶段，当js层代码注册的事件回调都没有返回的时候，事件循环会暂时阻塞在poll阶段，解除阻塞的条件：

> 1. 在poll阶段执行的时候，会传入一个timeout超时时间，该超时时间就是poll阶段的最大阻塞时间。
> 2. timeout时间未到的时候，如果有事件返回，就执行该事件注册的回调函数。timeout超时时间到了，则退出poll阶段，执行下一个阶段。
>
> 这个 timeout 设置为多少合适呢? 答案就是 Timer Phase 中最近要执行的回调启动时间到现在的差值, 假设这个差值是 detal. 因为 Poll Phase 后面没有等待执行的回调了. 所以这里最多等待 delta 时长, 如果期间有事件唤醒了消息循环, 那么就继续下一个 Phase 的工作; 如果期间什么都没发生, 那么到了 timeout 后, 消息循环依然要进入后面的 Phase, 让下一个迭代的 Timer Phase 也能够得到执行.
> Nodejs 就是通过 Poll Phase, 对 IO 事件的等待和内核异步事件的到达来驱动整个消息循环的.
>
> 消息循环也就是事件循环

**check**:
这个阶段只用来处理setImmediate的回调函数

> 在node11版本之前微任务的执行和11版本微任务的执行是不一样的，具体看下方解释

###  Nodejs执行JS代码过程及事件循环过程

- 1、node初始化

  - 初始化node环境
  - 执行输入的代码，执行**同步代码，把各个回调函数放入各个阶段的回调队列中**
  - 执行`process.nextTick`回调
  - 执行微任务(microtasks)

- 2、进入事件循环

  - 2.1、进入`Timer`阶段

    - 检查`Timer`队列是否有到期的`Timer`的回调，如果有，将到期的所有`Timer`回调按照`TimerId`升序执行
    - 检查是否有`process.nextTick`任务，如果有，全部执行
    - 检查是否有微任务(promise)，如果有，全部执行
    - 退出该阶段

  - 2.2、进入`Pending I/O Callback`阶段

    - 检查是否有`Pending I/O Callback`的回调，如果有，执行回调。**如果没有退出该阶段**
    - 检查是否有`process.nextTick`任务，如果有，全部执行
    - 检查是否有微任务(promise)，如果有，全部执行
    - 退出该阶段

  - 2.3、进入idle，prepare阶段

    这个阶段与JavaScript关系不大，略过

  - 2.4、进入`Poll`阶段

    - 首先检查是否存在尚未完成的回调，如果存在，分如下两种情况：
      - 第一种情况：有可执行的回调
        - 执行所有可用回调(包含到期的定时器还有一些IO事件等)
        - 检查是否有`process.nextTick`任务，如果有，全部执行
        - 检查是否有微任务(promise)，如果有，全部执行
        - 退出该阶段
      - 第二种情况：没有可执行的回调
        - 检查是否有`immediate`回调，如果有，退出Poll阶段。如果没有，阻塞在此阶段，等待新的事件通知，有限时

  - 2.5、进入`check`阶段

    - 如果有immediate回调，则执行所有immediate回调
    - 检查是否有`process.nextTick`任务，如果有，全部执行
    - 检查是否有微任务(promise)，如果有，全部执行
    - 退出该阶段

  - 2.6、进入`closing`阶段

    - 如果有immediate回调，则执行所有immediate回调
    - 检查是否有`process.nextTick`任务，如果有，全部执行
    - 检查是否有微任务(promise)，如果有，全部执行
    - 退出该阶段

- 3、检查是否有活跃的`handles(定时器、IO等事件句柄)`

  - 如果有，继续下一轮事件循环
  - 如果没有，结束事件循环，退出程序

**注意：**

事件循环的每一个子阶段退出之前都会按顺序执行如下过程：

- 检查是否有 process.nextTick 回调，如果有，全部执行。
- 检查是否有 微任务(promise)，如果有，全部执行。

随着Node v11版本的发布，一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这样就和浏览器的事件循环保持了一致，而Node v11版本之前只有阶段结束后才执行微任务队列

关于poll阶段还有些许疑问，后续要继续学习

阅读的几篇博客及原文：

https://juejin.cn/post/6844903761949753352#heading-0

https://juejin.cn/post/6844904137662922760#heading-0

https://segmentfault.com/a/1190000018730085



### JavaScript的类型

JS的类型分为两种

- 原始数据类型：布尔值，数值，字符串，null，undefined和新类型Symbol,BigInt
- 对象类型

**JS中的错误类型有**

1. SyntaxError 语法错误
2. ReferenceErro 引用错误
3. RangeError 范围错误
4. TypeError 类型错误
5. URLError URL错误：主要是相关函数的参数不正确。
6. EvalError eval错误： 当eval()函数没有被正确执行时，会抛出evalError错误。但是ES5以上的JS已经不再抛出这个错误，但依然可以通过new关键字来自定义该类型的错误提示

这些错误，连同原生Error都是构造函数，可以自己生成错误对象的实例

```javascript
throw new Error('出错了！');
throw new TypeError('类型错误！');
```



### JavaScript中this

this是在运行时进行绑定的，并不是编写时绑定的，它的上下文取决于函数调用时的各种条件。

也就是说 **this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。**

> 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈），函数的调用方式、传入的参数等信息。this就是这个记录中的一个属性，会在函数执行的过程中用到。

调用位置：函数在代码中被调用的位置，其决定了this的绑定。

最重要的就是分析调用栈（就是为了达到当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。

学习四种绑定规则

**默认绑定**

是最常用的**独立函数调用**，在无法应用其他规则时的默认规则，就是根据调用位置决定的this

如果是严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined

**隐式绑定**

**显示绑定**

**new绑定**

《你不知道的JavaScript 上卷》



### 防抖和节流

防抖和节流都有一个共同的概念：通过限制调用次数来进行**性能优化**

**防抖**

触发事件一定时间后才会执行，如果在这段时间内再一次触发了这个事件，则重新计时这段时间

```javascript
function debounce(fn,delay = 3000){
	let timer = null;
    return (...args) => {
		if(timer) clearTimeout(timer); 
        timer = setTimeout(() => {
            fn(...args);
        },delay);
    }
}
```

> 代码一步一步、一行一行的说，说的过程中可以提及一些已经改进的代码，比如timer私有变量写在内部，使用扩展运算符，箭头函数

**节流**

每隔一段时间内，事件只触发一次

节流会稀释事件执行频率

```javascript
function throttle(fn , delay = 3000){
	let timer = null;
    return (...args) => {
        if(timer) return;
        timer = setTimeout(() =>{
            fn(...args);
            timer = null;
        },delay);
    }
}
```

相同点：目的都是降低回调次数，节省资源；

不同点：防抖关注一定时间内连续执行的事件，只执行最后一次；节流侧重于一段时间内，只执行一次

**应用场景**：

防抖：手机号，邮箱号的输入；窗口大小的调整，防止重复渲染

节流：滚动加载；表单的多次提交



### 事件委托

事件委托，就是把一个元素的响应事件委托到另外一个元素

一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。

关键点，使用e.target

e.target属性返回事件对象的目标结点（也就是触发该事件的节点）

```javascript
var ul = document.querySelector('ul');
ul.addEventListener('click',function(e){
    Array.from(ul.children).forEach(element => {
        element.className = '';
    });
    e.target.className = 'bk';
})
```

当需要精准匹配的时候，使用Element.matches

Element.matches(selectorString)   selectorString 既是 CSS 那样的选择器规则，比如本例中可以使用 target.matches('li.class-1')，他会返回一个布尔值，如果 target 元素是标签 li 并且它的类是 class-1 ，那么就会返回 true，否则返回 false。

```javascript
var ul = document.querySelector('ul');
ul.addEventListener('click',function(e){
    if(e.target.matches('li.c1'))
        e.target.className += ' bk';
})
```

这种方法存在兼容性问题，需要IE9及以上的现代化浏览器版本

可以使用**Polyfill**来解决兼容性上的问题

**好处**：

1. 减少内存消耗，不用一个函数一个元素的绑定，对列表每一个元素都绑定，对于内存消耗较大
2. 因为访问的DOM减少了，设置事件处理程序所需时间更少, 加快了整个页面的交互就绪时间
3. 动态绑定事件，减少重复的工作

**局限性**：

1. 事件委托基于冒泡，不冒泡的事件不支持事件委托，如focus、blur之类的事件本身并没有冒泡机制，无法委托
2. 层级过多的情况下，冒泡过程可能被中间层阻止
3. 当事件委托过多时，可能会出现事件误判，即不该触发该事件的元素被绑定了



### JS中的new关键字

JS中的new关键字会进行以下操作：

1. 创建一个空的简单JS对象，即{}
2. 为新建的对象添加\__proto__，将该属性链接至构造函数的原型对象（修改原型链）
3. 将新建的对象作为传入函数的this上下文（this绑定）
4. 如果构造函数内部显示返回对象数据类型，则返回该数据；否则返回新创建的对象

> 如果原本的构造函数内部返回基础类型，那么最后new的返回值还是创建的对象
>
> 如果是返回的一个对象，则new返回这个对象（对应第四条）

 手写一个new

```javascript
    function _new (fn,...args){
        const obj = Object.create(fn.prototype);
        const res = fn.apply(obj,args);
        return res instanceof Object ? res : obj;
    }
```

> 这里不能用typeof进行类型判断
>
> 因为用typeof去判断null，得到的结果是'object'
>
> 这是一个JS自己的bug，null应该是原始数据基本类型。
>
> 而instanceof 是看被判断的数据（实例对象）的原型链上是否有后面这个构造函数的原型对象，就不会出现误判null为object的情况

**为什么typeof null === ‘obejct’ ？**

在 JavaScript 最初的实现中，JavaScript 中的值是由**一个表示类型的标签**和**实际数据值**表示的

对象的类型标签是 0。但由于 null 代表的是空指针（大多数平台下值为 0x00），因此，**null 的类型标签也是 0**

typeof判断是判断其类型标签，typeof null 也因此返回 "object"。

参考文章：

- 详解 JS 中 new 调用函数原理 https://juejin.cn/post/6844903630605123598
- MDN typeof https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#null



### 闭包

闭包就是指**有权调用另一个函数作用域中变量的函数**（外面的这个函数，不是返回的函数）

**闭包的主要作用是**

- 延伸了变量的**作用范围**
- 隐藏变量，避免了**全局污染**

**闭包的危害**

- 不恰当的使用闭包可能会造成内存泄露的问题

为什么会发生内存泄露？

JS规定在一个函数作用域中，程序执行完后变量就会被销毁，这样可以节省内存（JS的垃圾回收机制）。而使用闭包时，由于作用域链的特点，变量一直不会被销毁，因为会被函数一直调用，从而造成了内存泄露

> 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。



### JS的垃圾回收机制（GC）

JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理

一般来说，垃圾回收器有自己的回收策略

譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）

JS常用的两种垃圾回收规则是：

- 标记清除
- 引用计数

JS引擎基础GC方案是**mark and sweep**（标记清除）,简单的解释如下：

1. 遍历所有可访问的对象
2. 回收已不可访问的对象

> 当变量进入环境时，例如声明一个变量，就将这个变量标记为“进入环境”
>
> 从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们
>
> 而当变量离开环境时，则将其标记为“离开环境”
>
> GC会在运行的时候会给存储在内存中的所有变量加上标记
>
> 然后它会去掉环境中的变量和被环境中变量引用的变量（相关应用变量）的标记（比如闭包）
>
> 在此之后被加上标记的变量就会视为准备被删除的变量，原因是环境中的变量已经无法访问到这些变量了
>
> 最后垃圾回收期完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间
>
> （和可达性分析算法类似）



关于**引用计数**

跟踪记录每个值被引用的次数，当一个值被引用时，次数`+1`，减持时`-1`，下次垃圾回收器会回收次数为`0`的值的内存（当然了，容易出循环引用的内存泄露）

> 什么是循环引用？
>
> 当对象 1 中的某个属性指向对象 2，对象 2 中的某个属性指向对象 1 就会出现循环引用，（当然不止这一种情况，不过原理是一样的）
>
> 如果出现上述情况，代码执行完后，会将变量赋值为null，引用完后变量计数都为1，并不为0，并不会进行垃圾回收，就会造成内存泄露



**GC的缺陷**

和其他语言一样，JS的GC策略避免一个问题：**GC时，停止响应其他操作**

这是为了安全考虑。

而JS的GC在**100ms甚至以上**

对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。

这就是引擎需要优化的点： **避免GC造成的长时间停止响应。**

> 只要采用标记清除方法，就会产生内存碎片，需要对内存碎片进行处理（内存调整，或者说是用空链表记录）这里我还不知道JS怎么处理这个内存碎片。



**GC优化策略**

这里要用到：**分带回收**

目的是通过区分“临时”与“持久”对象：

- 多回收“临时对象”区
- 少回收“持久对象”区
- 减少每次需要遍历的对象，从而减少每次GC的耗时



### JS内存泄露的四种方式及如何解决？

内存泄露是很多问题的根源：反应迟钝，崩溃，高延迟以及其他应用问题

**常见的JS内存泄露**

- 意外的全局变量，如在函数里不用var 就声明变量，或者直接用this.param声明变量

> 在 JavaScript 文件头部加上 `'use strict'`，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。
>
> 尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于 临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，**确保用完以后把它设置为 null 或者重新定义**。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。

- 被遗忘的计时器或回调函数（不懂）
- 脱离DOM的引用（不懂）
- 闭包

**解决方法**

- 优化代码逻辑，避免出现上述的JS泄露情况，及时将不需要的变量赋为null或者重新引用
- Chrome内存剖析工具概览Timeline和Profiles
- 使用ES6推出的新的数据结构：WeakSet和WeakMap。它们对值的引用是弱引用，不计入垃圾回收机制（这里针对引用计数机制）



### 简述一些操作数组的函数

简单的、常见的有

- concat 连接两或者更多的数组
- push 数组末尾添加元素
- pop 删除数组最后一个元素
- shift 删除数组第一个元素
- unshift 数组开头添加元素
- sort 排序
- toString 转换成字符串
- for...of   for...in（一般不用）  forEach() item index arr

等等一堆函数

ES6新增的有

- from 把类数组转换成真正的数组
- find 用于找出第一个符和条件的成员，里面是个回调函数 item index  arr
- findIndex 在find的基础上变成了找位置
- includes 是否包含给定的值

**for...of 和for...in有什么区别**

for in是遍历对象的属性名（键名），所以用for in遍历数组时，拿到的是每个元素的索引。一般不用在数组里，用于对象的遍历。

for of是遍历对象的属性的值（键值），只能用于可迭代的数据（涉及迭代器知识），包括数组，set，map，字符串，不包括对象。



### Node.js 和 JS的区别

> Node.js是基于V8引擎的运行环境，是一个能让JS**运行在服务器端的平台**，让JS成为PHP、Python等服务端语言平起平坐的脚本语言
>
> Node.js就是把浏览器的解释器封装起来作为服务器运行平台，用类似JavaScript的结构语法进行编程，在Node.js上运行

1. Node.js是平台，JS是编译语言

2. JavaScript组成：ECMAScript, DOM, BOM

   Node.js组成：ECMAScript, OS, file, net, database

3. 顶层对象不同，JS的顶层对象是window，node的顶层对象是global



### 数组与字符串的一些常用方法

都有的方法有：

param.concat 给param连接一个或多个，不改变param，返回新的字符串（字符串可以使用 + ，更方便，但大量的+拼接字符串比较耗时）









### 设计模式

**工厂模式**

不暴露创建对象的具体逻辑，而是将逻辑装在一个函数中，这个函数被视为一个工厂

分类：简单工厂模式，工厂方法模式，抽象工厂模式

**简单工厂模式**可以解决多个相似的问题，一个工厂对象来创建某一类产品的实例

**工厂方法模式**是创建多类产品的实例，写在原型对象上

**抽象工厂方法**是对类的工厂的抽象，用于创建工厂和工厂中的类

应用：AJAX的封装

**单例模式**

保证一个类仅有一个实例，并且提供一个可以访问它的访问点

只能被实例化(构造函数给实例添加属性与方法)一次

用一个变量（锁）来实现

应用：模态框，弹窗

**安全沙箱模式**

将一个函数放在立即执行函数里，用变量接收闭包暴露的接口。这样才能调用里面的值

沙箱里面不会受到外界影响，全局污染，相对来说算是安全的

应用：只受函数调用的计数器

**观察者模式（发布者订阅模式）**

当一个对象的状态发生改变时，所有依赖它的对象都会得到通知

定义一个发布者，为发布者添加一个列表，里面存放要通知的对象的回调函数，当发布者变动时，遍历这个列表，触发里面的函数

记得修改this指向

应用：JS很多的事件如onclick，vue（一般不要回答）

**构造函数模式**

就是最常使用的构造函数

应用：很多，ES6之前的继承就可以通过构造函数和原型对象来实现

**代理模式**

为一个对象提供一个代用品或占位符，以便控制对它的访问

某一个开销很大的操作，可以通过虚拟代理的方式延迟到**需要它的时候才创建**

应用：图片懒加载

https://xie.infoq.cn/article/88c926822394aa1c80847dd2a

https://juejin.cn/post/6844903653774458888



### 原型链和原型链继承	

首先，JS规定每个一个构造函数都有一个prototype属性，指向一个对象，这个对象被称为原型对象，该对象上的方法和属性，都会被其构造函数所拥有，每一个构造函数都有一个原型对象。

每一个构造函数所创建的实例对象，都有一个__proto属性指向构造函数的原型对象，这样每个对象也可以访问prototype上的方法和属性。三者的关系就如同一个三角形一般。

而原型链，简单的说就是用原型组成的链。

因为构造函数的prototype里也有一个__proto属性，它指向的是创建prototype这个对象的构造函数的原型对象，一般来说也就是Object构造函数的原型对象。

Object，Object的原型对象，某个对象的原型对象，这三者的关系与前面提到的关系是一样的。

Object的原型对象的__proto则指向null。而这一系列属性的指向，如同链一样把原型给链接起来了，这就形成了一个原型链。

**原型链继承**

在ES6之前，没有class和extends，只能用构造函数和原型对象**模拟实现继承**，也叫组合继承

首先要用到call或者apply函数，这两个函数可以修改执行某个函数的this指向

在构建子类的构造函数时，用call或者apply调用父类构造函数，再通过修改子类构造函数的原型对象，将其构造成父类的原型方法（new Father()  改constructor），这样就获得了父类的属性方法，而自己的属性方法照常实现，这样就模拟了继承

从**本质上**来看ES5的继承实质就是在创建子类实例对象后，再把父类的方法属性添加到新建的这个this上

> ES6的继承机制完全不同，**实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this**。要用到super方法
>
> static不能被子类的实例继承，也不能被自身实例继承，但可以直接通过构造函数（子类父类但可以）来调用
>
> 如何像JAVA一样通过设置私有方法让子类不能继承到父类的某些方法呢？



### 简述一下浏览器获得URL，到页面加载的过程

URL域名解析 —— DNS域名解析 —— TCP连接 —— 请求传输数据 —— 浏览器解析渲染页面 —— 关闭TCP连接

1.首先

输入URL后，会对URL进行解析。浏览器解析出的协议，开辟一个**网络请求线程**去请求资源

2.然后

如果输入的是域名，需要用DNS去查询IP

- 如果浏览器有缓存，直接使用浏览器缓存，否则使用本地缓存
- 如果本地没有，就向DNS域名服务器查询，（中间可能经过路由，也有缓存），查询到对应的IP

> **浏览器缓存（chrome://net-internals/#dns查看） -> 系统缓存（一般存放在C盘里hosts.sam文件里面） -> 路由器缓存 -> ISP（互联网服务提供商） DNS缓存 -> 递归搜索**

3.查询到对应的IP后

拿最常见的http协议举例，通过80端口，在传输层与服务器端建立三次握手，建立成功后才开始正式传输数据。经过网络层**IP封装**，数据链路层**封装成帧**，物理层**物理传输**

4.服务器接收到请求后，内部进行处理，返回一个http响应包，这个包也是经过多层封装发送到客户端

> 前后端交互时，http报文作为信息的载体，http十分重要，这里不详细讲

5.浏览器获取到html文件，然后开始

- 解析HTML，生成DOM树
- 解析CSS，生成CSS规则树
- 合并DOM树和CSS规则，生成render树
- 布局render树，绘制页面像素信息
- 浏览器会将各层的信息发送给GPU，GPU会将各层合成，显示在屏幕上

> 在解析HTML中，会遇到一些需要请求的外链资源，会单独开启一个下载线程去下载资源
>
> 如CSS样式资源，JS脚本资源，img图片类资源，各有特点，此处不详细讲

6.开始JS引擎解析过程

7.执行完后页面渲染结束，在浏览器中显示给用户



### DNS为什么即使用TCP又使用UDP？

首先UDP报文最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节后，协议的TC标志出现删除标志，这时则使用TCP发送。

我了解的，DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议

域名解析时使用UDP协议：

客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器**负载更低，响应更快**。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，**很多DNS服务器进行配置的时候，仅支持UDP查询包**。

> 区域传输：DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中**主DNS服务器从自己本机的数据文件**中读取该区的DNS数据信息，而辅助DNS服务器则**从区的主DNS服务器中**读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就交区域传输



### HTTP报文格式

**HTTP请求报文**

- 请求行（request line）：请求方法  URL 协议版本
- 请求头部（header）：许多key-value的值，如Accept-Encoding，User-Agent
- 空行(CR+LF) ：请求报文中空行表示header和请求数据的分割
- 请求数据（request data） ： GET方法不会携带数据，POST方法会携带一个body

**HTTP响应报文**

- 状态行：HTTP版本号 状态码 状态值组成
- 响应头类似请求头，是一系列的key-value值
- 空行：同上，响应报文也用空白行来分隔header和数据
- 响应体：响应的data



### HTTP常见字段有哪些？

**Host字段：**客户端发送请求时，用来指定服务器的域名

> Host：www.A.com

**Content-Length字段：**服务器在返回数据时，会有Content-Length字段，表明本次回应的数据长度

> Content-Length:1000

**Connection字段：**最常用于客户端要求服务器使用TCP持久连接，以便其他请求复用，HTTP/1.1默认连接都是持久连接，但为了兼容老版本，需要制定Connection字段值为Keep-Alive

> Connection:Keep-Alive

这不是一个标准的字段

**Content-Type字段：**用于服务器回应时，告诉**客户端本次数据是什么格式**

> Content-Type:text/html;charset = utf-8
>
> 发送的是网页，编码是utf-8

客户端请求的时候，可以用**Accept**字段声明自己可以接受哪些数据格式

> Accept:*/*
>
> 客户端声明自己可以接受任何格式的数据

**Content-Encoding：**说明**数据的压缩方法**。表示服务器返回的数据使用了什么压缩格式

> Content-Encoding:gzip
>
> 表示服务器返回的数据采用了gzip方式压缩，告诉服务端需要采用此方式解压

客户端在请求时，可以用Accept-Encoding字段说明自己可以接受哪些压缩方法

> Accept-Encoding：gzip,deflate

**User-Agent ：**用户代理，一个特殊字符串头，是一种**向访问网站提供**你所使用的浏览器类型及版本、操作系统及版本、浏览器内核等信息的标识。

> 但是我们可以人为的修改或者添加一些信息在这里面。标记当前所在的环境，比如在哪一个客户端环境下，是在QQ里，还是微信，还是钉钉下。一般用于镶嵌在客户端或者小程序里的h5页面里



### Content-Type具体有什么格式类型

常见的媒体类型格式：

1. text/html HTML格式
2. text/plain 纯文本格式
3. text/xml XML格式
4. image/gif gif图片格式
5. image/jpeg jpeg图片格式
6. image/png png图片格式

以application开头的媒体格式类型：

1. application/json JSON数据格式
2. application/x-www-form-urlencoded 最常见的 POST 提交数据的方式了，浏览器的原生 form 表单，提交的数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码
3. application/pdf pdf格式
4. application/msword word文档格式
5. application/xml XML数据格式
6. application/octet-stream 二进制流数据（如常见的文件下载）

另一种常见的媒体格式是上传文件的时用到的

multipart/form-data 需要在表单中进行文件上传，就需要使用该格式

> charset = utf-8 后面还可以跟个charset，表示编码是什么，比如这里就表示编码是utf-8



### HTTP特点

HTTP最凸出的优点是：简单，灵活和易于扩展、应用广泛和跨平台

1. HTTP基本报文就是header+body，头部信息也是key-value简单文本格式，易于理解，**简单**易懂
2. HTTP协议里各类请求方法，状态码，头文字等每个组成都没有被固定死，**允许开发人员自定义和扩充**
3. HTTP的应用范围非常广泛，天然具有跨平台的优越性
4. 支持B/S及C/S模式？

缺点：

1. HTTP是无状态的协议
2. HTTP信息是明文传递，虽然在调试时提供了极大的便利性，但存在安全问题



### HTTP和HTTPS的区别

1. HTTP是超文本传输协议，信息是明文传输，存在信息安全风险问题。HTTPS解决了HTTP不安全的缺陷，在TCP和HTTP之间加入了SSL/TLS安全协议，使得报文能够加密传输
2. HTTP连接建立相对简单，TCP三次握手后便可以进行HTTP的报文传输。而HTTPS在TCP三次握手后，还要进行SSL/TLS的握手过程，才能进行加密的报文传输
3. HTTP的端口号是80，HTTPS的端口号是443
4. HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的



### HTTPS是如何解决HTTP的安全问题的？

HTTP存在的安全问题：**窃听风险，篡改风险，冒充风险**

HTTPS很好的解决了上述风险：**信息加密，校验机制，身份证书**

1.**混合加密的方式实现信息的机密性，解决了窃听的风险**

HTTPS采用的是**对称加密**和**非对称加密**结合的混合加密方式：

- 在通信建立前采用非对称加密的方式交换会话秘钥，后续就不再使用非对称加密。
- 在通信过程中全部使用对称加密的会话秘钥的方式加密明文数据

采用混合加密的方式原因：

- 对称加密只使用一个密钥，虽然运算速度快，但密钥必须保密，无法做到安全的密钥交换
- 非对称加密使用公钥和私钥，公钥可以任意分发而私钥保密，虽然解决了密钥交换的安全问题，但运算速度慢

HTTPS就结合这个两种加密方式，先使用非对称加密保证密钥交换的安全，等生成了会话密钥后因无需进行密钥交换，这时候就使用对称加密

> 对称加密：就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。
>
> 如DES,AES,3DES等
>
> 非对称加密：加密和解密使用不同的秘钥，一把作为公开的秘钥（公钥），另一把叫做私钥。公钥加密的信息，只有私钥能解密；私钥加密的信息，只有公钥能解密。
>
> 如RSA,ECC等

2.**摘要算法的方式来实现完整性，它能够为数据生成独一无二的`指纹`，指纹用于校验数据的完整性，解决了篡改的风险**

客户端在发送明文前会通过摘要算法算出明文的指纹，然后把`指纹 + 明文`一同加密发送，服务器解密后，用相同的摘要算法算出发送过来的明文的指纹，通过比对指纹判断数据是否完整

3.**将服务器公钥放入数字证书中，解决了被冒充的风险**

客户端向服务器索要公钥，然后用公钥加密，服务器收到密文后，用自己的私钥解密。

为了保证客户端索要的公钥没有被篡改，需要借助第三方权威机构CA，服务器将自己的公钥放在数字证书里，只要证书可信（本地的CA公钥来判断），公钥就是可信的。



### SSL/TLS协议建立的详细流程

1. 首先客户端要向服务器发起加密请求（**ClientHello**），发送以下信息：

   - 客户端支持的SSL/TLS协议版本
   - 客户端生成的随机数A
   - 客户端支持的密码套件列表，如RSA加密算法

2. 服务器收到客户端请求后，向客户端发出响应（**SeverHello**），响应以下信息：

   - 确认SSL/TLS协议版本，如果浏览器不支持，则关闭加密通信
   - 服务器生成的随机数B
   - 确认密码套件列表
   - 服务器的数字证书

3. 客户端收到这些信息后，首先通过浏览器或者操作系统中**早已备好**的CA公钥，确定**数字证书的真实性**。如果证书没问题，客户端会从数字证书中取出公钥（服务端的），**用这个公钥来加密报文**，向服务器发送这些信息：

   - 一个被服务器公钥加密随机数C
   - 加密通信算法改变的通知，表示之后的信息都会用会话密钥加密通信
   - 客户端握手结束的通知，同时把之前所有的内容数据发个摘要，用于服务端校验

   这样整个握手阶段就有三个随机数ABC了，接着就**用双方协商的加密算法，各自生成本次通信的会话密钥**

4. 服务器收到客户端的第三个随机数C后，通过加密算法，生成会话密钥。然后向客户端发送最后的信息：

   - 加密通信算法改变的通知，表示之后的信息都会用会话密钥加密通信
   - 服务器握手结束的通知，同时把之前所有的内容数据发个摘要，用于客户端校验

至此，整个SSL/TLS的握手阶段全部结束。接下来服务器和客户端进入加密通道，就是完全使用普通的HTTP，只不过用**会话密钥加密内容**



### HTTP缓存

按缓存的位置上来看，可以分为四种，从上往下依次检查是否命中，如果但都没有命中则重新发起请求。

- **Service Worker**是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用Service Work的话，传输协议必须是https

- **Memory Cache**是内存中的缓存，主要包含的是当前页面已经抓取到的资源，例如页面上下载的样式，脚本，图片等。读取内存的数据肯定比读取磁盘快，但内存数据虽然高效，缓存持续性很短，会随着进程的释放而释放。一旦我们关闭了tab标签页，内存中的缓存也就被释放了。

  > 内存缓存中有一块重要的缓存资源是preloader相关指令下载的资源。它可以一边解析js/css文件，一边网络请求下一个资源。

- **Disk Cache**是存储在硬盘中的缓存，读取速度较慢，但什么都能存储到磁盘中，比Memory Cache胜在容量和存储时效性上。

  > 绝大部分的缓存都来自Disk Cache，在HTTP头中设置

- **Push Cache**是推送缓存，是HTPP/2中的内容，当以上三种缓存都没命中时，它才会使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在chrome浏览器中只存在5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

缓存又分为两大类型：**强缓存和协商缓存**

区别：

- 强缓存时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求  200 from cache
- 协商缓存，浏览器会向服务器发起http请求，然后服务器告诉浏览器文件未改变，让浏览器使用本地缓存 304

关于缓存的http头部字段简述：

属于**强缓存控制**的：

http/1.0  

**Pragma**

Pragma严格来说不是专门缓存控制头部，但它设置no-cache时可以让本地强缓存失效

指令：

no-cache

与 Cache-Control: no-cache 效果一致。强制要求缓存服务器在返回缓存的版本之前将请求提交到源头服务器进行验证（协商缓存）。

**Expires**

Expires响应头包含日期/时间， 即在此时候之后，响应（缓存）过期。

指令：

一个 HTTP-日期 时间戳

Expires是服务器端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存。



http1.1 

**Cache-control** 

Cache-Control通用消息头字段，被用于在http请求和响应中，通过指定指令来实现缓存机制。

指令：

可缓存性

- public，表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。
- private，表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。
- no-cache，在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。
- no-store，缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。

到期

- max-age=\<seconds\>  设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，max-age时间是相对于**请求的时间**。
- s-maxage=\<seconds> 覆盖max-age或者Expires头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它

重新验证和重新加载

- must-revalidate 一旦资源过期（比如已经超过`max-age`），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。（告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。）
- proxy-revalidate 与 must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。

其他

- no-transform 不得对资源进行转换或转变。`Content-Encoding`、`Content-Range`、`Content-Type`等HTTP头不能由代理修改。
- only-if-cached 表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。

> 还有很多指令，这里只有一部分

指定 `no-cache` 或 `max-age=0, must-revalidate` 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。(也就是协商缓存)

如果cache-control与expires同时存在，cache-control的优先级高于expires



属于**协商缓存控制**的：

协商缓存需要跟服务端通过特殊标示连接，即第一次请求的响应头带上某个字段（**Last-Modified**或者**Etag**），则后续请求则会带上对应的请求字段（**If-Modified-Since**或者**If-None-Match**），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。

http1.0 If-Modified-Since/Last-Modified

If-Modified-Since/Last-Modified成对出现，属于协商缓存的内容，在发起请求时，如果`If-Modified-Since(浏览器的头部)`和`Last-Modified(服务器的头部)`**匹配**，**那么代表服务器资源并未改变，因此服务端不会返回资源实体**，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified 顾名思义，指的是文件最后的修改时间

1. 浏览器第一次跟服务器请求一个资源，respone的header里加上Last-Modified：**表示这个资源在服务器上的最后修改时间**
2. 浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header：上一次请求时返回的Last-Modified的值
3. 服务器再次收到资源请求时，会判断**最后修改时间**是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容，Last-Modified会被修改为最新的值。如果没有变化，服务器返回304 Not Modified，Last-Modified不会修改，response header中不会再添加Last-Modified的header
4. 浏览器收到304的响应后，就会从缓存中加载资源



http1.1 If-None-Match/E-tag

If-None-Match/E-tag，这两个是成对出现的属于协商缓存的内容，其中浏览器的头部是`If-None-Match`，而服务端的是`E-tag`，同样，发出请求后，如果`If-None-Match`和`E-tag`匹配，则代表内容未变，通知浏览器使用本地缓存。

由服务器生成的**每个资源的唯一标识字符串**，只要资源有变化就这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个**ETag返回**，即使这个ETag跟之前的没有变化。

1. 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
3. 某些服务器不能精确的得到文件的最后修改时间。

Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。



**区别**

- Max-Age相比Expires的话，Expires使用的是服务器端的时间，而Max-Age是相对于客户端请求的时间。如果出现客户端和服务器时间不同步，使用Expires会造成浏览器本地缓存无效或一直无法过期
- E-tag和Last-Modified
  - Last-Modified表示服务端文件最后何时改变，只能**精确到1s**，有些改变频繁的文件，在秒以下的时间内进行了修改，而Last-Modified精准度不够，导致缓存失效
  - E-tag是一种指纹机制，代表文件的相关指纹，**没有时间限制**，只要文件一遍，E-tag立马改变



浏览器请求过程：有无缓存 -> 强缓存 -> 协商缓存

**缓存头优先级：Cache-Control > Expires > Etag > Last-Modified**

顺序访问图参考：https://segmentfault.com/a/1190000017311517

关于Cache-Control/Etag存在拿去验证后，是否还需要去验证Expires/Last-Modified，存疑



如何明确禁止缓存？

Pragma: no-cache(让本地强缓存失效，效果和Cache-Control: no-cache类似)

Cache-Control: no-store



**用户对缓存的影响**

- 地址栏输入地址，先查看Disk Cache中是否匹配，没有匹配则发送网络请求。
- 普通的刷新F5，优先使用Memory Cache，其次才是Disk Cache
- 强制刷新Crtl + F5，浏览器不适用缓存

| 用户操作        | Expires/Cache-Control | Last-Modified/Etag |
| --------------- | --------------------- | ------------------ |
| 地址栏回车      | 有效                  | 有效               |
| 页面链接跳转    | 有效                  | 有效               |
| 新开窗口        | 有效                  | 有效               |
| 前进后退        | 有效                  | 有效               |
| F5刷新          | 无效                  | 有效               |
| Ctrl+F5强制刷新 | 无效                  | 无效               |



### Vue2.x和Vue3的区别

1. **数据的双向绑定原理不同**

   2.x使用的是Object.defineproperty()进行数据劫持，结合发布订阅者模式实现的

   而3使用的是es6提供的proxy API进行数据代理

   > 使用proxy的好处：
   > Object.defineproperty()只能监听对象的某一个属性，不能全对象监听，需要使用遍历，递归的方式处理对象，而proxy可以直接绑定整个对象，且不用对数组进行特异性处理，proxy可以监听数组内部数据变化

2. **使用了懒观察模式**

   在2.x中不管数据有多大，都会在一开始为其创建观察者。当数据很大的时候，这可能会在页面载入时造成明显的性能压力。

   在3版本中，只会对用于页面初始加载的数据创建观察者，所以3版本的观察者更高效

3. 重写了**虚拟DOM的实现和Tree-Shaking**

4. **新增了一些特性**

   生命周期钩子函数出现了很大的不同，2.x中的beforeCreate和created都变成了setup，后续的生命周期钩子也发生了改变。

   新的Composition（组合）API，新的一些组件，比如文档碎片Fragment，还有语法上的更新等等



### Vue工作原理

比如 一个输入框 输入文本后 怎么更新数据呢



### Vue-router有哪些模式

vue-router有三种模式：

1. hash模式：后面hash值的变化，浏览器既不会向服务器发出请求，浏览器也不会刷新，每次hash的值的变化会触发hashchanged事件
2. history模式：利用了HTML5中新增的pushState和replaceState方法，这两方法应用于浏览器的历史记录栈，提供对历史记录修改的功能。只是当它们修改时，虽然改变了当前的URL，但浏览器不会立即向后端发送请求
3. abstract模式：适用于所有JavaScript环境，例如服务器端和Node.js. 如果没有浏览器API，路由器将自动强制进入此模式。



### 项目中的亮点

**大文件的断点续传**

首先利用**Spark-md5**插件获取每个文件唯一的hash表示码，把文件解析为**buffer**数据类型。

> 通过FileReader进行解析，用FileReader.readAsArrayBuffer把文件转换成buffer格式数据（这是异步的）
>
> 再返回FileReader.onload的事件对象的e.target.result，这就是我们要的文件buffer数据

然后使用Math.ceil函数对文件进行切片，创建一个切片列表，将所有切片push进去。

然后根据切片列表，创建一个请求列表，列表里面每一个函数都是发送一个切片的请求，每次请求都会带上每一片的序号（按需），和整个文件的hash标识

存在文件上传状态的变量，根据这个变量判断是否上传，这样能实现文件上传暂停功能

存在文件片上传片数的记录变量，只有切片请求列表每一次上传成功后，变量才会累加，防止文件切片丢失

在开始上传前会对这个文件（利用唯一hash表示码）在服务端的状态进行判断（发送请求），会返回这个文件是否存在，如果存在，则片数记录变量直接等于切片数，通知服务器合并文件，实现秒传效果；如果不存在或者只传了n片，则从0片或者从n+1片开始传，实现断点续传的效果

**RBAC权限管理**

RBAC是基于角色的权限控制，这个模式的核心在于用户和权限之间引入了角色的概念。用户和权限没有直接的关联，而是给用户赋角色，管理角色的权限来间接地给用户赋权限。

我的项目中是使用的是最基础的RBAC0的模式，用户和角色是**一对多**的方式，一个用户只能是一个角色，一个角色可以有多个用户。

具体的实现，首先我项目中有个后台系统，在这个页面系统中有个权限管理页面，里面有我的角色列表，固定的有老师、学生、管理员三种角色。

后台可以对角色进行增删改查，比如为角色添加新的用户，增添新的角色，删除存在的角色，移除角色中的某个用户的功能。

每一个角色有修改权限的按钮，点进去是一排一排分类的权限开关，可以修改开关来修改角色的权限。**比如~~~**

前端对于某些功能做了处理，有这个权限的才会渲染出这个功能相关的东西。

并且关于一些页面做了路由守卫，根据router.beforeEach的第一个参数to ，即将进入的路由对象的path属性来进行操作，通过next函数进行路由的调整，有这个权限才能访问这个页面。

这些是前端对于权限的控制，当然我们后端同学也会对请求进行权限管理，如果请求的用户没有这个权限就并不会处理并返回错误信息

> 对于权限的处理还有可以优化的地方



### 项目中下载文件是如何实现的

首先我采用Get请求，请求时修改了responseType的值为blob，也就是说我请求了一个类似文件的二进制数据对象。responseType设置的特定类型需要确保服务器所返回的类型和设置的返回值的类型是兼容的。

然后我新建了Blob对象，参数就是response.data。然后创建了新的a元素，调用window.URL.createObjectURL创建了下载链接，而参数就是新建的Blob对象。然后把创建的下载链接赋给了新的a元素的href，将新的a标签添加到页面文档中。

最后下载完成后移除元素，调用window.URL.revokeObjectURL释放掉刚刚创建的下载链接



Blob对象表示一个不可变，原始数据的类文件对象。

它的数据可以按文本或二进制的格式进行读取，也可以转换成 `ReadableStream`来用于数据二进制流操作。 

> 流操作API中，ReadalbeStream接口呈现了一个可读取的二进制流操作
>
> ReadableStream() 构造器创建并返回包含处理函数的**可读流**实例



URL.createObjectURL()静态方法会创建一个 DOMString，DOMString包含一个参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document绑定，但为了获得最佳性能和内存使用情况，还是及时使用URL.revokeObjectURL来释放



### 项目为什么要选择这些技术栈

为什么使用Vue？

首先当初是写项目是刚接触前端不久，学完基础后听学长同学介绍Vue**上手比较简单，对初学者比较友好**，刚好我们小组的前端人员也是初学者。

而且**Vue具有更好的性能**，学习生态较好，遇到问题的能很好的解决。

**老师的要求**也是要求我们使用Vue。



### Webpack

Webpack是一个前端资源加载/打包的工具。

它根据模块间的依赖关系进行静态分析，按照指定规则生成对应的静态资源。

简单多说，可以将多种静态资源JS,CSS,LESS转换成一个静态文件，减少了页面的请求



Webpack本身只能处理JS模块，要处理其他类型的模块，要使用loader进行转换

> 所以如果我们需要在应用中添加 css 文件，就需要使用到 css-loader 和 style-loader，他们做两件不同的事情，css-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们，style-loader 会把原来的 CSS 代码插入页面中的一个 style 标签中。



当然，我们可以将一下编译的配置放在配置文件webpack.config.js文件中

> 自己理解的 ，后续需要改动
>
> entry：要编译的
>
> output：打包出来的文件
>
> module：有哪些编译的模块
>
> plugins：配置插件信息的地方



### Vue中的key有什么作用

**key的作用主要是为了高效的更新虚拟DOM**，在diff算法中，key可以管理可复用的元素，减少不必要的元素的重新渲染，让有必要的元素重新渲染。有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误。

它也可以用于强制替换元素/组件而不是重复使用它。

另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们。



> vue应用 **in-place patch（就地复用）策略**。列表里的顺序发生改变的时候比如shuffle（列表打乱）的时候，vue为了提升性能，不会移动dom元素，只是更新相应元素的内容节点。



### 常见的HTTP状态码

- 1xx 是信息类状态码，表示收到了http请求，正在进行下一步处理
  - 100 客户端继续请求
  - 101 切换协议
- 2xx 是成功类状态码，表示用户被正确接收，处理
  - 200 请求成功
  - 201 成功请求并创建了新的资源
  - 202 已接收请求，但未处理完成
- 3xx 是重定向类状态码，表示没有请求成功，必须采取进一步的动作
  - 301 永久移动，请求的资源已被永久移动到新的URL，浏览器会自动定向到新的URL，今后请求也会用新的URL
  - 302 临时移动，与301类似
  - 304 所请求的资源未修改，不会返回任何的资源。客户端通常会去缓存访问过的资源
- 4xx 是客户端错误类状态码，表示客户端提交的请求包含错误或不能正确执行
  - 400 客户端请求语法错误
  - 401 要求认证用户身份
  - 403 服务器理解客户请求，但拒绝此请求
  - 404 服务器无法根据请求找到资源
  - 405 客户端请求的方法被这个资源禁止
- 5xx 是服务端错误类状态码 表示服务器不能正确执行一个正确的请求
  - 500 服务内部错误
  - 501 服务器不支持该请求的功能，无法完成请求
  - 503 服务器超载或者系统维护，暂时无法处理客户端请求

> 哪些情况需要用到301重定向？
>
> 1. 一个站点绑定了多个域名的时候
> 2. 同一个页面存在多个URL路径
> 3. 已有页面URL发生变化时，当一个页面被收录后，若是改变该页面的url路径，那么之前的路径就会成为网站死链，这个页面上的关键词排名与收录将会消失。那么就需要做301定向，将老链接跳转到新链接
> 4. 域名改版  当我们想换个域名的时候，除了域名以外，其余内容完全一样的情况下，想把老域名的收录于排名全部过渡到新域名上，这就需要做301定向。每个页面的链接需要一一对应。





### instanceof，typeof和Object.prototype.toString的用法和区别

**instanceof**

定义： instanceof运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上

语法：

```javascript
object instanceof constructor

object：某个实例对象     constructor：某个构造函数

用来检测  constructor.prototype 是否存在于参数  object 的原型链上。
返回结果是布尔值
```

能判断基本数据类型，数组，函数，判断对象的话需要结合起来判断（用多个）

**typeof**

定义：typeof用来判断数据类型，但只能判断出五种：number，string，undefined，boolean，object

对于对象，数组来说，统一返回'obejct'；

语法：

```javascript
typeof param
typeof(param)

返回的结果是字符串，上面五种类型的小写
```

**toString**

定义：默认情况下，`toString()` 方法被每个 `Object` 对象继承，但是不同的数据类型会覆盖默认的方法，如果未覆盖，toString()方法返回[object type]字符串，type是对象的类型。

可以利用call,apply来判断变量的类型

语法：

```javascript
Object.prototype.toString.call(param)
```



### 浅拷贝和深拷贝

浅拷贝和深拷贝是针对复杂数据类型来说的。

浅拷贝只拷贝一层，只会把栈里面变量的引用地址拷贝过来，而非堆里的值，对象的变化相互影响。

深拷贝会每一层都拷贝，每一级别的数据都会拷贝，通常使用递归来实现，两个对象的改变不会相互影响。

```JavaScript
function deepCopy(newObj,oldObj){
  for(let k in oldObj){
    var tmp = oldObj[k];
    if(tmp instanceof Array){
      newObj[k] = [];
      deepCopy(newObj[k],tmp); 
    }else if(tmp instanceof Function){
      newObj[k] = tmp;
    }else if(tmp instanceof Object){
      newObj[k] = {};
      deepCopy(newObj[k],tmp);
    }else{
      newObj[k] = tmp;
    }
  }
}
```

Object.assign(target,sources) es6新增方法可以实现拷贝，target拷贝给谁，sources拷贝来源。

Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

因为Object.assign()拷贝的是属性值。

假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。

也就是说，如果对象的属性值为简单类型（如string， number），通过Object.assign({},srcObj)，得到的新对象为深拷贝；**如果属性值为对象或其它引用类型**，那对于这个对象而言其实是**浅拷贝**的。

数组方法concat和slice与这个原理一样

```javascript
进阶版：考虑了其他类型和循环引用
let obj = {
    test_obj:'obj'
}
let set = new Set([11,12,obj]);
let map = new Map([[12,13],[14,obj]])
let a = [1,2,3,[4,5,6,[7,8]],{'9':9,'10':10,'15':set},set,map]
let reg = /\w/;
let oldObj = {
    oldObj:a,
    b:1,
    reg_test:reg
}

function deepClone(target,hash = new WeakMap()){
    let result;
    if(typeof target === 'object'){
      if(hash.has(target))  return hash.get(target);
      if(target instanceof RegExp || target === null || target instanceof Function){
        result = target;
        hash.set(target, result);
    }else if(target instanceof Set){
        result = new Set();
        hash.set(target, result);
        for(let item of target){
            result.add(deepClone(item,hash));
        }
      }else if(target instanceof Map){
        result = new Map();
        hash.set(target, result);
        hash.set(target, result);
        for(let item of target){
            result.set(deepClone(item[0],hash),deepClone(item[1],hash));
        }
      }else if(target instanceof Array){
        result = [];
        hash.set(target, result);
        for(let item of target){
          result.push(deepClone(item,hash));
        }
      }else{
        result = {};
        hash.set(target, result);
        for(let item in target){
          result[item] = deepClone(target[item],hash);
        }
      }
    }else{
      result = target;
    }
    return result;
}

let newObj = deepClone(oldObj);
console.log(newObj);
obj.test_obj = "??????";
console.log(oldObj);
console.log(newObj);    
```



### 子网掩码

子网掩码是另外一种划分网络号与主机号的形式。（子网掩码为1的位数就是网络号的位数）

将子网掩码和IP地址按位计算AND，就可以得到网络号

更重要的我们要通过子网掩码进行**划分子网**

子网划分实际上是将**主机地址分成了两个部分：子网网络地址和子网主机地址**

**子网划分的优点**

1. 有效利用IP地址，不浪费IP地址
2. 限定了广播的传播，通过子网隔离用户，保证了网络的安全



### TCP与UDP的区别

**TCP与UDP都位于网络模型中的传输层，负责传输应用层产生的数据**

1. 最基础的，TCP是**面向连接的**、**可靠的**、**有状态**的传输协议，而UDP是**无连接的，不可靠、无状态**的传输协议。TCP提供可靠的服务，先建立三次握手连接，支持差错检验，拥塞控制等实现不丢失、不重复、不失序的数据传输；UDP没有三次握手的连接建立，尽最大努力可靠交付交付
2. TCP是点对点的传输；UDP可以一对多，多对多的传输
3. TCP对系统资源要求较多，UDP对系统资源要求较少
4. TCP允许的报文长度超过512字节，UDP报文的最大长度为512字节
5. TCP提供可靠的服务，应用在一些对安全性、数据传输量大的场景，如HTTP，FTP文件传输；而UDP工作效率高，应用在实时性要求高的场景，如视频，音频等多媒体

> 无状态的含义：指协议对于事务处理没有记忆能力，服务器不知道客户端的状态。



### TCP三次握手的过程

1. 首先，一开始客户端和服务器都是处于**CLOSED状态**。服务端主动监听某个端口，服务器处于LISTEN状态
2. 客户端会随机初始化序列号（client_isn），将这个序号置于TCP首部的序号字段中，同时把SYN标识位设为1，发送这个**SYN**报文给服务端，表示向服务器**发起连接**，该报文不包含应用层数据，之后客户端处于**SYN-SENT状态**
3. 服务器收到客户端的SYN报文后，服务端也随机初始化自己的序号（server_isn），将此序号填入TCP报文中序号字段中，其次在TCP首部的**确认应答号**字段中填入之前收到的SYN报文中的序列号**（client_isn）+ 1**，并且把**SYN和ACK标志位设为1**。最后把该报文发送给客户端，该报文也不含应用层数据，之后服务端处于**SYN-RCVD(同步收到 SYN-RECEIVED)状态**
4. 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，**ACK标识为1**，**确认应答号是client_isn + 1**，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，然后**客户端处于ESTABLISHED（建立）状态**
5. 服务器收到客户端的应答报文后，也**进入ESTABLISHED状态**。此时已完成建立，客户端和服务端就可以相互发送数据了。

> 第三次握手是可以携带数据的，前两次握手是不可以携带数据的



### 为什么TCP要三次握手，不是两次握手？不是四次握手？

首要原因是TCP为了**防止已经失效的连接报文突然又传到了服务端**，因而产生了错误。

client发送的第一个连接请求因为网络问题延时了，成为了一个已失效的报文段，但是server后续收到了这个已失效的，误认为client要建立新的连接，于是向client发送确认报文段，同意建立连接。如果不采用三次握手，那么只要server发出确认请求了，连接就建立了，而client不会理会server端，这样server端的**资源就白白浪费了**，而采用三次握手就能防止上述现象出现。

还有个原因是**TCP需要seq序列号来做可靠传输，需要双方同步ISN（初始seq序列号）**。当client发送携带初始序列号的SYN报文时，需要server回一个ACK应答报文，同理，server发送携带初始序号的SYN报文时，需要client的应答报文。这样一来一回，**两次往返，才能确保双方的初始序列号同步，确保了双方都有发送和确定的过程**。这样看来四次握手也可以实现，但由于server的应答报文和SYN报文**可以优化成一步**，这样节约资源，所以就成了三次握手

> 顺带一提的是：
>
> 两次握手更容易受到SYN Flood洪水攻击。
>
> 
>
> 三次握手的原则设计是防止旧复用链接的初始化导致问题，为了解决此问题，我们设计了`reset`这个特别的控制信号来处理。
>
> 如果接收中的 TCP 在一个未同步状态如 `SYN-SENT, SYN-RECEIVED`，它会返回 `reset` 给对方，对方又变成listen状态。



### TCP头部报文格式

**序列号**：在建立连接时生成一个**随机数作为其初始值**，通过SYN包传给接收端，每发一次数据，就累加一次该数据字节大小，用来**解决网络包乱序问题**

**确认应答号**：指下一次**期望**收到的数据的序列号，发送端收到这个确认应答号后可以认为在这个号之前的数据都被正常接收（累积回应）。用来**解决不丢包的问题**

**控制号**：

- ACK: 该位为1时，**确认应答号**有效，TCP规定除了最初建立连接时的SYN包之外该位必须设置为1
- RST: 该位为1时，表示TCP连接出现异常必须**强制断开连接**
- SYN: 该位为1时，表示希望建立连接，并在其**序列号**的字段进行序列号初始值的设定（建立连接的前两次握手）
- FIN:  该位为1时，表示今后不会再有数据发送，希望断开连接。当通信双方希望断开连接时，通信双方的主机之间就可以**相互交换FIN位为1的TCP报文**



### 详解一下四次挥手过程

1. 客服端打算关闭连接，此时会发送一个TCP首部FIN为1的报文，即**FIN报文**，此时客户端**进入FIN_WAIT_1状态**
2. 服务端收到该报文后，就向客户端发送**ACK应答报文**，接着服务端**进入CLOSED_WAIT状态**
3. 客户端收到ACK应答报文后，之后**进入FIN_WAIT_2状态**
4. 此时只是客户端向服务端断开了连接，但服务端还可以向客户端发送数据
5. 等待服务器处理完数据后，也向客户端发送**FIN报文**，之后服务端进入**LAST_ACK状态**
6. 客户端收到FIN报文后，**回应ACK应答报文**，**之后进入TIME_WAIT状态**
7. 服务器收到了ACK应答报文后，就进入了**CLOSED状态**，**至此服务端已经完成了连接的关闭**
8. 客户端在经过了2MSL一段时间后，就自动进入CLOSED状态，**至此客户端已经完成了连接的关闭**

> 挥手的过程中每个方向都需要一个FIN和一个ACK
>
> 只有主动关闭连接的一方，才有TIME_WAIT状态
>
> 为什么会有TIME_WAIT状态（和下面的等待2msl原因一样）？
>
> 1. 防止旧连接的数据包被使用相同端口的新连接正常接收，造成数据错乱
> 2. 保证连接的正确关闭



### 为什么挥手需要四次？

- 关闭连接时，客户端向服务端发送FIN报文，**仅仅代表客户端不再发送数据，但是还能接收数据**
- 服务器收到FIN报文后，先回一个ACK报文，**但服务端可能还有数据需要处理和发送**，等服务端不再发送数据时，才发送FIN报文

综上，服务端通常还需等待完数据的处理和发送，所以ACK报文和FIN报文会分开发，**从而比三次握手多了一次**



### 四次挥手会等待2msl，为什么？

首先理解到什么是MSL，MSL是**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

2msl的时间是从客户端**接收到FIN后发送ACK开始计时的**,如果最后的ACK应答报文丢失了，被动关闭方（服务器端）会**触发超时重发FIN报文**，另一方接收到这个超时重发的FIN后，就会重发ACK给被动关闭方，并重新计时，这段时间正好是2msl

这样就**确保了连接的关闭**

还有个原因，经过2msl时间，**足以让两方向上的数据包都被丢弃，使得原来连接的数据包在网络中自然消失，防止客户端正常接收过期的报文，产生数据错乱等严重的问题**



### Web安全之四大常见攻击

见已经整理了的MarkDown



### 应用层其他协议

**文件传送协议FTP**，是基于TCP的互联网上使用得最广泛的文件传送协议，使用的是客户服务器模式。

**简单文件传送协议TFTP**，是基于UDP（需要有自己的差错改正措施）的很小且容易实现的文件传送协议，使用的是客户服务器模式。

**远程终端协议TELNET**是简单的远程终端协议，也是互联网的正式标准，也是使用的是客户服务器模式。

**电子邮件的一些标准：**

- 发送邮件的协议：SMTP
- 读取邮件的协议：POP3和IMAP



### 让一个div盒子水平垂直居中的方法

1.grid方法

> Grid布局（网格布局）
>
> grid布局与flex布局有一定的相似性，都可以指定内部多个项目位置。Flex布局是轴线布局，只能指定“项目”针对轴线的位置，是一维布局。Grid布局则是将容器划分成“行”和“列”，产生单元格，然后指定“项目”所在的单元格，可以看做是二维布局

```css
.father{
    display:grid;
}

.son{
    justify-self:center;
    align-self:center;
}


也可以这么写
        body{
            background-color: turquoise;
            height: 600px;
            display: grid;
            justify-items: center;
            align-items: center;
            grid-template-columns: repeat(3,33.3%);
            grid-template-rows: repeat(3,200px);
        }

        .box{
            width: 200px;
            height: 200px;
            background-color: tomato;
            grid-row: 2/3;
            grid-column: 2/3;
        }
```

2.absolute + 负margin

```css
.father{
	position:relavtive;
}

.son{
	position:absolute;
	left:50%;
	top:50%;
	margin-left:-50px;
	margin-right:-50px;
}
```

3.absolute + transform

对第二种方法的改良

```css
.father{
	position:relative;
}
.son{
	postioin:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
}
```

4.absolute + margin

这类方法的另一种变形

```css
.father{
	position:relative;
}

.son{
    position:absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin:auto;
}
```

5.flex布局

```css
.father{
    display:flex;
	justify-content:center;
    align-items:center;
}
```

6.margin + transform（特殊一点）

```css
.father{
	overflow:hidden;
    //也可以使用padding:1px; box-sizing:content-box;
}
.son{
	margin: 50% auto;
    transform:translateY(-50%);
}
或者
.son{
    margin: 0 auto;
    transform: translateY(250px);
}
需要计算一下
```

7.table-cell

```css
.father{
	display:table-cell;
    text-align:center;
    vertical-align:middle;
}
.son{
    display:inline-block;
}
```

8.inline-block + vertical-align

```css
.father{
    text-align:center;
    line-height:300px;
}
.son{
    display:inline-block;
    vertical-align:middle;
}
```

回答：

首先我们可以用grid布局，flex布局方式进行水平垂直居中。

还可以用绝对定位absolute和搭配（正负）margin，或者absolute搭配transform:translate

还有margin和transform的搭配（也有两种）

还有其他方法table-cell和inline-block + vertical-align（不懂 暂时不答）



### 关于margin的一些知识

margin的值就是基于参考线移动的数值。

margin的参考线分为两类

一类是top、left，它们以外元素作为参考线，另一类是right、bottom，它们以自身作为参考线。

- top负值就是以包含块(Containing block) 内容区域的上边或者上方相连元素 margin 的下边为参考线;
- left负值就是以包含块(Containing block) 内容区域的左边或者左方相连元素 margin 的右边为参考线;
- right负值就是以元素本身border的右边为参考线；
- bottom负值就是以元素本身border的下边为参考线

> 以上margin 包含块内容区域的相连元素不是看HTML结构中的元素，是实际上相邻的元素

margin的百分比是相对于包含块的宽度

> 官方定义：一个元素盒子的位置和大小有时相对于某个矩形来计算的，此矩形称为此元素的包含块。简写为：C.B.
> 有以下几种情况：
> 1、根元素所在的包含块是一个长方形，称为初始的包含块。
> 2、假如元素的position设为‘relative’或‘static’，包含块是由最近的父容器块的内容区边缘形成的。
> 3、假如元素的position设为‘fixed’，包含块是由所在的viewpoint或page area决定。
> 4、假如元素的position设为‘absolute’，包含块是由最近带有‘position’属性的祖先决定。

**负margin**

负margin就是，当margin-top、left为负值的时候与参考线的距离减少，当margin-right、bottom为负值的时候参考线就向左、上面移动。

实际应用：

1. 边框去重（一些排列的卡，可以用margin-left: -1px）进行去重

2. 在布局中使用，如圣杯布局，双飞翼布局

   

**外边距重叠**

也叫边距重叠，垂直外边距合并问题

块的上外边距(margin-top)或下外边距(margin-bottom)有时合并(折叠)为单个边距，其大小为单个边距的最大值(或如果它们相等，则仅为其中一个，还有为负时的特殊情况)

以下三种情况会出现外边距重叠：

1. 同一层元素上下相邻时，两个元素之间会发生外边距重叠

2. 没有内容将父元素和后代元素分开时，就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。

   > 这个问题发生的原因是**根据规范，一个盒子如果没有上补白(padding-top)和上边框(border-top)，那么这个盒子的上边距会和其内部文档流中的第一个子元素的上边距重叠**。

3. 空的块级元素，当一个块元素上边界margin-top 直接贴到元素下边界margin-bottom时也会发生边界折叠。

一些需要注意的地方：

- 上述情况的组合会产生更复杂的外边距折叠。
- 即使某一外边距为0，这些规则仍然适用。因此就算父元素的外边距是0，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。
- 如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和,；也就是说如果有-13px 8px 100px叠在一起，边界范围的技术就是 100px -13px的87px。
- 如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。

以上这些内容都是发生在Block-Level的元素，设定floating和absolutely positioned的元素完全不用担心边界重叠的问题。



**auto**

让浏览器自己选择一个合适的外边距。有时，在一些特殊情况下，该值可以使元素居中。

为什么auto只能水平居中，不能实现垂直居中？

因为默认的宽度规则是“适应于父级”规则（在水平方向上自动扩充）。即

margin-left+border-left-width+padding-left+width+padding-right+border-right-width+margin-right= width of containing block

对于绝对定位元素，有以下算式：

left+margin-left+border-left-width+padding-left+width+padding-right+border-right-width+margin-right+right= width of containing block

而auto的作用是：自动填充剩余空间， 所以给div设置margin：auto时，在水平方向上 margin会填充 div这一行中除了left+border-left-width+padding-left+width+padding-right+border-right-width+right的剩余的空间，当左右的margin都设置为auto时，会平分剩余空间，从而实现水平居中。那为什么没有按照上述同样的方式填充垂直方向上的剩余空间呢？

因为在垂直方向上，块级元素不会自动扩充，它的外部尺寸没有自动充满父元素，也没有剩余空间可说。所以margin：auto不能实现垂直居中。

但是

**当一个绝对定位元素，其对立定位方向属性同时有具体定位数值的时候，流体特性就发生了**。

**具有流体特性绝对定位元素的margin:auto的填充规则和普通流体元素一模一样**：

如果一侧定值，一侧auto，auto为剩余空间大小；

如果两侧均是auto, 则平分剩余空间

因为此时.son这个元素的尺寸表现为“格式化宽度和格式化高度”。即.son**这个元素的尺寸自动填充父级元素的可用尺寸**。

**总结**：通过position:absolute 和 top:0 bottom:0将元素设为流体特性的元素，这样该元素可自动填充父级元素的可用尺寸。

**格式化宽度**：格式化宽度仅出现在“绝对定位模型中”，也就是出现在position属性值为absolute或fixed的元素中。

对于非替换元素，当left/right或top/bottom对立方位的属性值同时存在时，元素的宽度表现为“格式化宽度”，其宽度大小相对于最近的具有定位特性的祖先元素计算。

“格式化宽度”具有完全的流动性，也就是margin、border、padding、content内容区域同样会自动分配水平和垂直空间。



### 为什么要清除浮动？

由于父盒子很多情况下不方便赋值高度，但子盒子浮动又不占有位置，最后父盒子高度就为0，就会影响下面的标准流盒子，影响整个页面布局

清除浮动本质？**本质是清除浮动元素脱离标准流造成的影响**

清除浮动的策略是？闭合浮动，只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子

**有哪些方法？**

1. **额外标签法**。末尾的新标签添加clear:both，且必须是块级元素。缺点：添加许多无意义的标签，结构化比较差。不常用
2. 给父元素**添加overflow**。缺点：无法显示溢出的部分
3. :after伪元素法。在after里添加clear:both，缺点：需要照顾低版本浏览器
4. 双伪元素清楚浮动。代码更简洁，但也需要照顾低版本浏览器

（3、4也被称为.clearfix方法，相对前两个是比较好的方法）



### CSS属性书写顺序

建议遵循以下顺序：

1. 布局定位属性
2. 自身属性
3. 文本属性
4. 其他属性



### 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景

从结构上来讲：

- display:none **会**让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击
- visibility:hidden**不会**让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击
- opacity:0 **不会**让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击(透明度)

从继承上来讲：

- display:none是**非继承属性**，子孙结点的消失是由于该元素从渲染数消失造成的，通过修改子孙结点属性仍无法显示
- visibility:hidden是**继承属性**，子孙节点消失由于继承了hidden，通过设置visibility: visible可以让子孙节点显式。
- opacity:0是**继承属性**，且子孙结点无法通过修改opacity来改变这个继承属性。父节点可以通过rgba间接设定opacity的值，这个不会向下继承；或者把opacity属性放到同级元素实现透明

从性能方面来讲：

- display:none修改元素会造成文档**回流**，性能消耗较大，读屏器不会读取display:none元素内容
- visibility:hidden修改元素只会造成元素本身**重绘**，性能消耗较少，读屏器会读取visibility:hidden元素内容
- opacity:0修改元素造成**重绘**，性能消耗较少，读屏器会读取opacity:0元素内容

共同特点：它们都能让元素不可见



### CSS：画一个三角形

等腰直角：宽高设置为0，只设置border宽度，且颜色设置为透明色，需要哪个朝向的三角形，就设置哪个朝向的颜色为需求颜色

中心交汇点到每一个边的距离就是每一个方向上border的宽度

需要其他类型的三角形，可以自定义修改border

```css
边长为3 4 5的三角形
.triangle{
            height: 0;
            width: 0;
            border-top:20px solid transparent;
            border-bottom:30px solid yellow;
            border-left:40px solid transparent;
            /* border-right:20px solid red; */
}
```



### CSS：画一个0.5px边框

详见0.5px边框.md



### CSS如何解决图片底部默认空白间隙

为什么会有空白间隙？因为行内块元素要和文字的基线对齐，文字会多出部分内容，哪怕没有文字，也会多出这点空隙

解决方法：

1. 给图片添加vertical-align，改变它与文字垂直对齐的方式，不让它与文字的基线对齐。
2. 把图片转换为块级元素，display:block;

提倡使用第一种，第二种可能会影响布局

> vertical-align只针对行内块和行内元素



### 溢出文本省略号显示

单行文本溢出显示省略号

```css
{
    /*先强制一行内显示文本 ,默认是normal自动换行*/
    white-space:nowrap;
    /*超出的部分隐藏*/
    overflow:hidden;
    /*文字用省略号代替超出的部分*/
    text-overflow:ellipsis;
}
```

多行文本溢出显示省略号（有较大的兼容性问题，适用于webKit浏览器）

```css
{
    overflow:hidden;
    text-overflow:ellipsis;
    /*弹性伸缩盒子模型显示*/
    display:-webkit-box;
    /*限制在一个块元素显示的文本的行数*/
    -webkit-line-clamp:2;
    /*设置或检索伸缩盒对象的子元素的排列方式*/
    -webkit-box-orient:vertical;
}
```

更推荐让后台人员写这个效果,	后台人员显示多少字，操作更简单。（感觉不是这样的）



### HTML5新特性

1.新增的带有语义化的标签：

1. header 头部
2. nav 导航
3. article 内容
4. section 定义文档某个取余（大号div标签）
5. aside 侧边栏
6. footer 尾部

2.新增的多媒体标签：

1. audio 音频 支持MP3 Wav Ogg格式 
2. video 视频 只支持MP4，WebM，Ogg格式

3.新增了input类型：email,url,date,number,tel,search,color......

4.新增的表单属性（写在input里面）

1. required表单内容不能为空
2. placeholder 表单提示信息
3. autofocus 自动聚焦
4. autocomplete 是否显示已经键入过的值
5. multiple 可多选文件



### CSS3的新特性

**CSS3新增选择器**

1. **属性选择器**

   ```css
   input[value]{
   	xxxxxx
   }
   
   <input type="text" value="请输入用户名">
   <input type="text">
   
   E[att=val]
   E[att^=val]开头
   E[att$=val]结尾
   E[att*=val]包含
   ```

   类、属性、伪类的权重一样

2. **结构伪类选择器**

   ```css
   E:first-child{
   
   }
   还可以写成 ul li:first-child  ul里第一个li标签
   
   :last-child
   :nth-child(n) 第n个 n可以是数字，关键字，公式 even（偶数） odd（奇数） 如果n是公式,会从0开始累加，但第0个元素和超出元素的个数会被忽略掉，公式里的变量只能是n。
   :first-of-type 指定类型E的第一个
   :last-of-type
   :nth-of-type(n)
   
   nth-child还比较特殊，在特定情况下还选不出来指定的标签
   <section>
   	<p>
   	<div>
   </section>
   section div:nth-child(1)这时候选不出来，但nth-of-type就能选出来（观测顺序不一样）
   使用nth-child，会把所有子元素排序，必须是子元素和顺序都匹配上才能选出来，否则选不出来。在上面的案例中就是必须是div的一个元素，而且必须是div标签，而第一个是p标签，所以匹配不了，选不出来。
   而nth-of-type是排列指定元素的序号，section div:nth-of-type(1)就能匹配子元素的第一个div
   ```

   

3. **伪元素选择器**

   可以帮助我们利用CSS新建标签（是行内元素），而不需要HTML标签，可以简化HTML结构（CSS3采用双冒号）

   新建的这个元素在文档树里是找不到的，所以被称为伪元素

   权重和标签选择器一样

   必须有content属性

**CSS3动画**

详见CSS动画.md

**其他特性**

让图片变模糊：滤镜filter CSS属性将模糊或颜色偏移等图形效果应用于元素 如 filter:blur(5px)

calc函数，此CSS函数能在声明CSS属性时执行一些计算，+ - * /都可以,运算符前后都需要保留一个空格，任何长度值都可以使用calc()函数进行计算

> calc相比less的运算，有一些限制：
>
> - 运算符前后必须要有空格（*,/不用，但考虑统一性还是要加上），编写麻烦
> - 对运算值有限制，乘法的话必须至少有一个是numbe，除法右边的数必须是number
> - less的运算更强大，甚至可以对颜色进行运算（#22448 / 2）,而calc不行



### Less 到底为 CSS 添加了什么功能？

1. 变量(Variables) 可以自定义变量，用@创建，使用
2. 混合(Mixins) 将一组属性从一个规则集包含（或混入）到另一个规则集的方法，这样另一个规则集也有这一组属性了，使用方法是类名加()，也可是#id()
3. 嵌套(Nesting) 可以将CSS写成像html一样的组织层级结构,这样代码更规范简洁，也不怕变量污染
4. 运算(Operations) 算术运算符 `+`、`-`、`*`、`/` 可以对任何数字、颜色或变量进行运算。如果可能的话，算术运算符在加、减或比较之前会进行单位换算。计算的结果以最左侧操作数的单位类型为准。如果单位换算无效或失去意义，则忽略单位
5. 导入(Importing) 通过@import导入less文件，此文件中的所有变量就可以全部使用了
6. 映射(Maps)  可以将混合（mixins）和规则集（rulesets）作为一组值的映射（map）使用，就像调用对象的属性一样使用
7. 作用域(Scope) 首先在本地查找变量和混合（mixins），如果找不到，则从“父”级作用域继承



### CSS选择器权重

CSS基本选择器有类选择器、属性选择器和ID选择器。

CSS 的选择器有很多，常用的有 [元素选择器](https://blog.csdn.net/qq_42351033/article/details/103225005)、[id 选择器](https://blog.csdn.net/qq_42351033/article/details/103225736)、[class 选择器](https://blog.csdn.net/qq_42351033/article/details/103229023)、[后代选择器](https://blog.csdn.net/qq_42351033/article/details/103244891)、[子代选择器](https://blog.csdn.net/qq_42351033/article/details/103246217)、[并集选择器](https://blog.csdn.net/qq_42351033/article/details/103246871)、[交集选择器](https://blog.csdn.net/qq_42351033/article/details/103280516)、[伪类选择器](https://blog.csdn.net/qq_42351033/article/details/103281108#font_color3399EA_size4stronginput_strongfont_93)、[通配符选择器](https://blog.csdn.net/qq_42351033/article/details/103291503) 等。

CSS选择器的权重预示着CSS选择器样式渲染的先后顺序，元素样式渲染时，权重高的选择器样式会覆盖权重低的选择器样式。

通常将权重分为4个等级，可用0.0.0.0来表示这4个等级。

！important关键字优先级最高。

注意：！important井非选择器，而是针对选择器内的单一样式设置的。当然，不同选择器内应用 ！important的权重也是不一样的，例如，在id选择器内的！important关键字权重要高于类选择器内的 ！important关键字权重，即下面所说的选择器权重组合。

- 内联样式（非元素器）的优先级可看成1.0.0.0
- ID选择器的优先级为0.1.0.0
- 类属性选择器、属性选择器、伪类的优先级为0.0.1.0
- 元素选择器、伪元素选择器的优先级为0.0.0.1
- 通配符选择器对特殊性没有任何贡献值

当把选择器组合使用的时候，相应的层级权重也会递增，例如# id .class的权重为0.1.1.0



> 伪类如 :first-child, :nth-last-child(n), :hover等等
>
> 伪元素选择器如::after, ::before等等



注意：

- 当两个选择器组合权重不一样时，用权重高的选择器，不在意代码中谁上谁下
- 当两个选择器组合权重一样时，看代码中谁上谁下
- 类 ID 和 ID 类的组合权重是一样的
- !important的权重比内联样式还要高
- 选择器组合是没有父级优于子级这一说法的，比如

```html
  <style>
    #box .sp {
      color: green;
    }

    #qqqq .sp {
      color: red;
    }
  </style>
</head>

<body>
  <div id="box">
    <p class="ap" id="qqqq">
      <span class="sp" id="sqqq">text</span>
    </p>
  </div>
</body>
```

组合优先级一样高，red在下面，文字呈现为红色

参考文章：

- 【前端面试题】02—59道CSS面试题(附答案)https://blog.csdn.net/snsHL9db69ccu1aIKl9r/article/details/114297605
- 【CSS】什么是 CSS 中的子代选择器https://blog.csdn.net/qq_42351033/article/details/103246217





### CSS line-height = height为什么能让文字居中

首先来说，line-height是行高，指的是文本行之间基线的垂直距离。

基线是什么？在文本行中，从上到下依次是**半行距，顶线，中线，基线，底线，半行距**。基线所在的位置是除了j g f这类的小写字母的末端，像英文四行格子的第三行

又因为文本间的半行距是相等的，所以行高又可以看成是一行文本的上半行距到下半行距

font-size的大小就是从**顶线到底线**的距离。

在没有给div盒子设置height的时候，div的高度随line-height的变化而变换，且文字居中

当div盒子有高度时，如果line-height = height，文字就是在中间显示；如果大于，文字偏下；如果小于，文字偏上



### CSS3盒子模型

所有的HTML元素在页面上都可以看做是一个盒子，一个盒子包括:外边距margin，边框border，内边距padding和元素实际内容content

CSS3可以通过设置box-sizing来指定盒子模型，有2个值，content-box和border-box，**这样我们计算盒子大小的方式就进行了改变**

box-sizing:content-box 盒子大小为width + padding + border（默认）

box-sizing:border-box 盒子大小为width(也被称为怪异盒模型，IE盒模型)

如果盒子模型我们改为了box-sizing:border-box，那么padding和border就不会撑大盒子（前提padding和border不会超过width宽度）

与盒模型相关的属性：border-image、box-shadow



### CSS中的BFC和IFC

什么是FC？ FC是Fomatting Context，是页面中的一块渲染区域，并且有一套渲染规则。

BFC和IFC都是常见的FC

**BFC**是Block FC  也叫块级格式化上下文

BFC就是一个页面上隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也是如此

一个元素如何触发产生BFC呢？

1. 根元素本身就是BFC
2. float属性不为none;
3. position为absolute或fixed
4. display为inline-block，table-cell,table-caption,flex
5. overflow不为visible

**BFC布局规则**

1. 内部盒子会在**垂直方向**一个一个的摆放
2. 盒子垂直方向的距离由margin决定，**属于同一个BFC的两个相邻BOX的上下margin会发送重叠**（也就是外边距塌陷）
3. 每个元素的左边与包含的盒子的左边相接触，即使存在浮动也是如此
4. BFC区域不会和float重叠
5. 计算BFC高度时，**浮动元素也参与其中**

能解决什么问题：**能完成自适应的两栏布局，清除内部浮动引起的高度塌陷，解决外边距塌陷问题**



**IFC**是Inline FC，也被叫为内联格式化上下文

一个元素如何触发产生IFC呢？

IFC由不包含块级盒的块容器盒子建立（块容器盒中只有内联级盒子）

**IFC布局规则**

1. 盒子是一个接一个水平摆放的
2. 摆放这些框，它们的水平方向的margin,border,padding所占的空间都会被计算在内
3. 行盒的高度由内部最高的inline box决定
4. 垂直方向可以由vertical-align设置文本基线
5. 当内部盒子太多，会折行变成两个或多个line box，在垂直方向无间隔堆叠，但不能重叠
6. 浮动后IFC内部的浮动元素宽高参与IFC的line-box宽高计算并且从换行后的行开始排列

能影响IFC内部布局的CSS属性：font-size,line-height,height,vertical-align



### CSS常见布局

**两列布局**（可以根据具体要求改变代码）：

利用浮动实现

```html
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        .main{
            width: 95%;
            margin: 0 auto;
        }

        .left{
            float: left;
            width: 200px;
            height: 600px;
            background-color: red;
            margin-right: 20px;
        }

        .right{
            display: flex;//如果里面没有溢出的元素，也可以使用overflow 目的是构建BFC，BFC区域不会和float重叠
            //这里自适应宽度，如果是inline-box，就不能自适应宽度
            height: 600px;
            background-color: blue;
        }
    </style>

<body>
    <div class="main">
        <div class="left"></div>
        <div class="right"></div>
    </div>
</body>
```

利用flex布局实现：

```html
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        .main{
            width: 95%;
            margin: 0 auto;
            display: flex;
        }

        .left{
            width: 200px;
            height: 600px;
            background-color: red;
            margin-right: 20px;
        }

        .right{
            flex: auto;
            height: 600px;
            background-color: blue;
        }
    </style>
```

**三列布局**：

使用定位

```html
   <style>
        * {
            padding: 0;
            margin: 0;
        }

        .main {
            width: 95%;
            margin-left: auto;
            margin-right: auto;
            /* 左右居中 */
            height: 300px;
            /* *zoom: 1; */
            position: relative;
        }


        /*左边固定元素定位*/
        .left {
            position: absolute;
            top: 0;
            left: 0;
            width: 200px;
            height: 100%;
            background-color: cyan;
        }


        /* 中间自适应，设置的margin左右距离为左右二边固定宽度元素的 大小*/
        .center-fa {
            width: 100%;
            height: 100%;
        }

        .center {
            height: 100%;
            margin-left: 210px;
            margin-right: 210px;
            background-color: chocolate;
        }


        .right {
            position: absolute;
            top: 0;
            right: 0;
            width: 200px;
            height: 100%;
            background-color: rgb(255, 0, 221);
        }
    </style>

<div class="main">
        <div class="left"></div>
        <div class="center-fa"> <div class="center"></div></div>
        <div class="right"></div>
    </div>
```

使用flex布局

```html
<style>
        * {
            padding: 0;
            margin: 0;
        }

        .main {
            width: 95%;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            display: flex;
            justify-content:space-between;
        }

        .left {
            width: 200px;
            height: 100%;
            background-color: cyan;
        }

        .center {
            flex:auto;
            height: 100%;
            margin-left: 20px;
            margin-right: 20px;
            background-color: chocolate;
        }

        .right {
            width: 200px;
            height: 100%;
            background-color: rgb(255, 0, 221);
        }
    </style>

    <div class="main">
        <div class="left"></div>
        <div class="center"></div>
        <div class="right"></div>
    </div>
```

**圣杯布局**

> 要求：
>
> - header和footer各自占领屏幕所有宽度，高度固定。
> - 中间的container是一个三栏布局。
> - 三栏布局两侧宽度固定不变，中间部分自动填充整个区域。
> - 中间部分的高度是三栏中最高的区域的高度。
> - 中间部分在DOM结构上优先，以便先行渲染

实现方法：浮动  padding 定位 margin

**双飞翼布局**

>  [圣杯布局](https://blog.csdn.net/qq_38128179/article/details/86533976)和[双飞翼布局](https://blog.csdn.net/qq_38128179/article/details/86542447)达到的效果基本相同，都是**侧边两栏宽度固定，中间栏宽度自适应。**主要的不同之处就是在解决中间部分被挡住的问题时，采取的解决办法不一样，圣杯布局是在父元素上设置了padding-left和padding-right，在给左右两边的内容设置position为relative，通过左移和右移来使得左右两边的内容得以很好的展现，而双飞翼则是在center这个div中再加了一个div来放置内容，在给这个新的div设置margin-left和margin-right 。

> 共同要求：
>
> - 两侧宽度固定，中间宽度自适应
> - 中间部分在DOM结构上优先，以便先行渲染
> - 允许三列中的任意一列成为最高列
> - 只需要使用一个额外的div标签

实现方法：浮动 margin

这一类的布局的还有其他的实现方法

1. flex 定位（absolute定位的元素不参与flex布局，但这一特性可能不兼容，relative不受影响，不知道是哪方面的影响）
2. flex order min-width



### 关于Flex布局

面试时被问到的一些地方

**flex属性是哪些属性的集合简写？默认值是什么？**

flex属性是flex-grow,flex-shrink,flex-basis的简写，默认值为0 1 auto   后两个属性可选。

该属性有两个快捷值：auto(1 1 auto)和 none(0 0 auto)

这三个属性分别掌管项目的放大比例，缩小比例和项目占据的固定空间

- flex-grow: 默认为0，**即如果存在了剩余空间，也不放大**。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
- flex-shrink: 默认为1，**即如果空间不足，该项目将缩小**。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。
- flex-basis: **定义了在分配多余空间之前，项目占据的主轴空间**（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。

> 注意：
>
> 单独写还无效？
>
> flex-grow/flex-shrink详解
>
> https://zhuanlan.zhihu.com/p/24372279
>
> flex-basis与width/flex项目尺寸
>
> https://www.zhangxinxu.com/wordpress/2019/12/css-flex-basis/



### 手写一个Promise.all Promise.race

考虑了可迭代对象，包括Array,String,Map,Set

```javascript
	function myPromiseAll(iterableParam){
        if(typeof iterableParam[Symbol.iterator] !== 'function'){
            throw new TypeError('参数必须是可迭代对象');       
        }
        const resArr = [];
        let count = 0;
        const length = iterableParam.length || iterableParam.size;
        return new Promise((resolve,reject) => {
            let i = 0;
            for(let item of iterableParam){
                let index = i++;
                Promise.resolve(item).then(
                    (data) => {
                        resArr[index] = data;
                        count++;
                        if(count === length){
                            resolve(resArr);
                        }
                    }
                ).catch(
                    (err) => {
                        reject(err);
                    }
                );
            };
        });
    }

    function myPromiseRace(iterableParam){
        if(typeof iterableParam[Symbol.iterator] !== 'function'){
            throw new TypeError('参数必须是可迭代对象');
        }

        return new Promise((resolve,reject) => {
            for(let item of iterableParam ){
                Promise.resolve(item).then(
                    (data) => {
                        resolve(data);
                    }
                ).catch(
                    (err) => {
                        reject(err);
                    }
                );
            };
        });
    }
```



### 理解一下Promise对象

新建一个Promise对象，参数会是一个回调函数，回调函数会携带两个参数resolve和reject，此时这个两个参数还没什么意义

在这个回调函数里可以写各种逻辑的代码，同步的，异步的都可以，此时把刚刚传入的resolve和reject当成函数来使用，resolve当成逻辑成功时的return，reject当成逻辑失败时的return，传入的这两个`return`的参数也是自定的。

其实当没执行到resolve和reject的时候，Promise是一个未确定的状态pending，当执行到某一个`return`后Promise会根据到底是resolve还是reject来选择变成是fulfilled或者说是rejected状态，而PromiseResult（在浏览器里看见的）就是传入这两个`return`函数的参数

> 但这个return还是不一样的，这个return只是决定了promise的状态，其他的代码还是要执行的
>
> 也就是说
>
> 无论是先resolve或reject ，并不会像return一样停止执行代码，所有的都会执行，如果p后面有then/catch，那么执行到resolve/reject会立即执行then/catch，但并不会影响Promise内其余代码执行
>
>  如果有两个resolve/reject，那么第二个运行到的不会执行

重点就是then方法

如果不调用这个Promise的then方法，这个两个`return`函数就没啥用，此时我们要把早就定义好的resolve和reject变成真正的函数，也就是传入then方法的第一二个回调函数，或者只给then传一个函数，另一个给catch，传入then或者catch里面的参数（也就是回调函数）的参数就是刚刚`return`的返回值，也就是说then方法里面的回调函数顶替了resolve，catch里面的回调函数顶替了reject



### 理解一下Promise.resolve与Promise.reject

**Promise.resolve**

给定一个参数，返回Promise对象

首先说参数：分为四类（对Promise存疑）

一类是空，什么都不传，返回fulfill状态，PromiseResult是undefined

一类是普通的没有then方法的参数，此时返回的Promise是成功态，PromiseResult是该参数（无论是对象还是基本类型）

一类是 本身不是Promise但有then方法的参数，如果then方法没有参数，或者有参数没有当成函数执行，**那么返回的是pending undifened**；如果有两个函数（onFulfill onReject），一个就不用考虑那么多

- Fulfill 在最前面的话，状态就是fulfill，参数是then函数里面的onFulfill里面的参数
- 如果抛出异常或onReject在前面的话，必须在resolve后面跟有处理失败状态的回调函数（then的第二个参数或者catch），否则报错，此时返回的就是then处理过的新的Promise对象了

>   都会执行then里面的其他代码

一类是 传入Promise对象，则原样返回（没有深入研究）



**Promise.reject**

**调用后除了fuifill状态，其他必须跟catch捕捉错误，否则会报错**

给定一个参数，返回Promise对象

首先说参数：

如果是普通的没有then方法的参数时，reject状态和（数据是）数据本身

如果是普通异常，reject状态和（数据是）异常本身

（不正常的情况）如果传入有then方法但没有参数之类的话，**此时返回的Promise是失败态，PromiseResult是该参数（无论是对象还是基本类型）**，但会报错（没有捕捉），如果加上捕捉，不会报错但只会返回pending undifiened且不会执行then和catch的回调

（正常的情况）但then如果有两个函数（onFulfill onReject） 

- **Fulfill 在最前面的话，状态就是fulfill，参数是then函数里面的onFulfill里面的参数！！！很重要**

- 如果抛出异常或onReject在前面的话，必须在resolve后面跟有处理失败状态的回调函数（then的第二个参数或者catch），否则报错，此时返回的就是then处理过的新的Promise对象了

- **这里和resolve的处理方法一样！！！！**

  会执行自身的then

方法可能太复杂，没有统一的规律，日后再理解



### ES6的Map和Set

不能像数组或者对象一样访问（不能通过. 或 []访问），只能通过方法来访问，因为那样访问的是对象的属性，而Map和Set的值都不是属性存储的，存在这个*[[Entries]]*东西里面

**Map**，结构和对象相似，也是键值对的形式存储。

但是和对象很很多地方不同

1. Map的键可以是任意值，甚至可以是NaN；Object只能是字符串或者Symbol
2. Map的key是有序的；Object的key是无序的
3. Map是可以迭代的；而Object是不可以迭代的（Map迭代的item是数组形式的键值对）
4. Map在频繁增删键值的场景下表现更好，而Object不行

可以使用instanceof和toString来进行判断类型

使用

```javascript
let a = new Map();
let b = new Map([[1,2],[3,4]])或者是一个可迭代对象（这里数组迭代出来就是一个个数组）

a.set(key,value)//任意类型
a.get(key)//返回对应值，没有就undifined
b.delete(key)//存在元素返回true，不存在返回false
b.size//多少个键值对
b.has(key)//是否存在，返回布尔值

可以使用...进行扩展，扩展出来是一个个长度为二的数组，也是因为这个特性，可以对多个Map或数组进行合并

//使用for of遍历
for(let i of b) 每一个i是个长度为二的数组
//使用forEach遍历
b.forEach(function(value, key) {
  console.log(key + " = " + value);
})
一个参数是value 第二个参数是key 注意！！！

如果value或者key没有引用类型，则可以直接使用new Map(另一个Map)进行拷贝，是深拷贝
但如果value或者key有引用类型，就要对其进行处理，不然拷贝过来的是引用地址
```

**Set**，允许你存储任何类型的**唯一值**，无论是原始值还是对象引用，可以**按照插入的顺序迭代**它的元素

`NaN`和`undefined`都可以被存储在Set 中， `NaN`之间被视为相同的值（NaN被认为是相同的，尽管 NaN !== NaN）

一些情况下可以用来对数组的去重

没有像数组一样的索引调用，也没有像Map一样的用get调用，单独调用一个值出来好像只能遍历

可以用instanceof 和 toString来进行类型判断

```javascript
let a = new Set();
let b = new Set([1,2,3,44,4,4,5]);或者是一个可迭代对象（这里数组迭代出来就是一个个数组）,不重复的添加到Set里面

大部分和Map类似
a.add(val)//返回该Set对象
let setIter = b.values();//返回新的迭代器对象，
setIter.next().value //1

也可以用扩展运算符...扩展，得出的是一个个值

for of的item是values

b.forEach(callback,[,thisArg])
callback必选
为集合中每个元素执行的回调函数，该函数接收三个参数：
	currentValue, currentKey可选
	currentValue 是正在被操作的元素。并且由于集合没有索引，所以 currentKey 也表示这个正在被操作的元素。
set可选 调用当前 forEach 方法的集合对象
thisArg可选 回调函数执行过程中的 this 值。

关于拷贝，和Map的情况一样
```



### 获取URL中的参数

```javascript
function getUrlParam(sUrl, sKey) {
    sUrl = sUrl.slice(sUrl.indexOf('?') + 1);
    var reg = /(\w+)=(\w+)/g
    var res_obj = {};
    sUrl.replace(reg,function(str,g1,g2){
        if(res_obj[g1] !== void 0){
            res_obj[g1] = [].concat(res_obj[g1],g2);
        }else{
            res_obj[g1] = g2;
        }
    });
    if(sKey === void 0){
        return res_obj;
    }else{
        return res_obj[sKey] || '';
    }
}
```



### 正则表达式

限定符

1. *表示0次或多次
2. +表示1次或多次
3. ?表示0次或1次
4. {6}6次
5. {2,6}2-6次
6. {6,}6次以上

或运算符

1. a|b 匹配a或b

元字符

1. \d 数字 \D 非数字
2. \w 单词字符（英文、数字、下划线） \W 非单词字符
3. \s 匹配空白符（包含换行和Tab） \S非空白符
4. . 任意字符（除了换行符）
5. ^行首 $行尾

转义符号: \

标志：

1. i 忽略大小写
2. g 全局匹配
3. m 多行修饰符：锚点元字符 `^` `$` 工作范围在每行的起始

JS创建正则表达式:

1.  var a = new RegExp(/表达式/)
2.  var a = /表达式/

> RegExp.test(str) 返回布尔值
>
> str.replace(regexp/str,replacement/callback) 
>
> callback(str,p1,p2...,offset,string,NameCaptureGroup)
>
> 第一个参数是匹配到的字符串
>
> p1,p2..表示正则表达式里面的括号
>
> offset表示偏移量
>
> string表示原字符串
>
> NameCaptureGroup命名组匹配的对象 不知道有是没用，普通打印出来的是undifined



### offset,client,scroll区别及联系

首先 offset所涉及的Widht和Height是包括了border,padding和实际内容的

而client所涉及的Widht和Height只包括了padding和实际内容

而scroll所涉及的Widht和Height只包括了实际内容

三者所返回的数值都不带单位，一个比一个包含的内容少，且会涉及清空浏览器渲染队列



其次三者涉及的Top和Left也是不一样的

offset涉及的Top，是元素距离带有定位的父元素上方的距离，left同理

而client涉及的Top，是元素上边框的大小，left同理

而scroll涉及的Top，是被卷去的上侧的距离，left同理

三者区别还是很大的，特别是client与另外两个的区别



### innerHTML和createElement的效率测试

不同浏览器下，innerHTML的效率要比createElement效率高，但这是在innerHTML采用数组拼接的方法的情况，如果采用`+`拼接字符串，效率就会大幅下降

> 还有种动态创建元素的方法
>
> document.write('<div></div>')
>
> 它是把内容直接写入页面的内容流，当文档流执行完毕再执行这个函数的时候，会把原本的内容替换掉，引起页面回流





### 说一些常用的BOM对象

首先BOM是浏览器对象

常用的对象：location对象，history对象，Navigator对象

**location对象**

1. location.href 返回或设置当前文档的URL
2. location.search 返回URL中的查询字符串部分
3. location.hash 返回URL中#的部分
4. location.host 返回URL中的域名部分
5. location.assign 设置当前文档的URL
6. location.replace() 设置当前文档的URL，并且在**history对象**的地址列表中移除这个URL location.replace(newUrl)
7. location.reload() 重载当前页面

**history对象**

1. history.go() 前进或后腿指定的页面数（正数或负数，0是刷新页面）
2. history.back() -- 后退一页
3. history.forward() -- 前进一页

**Navigator对象**

1. navigator.userAgent 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)也就是HTTP头部的user-agent字段的信息
2. navigator.cookieEnabled 返回浏览器是否支持(启用)cookie



### export和export default的区别

`export`命令对外接口是**有名称的**且`import`命令从模块导入的变量名与**被导入模块对外接口的名称相同**,可以用as来进行更改名字，可以export多个变量，或者用一个export {param1,param2}，接收时也是{param1,param2}

```javascript
export function multiply(x, y) {
  return x * y;
};

import {multiply} from './profile.js'
```



而export default命令对外输出的**变量名可以是任意的，不需要知道原本的变量名**，这时`import`命令后面，**不使用大括号**。

```javascript
export default function(){
}

import param from './profile.js'
```



换一个角度来看，export default就是输出一个default的变量和方法，所以可以用export输出一个default的变量，但实际效果与export default相比我也不是很清楚

> `export default`命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此`export default`命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应`export default`命令。



### JS迭代器

**迭代器是**什么？迭代器就是为实现**对不同集合进行统一遍历操作**的一种机制

什么是**迭代器模式**？提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部元素。

为什么要**使用迭代器**？JS对于遍历聚合对象中各个元素（Array，Set，Map，Object），会采用不同的遍历方式，如果后端返回的数据结构发生变化，会导致前端大量代码重写，所以使用迭代器，就是要**标准化迭代操作**



**在JavaScript中**，**迭代器**就是一个**对象**（这个对象中有next方法），这个对象定义一个序列，并在终止时可能返回一个返回值。

更具体的说，迭代器这个对象通过next()方法返回具有两个属性的对象：**value**（这是序列中的 next 值）和**done**（如果已经迭代到序列的最后一个值，则它就是true），这个有value和done的对象就是迭代器的返回值

>  只能迭代一次的Iterables（例如Generators）通常从它们的**@@iterator**方法中返回它本身，其中那些可以多次迭代的方法必须在每次调用**@@iterator**时返回一个新的迭代器。

**迭代协议**分为两个部分：

1. 可迭代协议
2. 迭代器协议

**可迭代协议**规定了，运行JS对象定义或定制它们的迭代行为。

如何定制呢？要成为可以迭代的对象，对象必须有**@@iterator方法**（[Symbol.iterator]）

**迭代器协议**规定了，产生 **迭代的一系列的值**的标准方式。

当值为有限个时，所有的值都被迭代完毕后，则会返回一个**默认返回值**。

也就是规定了拥有特殊写法的next方法（包括规定返回值，value，done的内容等等），拥有这个next方法，对象才能成为可迭代的对象



**生成器函数**

用**function***这种声明方式表示这个函数是个**生成器函数**，返回一个Generator对象，也就是生成器对象，这对象有**next方法**，满足上述的迭代协议。

> **生成器对象**，既是一个迭代器，也是一个可迭代对象（@@iterator方法返回本身（本身这个迭代器））
>
> 生成器函数最多有255个参数

**生成器函数**在执行时能暂停，后面又能从暂停处继续执行。

调用 `next()`方法时，如果传入了参数，那么这个参数会传给**上一条执行的 yield语句左边的变量**

当在生成器函数中显式 `return `时，会导致生成器立即变为完成状态，即调用 `next()` 方法返回的对象的 `done `为 `true`。如果 `return `后面跟了一个值，那么这个值会作为**当前**调用 `next()` 方法返回的 value 值

不能当构造函数来使用



给对象定制迭代行为

```javascript
两种方法    
var obj = {
        a:1,
        [Symbol.iterator]:function(){
            let index = 0;
            let next = () =>{
                return {
                    value:index++,
                    done: index > 10 ? true : false
                }
            }
            return {
                next
            }
        }
    }

    var obj = {
        a:1, 
        [Symbol.iterator]:function*(){
            yield 1;
            yield 2;
            yield 3;
        }
    }

    for(let i of obj){
        console.log(i);
    }
```



### DOM事件流

JS代码只能执行捕获或者冒泡其中的一个阶段

onclick和attachEvent只能得到冒泡阶段，也就是说是冒泡开始的

addEventListener(type,listener[,options,userCapture,wantsUntrusted])

第四个参数为true,表示在**捕获阶段调用事件处理程序**；

如果是false(默认为fasle)，表示在**冒泡阶段调用事件程序**。

> 其实第三个参数是一个指定有关listener属性的对象。
>
> 属性分别是capture,once,passive
>
> - `capture`:  Boolean，表示 `listener` 会在该类型的事件捕获阶段传播到该 `EventTarget` 时触发。
> - `once`:  Boolean，表示 `listener 在添加之后最多只调用一次。如果是` `true，` `listener` 会在其被调用之后自动移除。
> - `passive`: Boolean，设置为true时，表示 `listener` 永远不会调用 `preventDefault()`。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。
>
> 第五个参数不是标准的参数
>
> wantsUntrusted如果为 `true `, 则事件处理程序会接收网页自定义的事件。此参数只适用于 Gecko（[chrome](https://developer.mozilla.org/zh-CN/docs/Glossary/Chrome)的默认值为true，其他常规网页的默认值为false），主要用于附加组件的代码和浏览器本身。



### 如何阻止事件发生

三种方法：

标准的：e.preventDefault();

非标准，兼容IE低版本：e.returnValue

特殊的：return false(之后的代码都没用了)



### 如何阻止事件冒泡

标准方法：e.stopPropagation()

兼容IE低版本的方法：e.cancelBubble = true



### 什么是高阶函数？

1.若A函数，接收的参数是一个函数，那么A就可以被称为高阶函数

2.若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数

两个中任意满足一个即可。

常见的，如Promise、setTimeout



### JS中sort的坑和sort源码

坑：https://segmentfault.com/a/1190000018076819

源码：https://zhuanlan.zhihu.com/p/33626637





React：https://juejin.cn/post/6844903985338400782#heading-22



### NestJS学习

文档：https://docs.nestjs.cn/7/firststeps

NestJS是一个高效，易于扩展的Nodejs框架。内置并完全支持TypeScript（eggjs就不能很好的支持，各种第三方库可能不受控制）。

Nest底层使用了强大的HTTP Server框架，如Express，Fastify。Nest在这些框架的基础上提供了一定程度的抽象，同时也将其API暴露给开发人员。这样可以轻松使用每个平台的第三方模块。



Nest通过依赖注入(DI)的方式进行控制反转。

只要声明模块中的依赖，Nest就会在启动的时候去创建依赖，然后自动注入到相应的地方。

依赖注入的最大作用就是依赖解耦，依赖的对象根据不同的情况可以有多种实现。



Nest遵从面向切面编程（AOP）的思想。

除了`Middleware`外，还有`Exception Filter`、`Pipes`、`Guards`和`Interceptors`几个预定义的切面，可以集中进行异常处理、数据验证、权限验证和逻辑扩展等功能。

Nest自带如数据验证等一些常用的基于切面的功能，也可以通过继承的方式来进行扩展。这些预定义的切面是代码架构的组成部分，按照这些约定来组织代码会大大降低日后的维护成本。

> 所谓AOP，简单理解就是在目标方法执行的前后，执行我们想要执行的代码，一般来说框架里面经常用到aop编程，而要做到aop，常常用到动态代理的技术。即会通过代理类，增强原有的目标类，加入方法执行前后需要执行的目标代码，这个过程不需要人为手动实现。



### 为什么很多Web项目还是使用px，而不是rem？

https://www.zhihu.com/question/313971223



### React中的Diffing算法

逐层比较，最小粒度是标签

**react/vue中key有什么用？为什么遍历列表时，key最好不要用index**？

首先我们知道react、vue高效的原因之一就是使用了虚拟DOM，在虚拟DOM中，**key是虚拟DOM的对象的标识**，在更新页面时key起着极其重要的作用。

当页面中的数据发生变化时，react会根据**新数据**生成**新虚拟DOM**。随后react会将**新虚拟DOM**和**旧虚拟DOM**进行diff比较，总的来说比较规则如下：

key相同的情况：

1. 若虚拟DOM内容相同，直接使用之前的真实DOM
2. 若内容不同，则生成新的真实DOM，替换页面之前的真实DOM

key不同的情况：

1. 直接根据新虚拟DOM创建新真实DOM，随后渲染到页面上



当使用index作为key时，可能会引发的问题：

1. 当对数据进行逆序添加，逆序删除等破坏顺序的操作时：会产生没必要的页面更新，页面效果没问题，但效率低。
2. 如果结构中包含输入类DOM：会产生错误的DOM更新，界面有问题。



**在开发中如何选择key？**

1. 最好使用每条数据的唯一标识作为key，比如id、手机号、学生号等唯一值。
2. 如果不存在对数据的逆序添加，逆序删除等破坏顺序的操作，只是简单的数据展示，用index也可以。



### 受控组件与非受控组件

对于存在表单输入的组件来说，该类组件分为受控组件和非受控组件

受控与非受控是什么意思呢？就是我们**对某个组件状态的掌控，它的值是否只能由用户设置，而不能通过代码控制**。



受控组件：

在HTML的表单元素中，它们通常自己维护一套`state`，并随着用户的输入自己进行`UI`上的更新，这种行为是不被我们程序所管控的。而如果将`React`里的`state`属性和表单元素的值建立依赖关系，再通过`onChange`事件与`setState()`结合更新`state`属性，就能达到**控制用户输入过程中表单发生的操作**。

能被React控制数据取值等操作的组件就叫做**受控组件**。

相反的，**React只能被动接收DOM表单返回的信息，不受React状态操作的表单输入组件**，就叫非受控组件



### 关于useState

返回一个 state，以及更新 state 的函数。

在初始渲染期间，返回的状态 (`state`) 与传入的第一个参数 (`initialState`) 值相同。

`setState` 函数用于更新 state。**它接收一个新的 state 值并将组件的一次重新渲染加入队列**。

在后续的重新渲染中，`useState` 返回的第一个值将始终是更新后最新的 state。

> 注意
>
> React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。



### 关于useEffect

在写第二个参数时，如果有个数组元素是对象，那么不管对象里面有什么，数据是否变换，useEffect每次都会更新

```jsx
    useEffect(()=>{
        console.log('变化');
    },[{name:'c'}])
```

new {name:'c'} !== old {name:'c'}

这种写法vscode会直接警告



### 在useEffect中调用函数

在 useEffect 中调用用函数时，如果该函数依赖组件作用域的props或state，要把该函数在 useEffect 中申明，把用到的变量写在第二个参数数组中，不能放到外部申明，然后再在 useEffect 中调用。在外部申明，在内部调用。这样是不安全的。

当函数不依赖props、state或它们衍生而来的值时，才能安全的指定的第二个参数为[ ]

为什么不安全？目前不能很好的说明原因，但如果不写依赖，effect内则不会更新，如果有一些判断事件，则会出bug



### useCallback

useCallback接收一个回调函数，一个依赖项数组作为参数，返回一个memoized（具有记忆技术的）回调函数，只有在依赖数组中值变化后才会更新返回值。

> memoization是JavaScript中的一种记忆技术，通过缓存结果并在下一个操作中重新使用缓存来加速查找效率的操作。
>
> 什么叫记忆性技术？
>
> 每次调用函数把你的传参和结果记录下来，遇到相同的传参，就直接返回记录缓存的结果，不用再去调用函数处理数据！

**误区**:useCallback是解决函数组件过多内部函数的性能问题（因为每次重新渲染，都要重新构造内部函数，所以我用这个函数，那么每次是不是就不会重新创建内部数组了呢？这是一大误区）

使用函数组件时经常定义一些内部函数，总觉得这会影响函数组件性能。也以为`useCallback`就是解决这个问题的，其实并不是：

1. JS内部创建函数很快的，这点性能不是问题
2. 相对于class更轻量的函数式组件，避免了HOC, renderProps等额外层级，函数式组件的性能较好
3. 使用了useCallback会额外增加性能，因为增加了额外的deps数组变换判断
4. 最重要的一点，useCallback不能解决内部函数重新创建的问题。不管是否使用useCallback，都无法避免重新创建内部函数。虽然函数引用不会变（这点我无从证实）

useCallBack**解决的问题时利用momeize函数减少不必要的组件渲染**

当一个子组件只用了一个内部函数，没用到其他状态，但其他状态更新了后，整个组件都要重新渲染，重新生成一个函数，导致函数引用不一样，从而导致了这个子组件也跟着重新渲染，但实际上两次渲染没有什么差别，白白浪费了性能。

（这里有个疑问，React.memo的作用感觉很鸡肋，因为React原本的渲染机制就不会去重新渲染那些props不变的组件，是用memo更快吗？还是我理解的渲染机制有问题）



### useMemo

useMemo的作用和useCallback的作用很相似，传入一个值和依赖数组，返回一个memoized的值，依赖数组变化后才会更新返回值

与useCallback的区别：

- useCallback针对的是函数，传参和结果都是函数；而useMemo主要针对那些计算量较大的值，避免组件进行一些冗余计算
- useCallback可以看作是useMemo的一种特殊情况；传入useMemo的函数具有限制，因为传入 useMemo的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如**副作用这类的操作**属于 useEffect的适用范畴，而不是 useMemo

**可以把 useMemo作为性能优化的手段，但不要把它当成语义上的保证。**



### Memo

React.memo是高阶组件

> 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。
>
> 具体而言，**高阶组件是参数为组件，返回值为新组件的函数。**

如果组件在相同 props 的情况下渲染相同的结果，那么可以通过将其包装在 `React.memo` 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。

> `React.memo` 仅检查 props 变更。如果函数组件被 `React.memo` 包裹，且其实现中拥有 [`useState`](https://zh-hans.reactjs.org/docs/hooks-state.html)，[`useReducer`](https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer) 或 [`useContext`](https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext) 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。

默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。



以上三个可以理解记忆：useCallback针对函数Memoized,useMemo主要针对参与渲染的值Memoized，Memo针对组件进行Memoized

这三个都可以减少渲染次数，从而达到页面性能优化，但不要过多的使用，「记住」这个过程本来就会消耗一定的内存和计算资源，考虑不使用memoized情况的开销，考虑每次对比是浅比较的情况，再进行使用这三个API

> 参与页面性能优化的API还有很多，比如useRef,useReducer,creatContext等，后续再深入学



### React中的portal

> 官方解释：Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。

React中的portal，能让一个React组件存放在任意一个存在的DOM节点内，就像给这个React组件开了一个传送门，最后能渲染在任一一个存在的DOM树内。

 portal 的典型用例是当父组件有 `overflow: hidden` 或 `z-index` 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框

具体使用:

ReactDom.createPortal(child,container)

- 第一个参数（`child`）是任何[可渲染的 React 子元素](https://zh-hans.reactjs.org/docs/react-component.html#render)，例如一个元素，字符串或 fragment。
- 第二个参数（`container`）是一个 DOM 元素。

**关于使用了portal的元素的事件冒泡**

使用了portal后，该元素在DOM树中的位置和在React树中的位置不一致，也就是在React中编写该元素时的位置与其渲染出来在DOM树中的位置不一致（这是显而易见的）

那么该元素的事件冒泡会被冒泡到React树的父级，而不是DOM树的父级

参考：

- 官方文档 https://zh-hans.reactjs.org/docs/portals.html




### 在腾讯实习这段时间做了什么？

首先我了解了我们组的业务，体验了我们组的产品。

我们中心是云开发产品中心，组内做的内容是微搭低码的控制台这一块。在我刚入职的那段时间，我在一边熟悉内部开发文档，一边体验产品，最后产出产品体验报告一份。

在体验完产品后，我开始了第一个项目需求，完成企业门户的登录应用鉴权。拿到项目后我开始阅读项目代码，项目是由React的框架antd pro这样一个企业级中后台作为前端框架，并用Nestjs作为中间转发层，搭配CONCENT作为react的数据状态管理，开发语言用的TS，JS的超集，更适合工程开发的语言，配上一些其他库如antd，tailwind，react-use进行开发。

因为之前没有接触过antd pro、concent和nestjs，所以我在边阅读项目边学习这些框架，浏览官方文档并代入公司项目中。学习差不多后开始编写代码，自测，ti填写自测报告，最后顺利完成该需求。

之后的任务就在项目联调，产品发布时跟进测试、交互的问题，随时进行代码修改。

完成的事有：在项目中编写代码把项目加入内部前端监控中；代码规范；对前端日志打印进行清除；发布前完成环境变更，修改运行态接口请求配置，改为prod发布现网环境；对页面进行响应式开发，完成移动端适配；对官方组件库的表单组件进行响应式适配，其实相当于写了个新的页面。

在这个过程中，还在学习扫码登录相关知识，为之后的需求做准备，但后续因为要准备秋招，于是换了其他需求给我做。

目前的话，产品发布后要进行周期性迭代，我这部分的随时准备做更新，并且在我离职之前我需要完成一些交接工作。



总结：这是我第一次的工作实习，感受最深是从一个学生变成一个公司开发人员的过程，学习到了大厂公司的开发模式，一个需求的开发流程，一个产品从开发到测试，到发布的过程，第一次在十分正式的工程里开发，这些都是在学校中学不到的。当然也有技术的提升，在公司做项目学到了很多我平时都没接触过的框架，库，如nestjs，tailwind这些技术前沿的东西，我去学习这些框架，阅读文档，了解一些思想，设计原理，这些都是对我技术的提升。

具体一点：

Git的操作。之前学校里做自己的项目，虽然也使用了Git，但因为人数较少，开发周期较短，遇到的问题不多，对git的使用仅限于拉取，推送，冲突的处理等小问题，在实习时对git有了更好的理解，也学到了更多的操作，如git rebase,git stash,git reset等，学会了如何提一个PR，MR，也在学习git可视化工具如Fork。

nestjs的学习。在做登录鉴权的时候，主要就是在nestjs里面进行开发。前端发送的请求是一步一步的通过nestjs的

客户端请求 -> Middleware中间件 -> Guard守卫 -> 请求拦截器 -> Pipe管道 -> Controllor层的路由处理函数 -> 响应拦截器 -> 客户端响应

中间件，拦截器都是在对前端请求做一些处理，进行一些日志的打印。我主要是在guard守卫处进行设置，首先要判断的是用户有无登录进入的权限，我在guard进行判断，如果没有权限则直接抛出错误，让异常过滤器进行处理。然后对于一些页面中的接口请求，我会通过自定义装饰器，nestjs内部接口SetMetadata来对services中的类中处理函数进行装饰，自定义时会用装饰器接收一个参数作为权限，如果用户要调用这个接口，那么在controllor层通过reflector取出这个自定义参数，用户的权限中必须包含这个自定义参数，没有的话就会抛出不存在权限的错误。**这样的写法耦合性较低，编写起来也十分方便，不用写过多的冗余代码**。当然也会对前端进行路由守卫，antd pro的路由守卫是通过在access文件和router文件里进行配置，首先返回的access对象中要有判断的变量，然后填入router配置中的access值，代表如果这个access为真，则能访问，为假则进入wrappers中配置的页面（错误边界？）

微搭这个项目是以云开发为基础的，我所做的登录有两次判断，首先是直接调用云开发的SDK进行账号密码的判断，之后是上述的访问登录权限判断。因为这个登录只与门户这一个系统有关，并不是单点登录。



### Function hooks相比Class components有什么优势

类组件的不足（3点）：

1. **状态逻辑难以服用**：在组件之间复用状态逻辑很难，可能要用到 **render props** （**渲染属性**）或者 **HOC**（**高阶组件**），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素），**导致层级冗余**
2. **趋向复杂难以维护**：生命周期函数多，常常包含一些不相关的逻辑，相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。类组件中到处都是对状态的访问和处理，导致组件难以拆分成更小的组件。
3. **this的指向问题**：自身内部写方法时，需要注意this指向；父组件给子组件传递函数时，必须绑定 this，父组件给子组件绑定this的方法有多种，但如果写法不注意，会造成性能损耗。

而Hooks对上述问题进行了优化（4点）：

1. 能在无需修改组件结构的情况下复用状态逻辑（自定义 Hooks ）

2. 能将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）

3. 使用多个Effect来分离不同副作用关注点：以往这些副作用都是写在类组件生命周期函数中的，常常包含一些不相关的逻辑。而 我们可以使用多个useEffect来分离多个副作用关注点，一个副作用关注点属于一个Effect。也就是说**Hooks 允许我们根据代码的用途来分割代码** 。（业务代码更聚合）

   > 副作用指那些没有发生在数据向视图转换过程中的逻辑，如 `ajax` 请求、访问原生`dom` 元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志等
   >
   > 而useEffect在全部渲染完毕后才会执行，useLayoutEffect 会在浏览器 layout 之后，painting 之前执行。

4. 代码更简洁，可读性更好



Hooks的缺点（2点）：

1. 响应式的useEffect:有时候，你的useEffect依赖某个函数的不可变性，这个函数的不可变性又依赖于另一个函数的不可变性，这样便形成了一条依赖链。一旦这条依赖链的某个节点意外地被改变了，你的useEffect就被意外地触发了，如果你的useEffect是幂等的操作，可能带来的是性能层次的问题，如果是非幂等，那就糟糕了。
2. hooks存在旧引用的问题：函数的运行是独立的，每个函数都有一份独立的作用域。函数的变量是保存在运行时的作用域里面。当我们有**异步**操作的时候，经常会碰到异步回调的变量引用是之前的，也就是旧的（这里也可以理解成闭包）。这里可以用useRef来解决问题。

> useRef 返回一个可变的 ref 对象，其 `current` 属性被初始化为传入的参数（initialValue）
>
> useRef 返回的 ref 对象在组件的整个生命周期内保持不变，也就是说每次重新渲染函数组件时，返回的ref 对象都是同一个（使用 React.createRef ，每次重新渲染组件都会重新创建 ref）



### MVC MVP MVVM设计模式

MVC：Model-View-Controller设计模式

MVP：Model-View-Presenter设计模式

MVVM：Model-View-ViewModel设计模式

**MVC**

MVC是比较直观的架构模式。

用户进行操作——（View接收用户的操作）——传递给Controller进行业务逻辑处理——Model进行数据存储，并将结果返回给View

以上这是一次完整的MVC模式。

Model是数据模型。View是视图，或者说是我们要去展示的东西。Controller是用来控制Model的读取，存储，以及如何在View上展示数据，更新数据的逻辑控制器

缺点：

- MVC 框架的大部分逻辑都集中在 Controller 层，代码量也都集中在 Controller 层，这带给 Controller 层很大的压力，而已经有独立处理事件能力的 View 层却没有用到。
- 还有一个问题，就是 Controller 层和 View 层之间是一一对应的，断绝了 View 层复用的可能，因而产生了很多冗余代码。

**MVP**

MVP是把MVC中的Controller换成了Presenter（呈现），彻底隔绝了View层和Model层的通信

相对于MVC的修改：

- 首先是因为 Model 层和 View 层都必须通过 Presenter 层来传递信息，所以完全分离了 View 层和 Model 层，也就是说，View 层与 Model 层一点关系也没有，双方是不知道彼此存在的，在它们眼里，只有 Presenter 层。
- 其次，因为 View 层与 Model 层没有关系，所以 View 层可以抽离出来做成组件，在复用性上比 MVC 模型好很多。

总的来说就是耦合性降低，复用性好很多

缺点：

- 因为 View 层和 Model 层都需经过 Presenter 层，致使 Presenter 层比较复杂，维护起来会有一定的问题。（个人认为这也是MVVM的缺点）
- 而且因为没有绑定数据，所有数据都需要 Presenter 层进行“手动同步”，代码量比较大，虽然比 MVC 模型好很多，但也是有比较多的冗余部分。

**MVVM**

MVVM是把**数据模型数据双向绑定**的思想作为核心，因此在View和Model上没有联系，通过ViewModel进行交互，而Model和ViewModel之间的数据交互是双向的，ViewModel是一个**View 信息 的存储结构**，ViewModel和View上的信息是一一映射关系。

使用 MVVM 模式，程序的 UI 和其背后的展现与业务逻辑将被分离至三个类中：

- 视图，封装 UI 与 UI 逻辑。

  负责界面和显示。

- 模型视图，封装展示逻辑和状态(数据、信息)

  负责协调视图与任何需要的模型类的交互。视图模型提供的属性和命令定义了提供给UI 的功能。但是视图定义了如何渲染的功能。

  视图模型是View和Model的桥梁，是对Model的抽象，比如：Model中数据格式是“年月日”，可以在ViewModel中转换Model的数据为“日月年”供View显示。

- 模型，封装程序的业务逻辑以及数据

  模型不关心会被如何显示或是如何被操作，模型也不能包含任何用户使用的与界面相关的逻辑。

使用MVVM的好处：

1. 低耦合。View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。
2. 可重用性。可以把一些视图逻辑放在ViewModel里面，让很多View重用这段视图逻辑。
3. 独立开发。开发人员可以专注业务逻辑与数据的开发（ViewModel）。设计人员可以专注于界面（View）的开发
4. 可测试性。可以针对ViewModel来对界面(View)进行测试

MVVM与MVP的区别：
两者差别不大，但ViewModel 层双向绑定了 View 层和 Model 层，因此，随着 View 层的数据变化，系统会自动修改 Model 层的数据，反之同理。而 Presenter 层是采用手动写方法来调用或者修改 View 层和 Model 层，需要更多的处理。

MVVM 模型中数据绑定方法一般有以下3种：

- 数据劫持
- 发布-订阅模式
- 脏值检查

Vue的MVVM实现是数据劫持

React，单向数据流。本身只是 一个函数 ui = render (data) 官方就这么简单一个公式。加上状态管理等，可以做 MVVM 风格的开发。

不管是 MVC 还是 MVVM ，具体到实际框架，组成成分之间都不会泾渭分明，几种组成成分之间常常有难以划分的模糊地带。如果忽略划分细节从整体来看，Vue 参考但没有完全遵循 MVVM，React 只是一个 View 层。

参考：

- http://c.biancheng.net/view/7743.html
- https://www.jianshu.com/p/9037026513a2



### 进程与线程的区别

进程：CPU分配资源的最小单位，是能拥有资源和独立运行的最小单位

线程：CPU调度的最小单位。线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程。

不同的进程拥有不同的内存空间，进程之间需要通信（IPC，进程间通信）



### 进程间通信IPC有哪些方法

**管道/匿名管道pipe**

管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。

只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);

单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。

数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

**管道的实质**

管道的实质其实就是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。
 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。
 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。

**管道的局限：**
 管道的主要局限性正体现在它的特点上：

- 只支持单向数据流
- 只能用于具有亲缘关系的进程之间
- 没有名字
- 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）
- 管道所传送的是无格式字节流，这就**要求管道的读出方和写入方必须事先约定好数据的格式**，比如多少字节算作一个消息（或命令、或记录）等等



**有名管道FIFO**

匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。**为了克服这个缺点**，提出了有名管道(FIFO)。
 有名管道不同于匿名管道之处在于它提供了一个**路径名与之关联**，**该路径名以文件形式存在于文件系统中**，这样，**即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信**，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循**先进先出(first in first out)** 对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。**有名管道的名字存在于文件系统中，内容存放在内存中。**



**匿名管道和有名管道总结：**
 （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。
 （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
 （3）**无名管道阻塞问题：**无名管道无需显示打开**，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出**。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，**如果管道发现另一端断开，将自动退出**。
 （4）**有名管道阻塞问题：**有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。



**信号Signal**

信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。

系统消息从一个进程发送到另外一个进程，一般不用于传输数据，而是用于远程传输命令。

如果该进程当前并未处于执行状态，则该信号就有**内核**保存起来，知道该进程回复执行并传递给它为止

如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。

> 内核是一个操作系统的核心。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性。是连接应用程序和硬件的桥梁。



**消息队列Message**

消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。

与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。

另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达

特点：

（1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.
 （2）消息队列允许一个或多个进程向它写入与读取消息.
 （3）管道和消息队列的通信数据都是**先进先出的原则**。
 （4）消息队列可以实现消息的随机查询,消**息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。**
 （5）消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。
 （6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系**统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。**



**共享内存Share Memory**

使得多个进程可以可以直接读写同一块内存空间，**是最快的可用IPC形式，是针对其他通信机制运行效率较低而设计的**。

为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率

由于多个进程共享一段内存，因此需要依靠某种同步机制（如**信号量**）来达到进程间的同步及互斥

> **信号量(semaphore)**
>
> 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。
>  为了获得共享资源，进程需要执行下列操作：
>  （1）**创建一个信号量**：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。
>  （2）**等待一个信号量**：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。
>  （3）**挂出一个信号量**：该操作将信号量的值加1，也称为V操作。
>
> **信号量与普通整型变量的区别：**
>  （1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；
>  （2）操作也被成为PV原语（P来源于荷兰语proberen"测试"，V来源于荷兰语verhogen"增加"，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；
>
> **信号量与互斥量之间的区别：**
>  （1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。
>  **互斥：**是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
>  **同步：**是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。
>  在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源
>  （2）互斥量值只能为0/1，信号量值可以为非负整数。
>  也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。
>  （3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。

​	

**套接字Socket**

套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。

套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。

> 创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。
>
> “TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。”
>
> 实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。socket是对端口通信开发的工具,它要更底层一些。



### CPU GPU

首先我们要说的是计算机的大脑 - CPU（**C**entral **P**rocessing **U**nit）中央处理器。CPU是计算机里面的一块芯片，上面有一个或者多个核心（core）。我们可以把CPU的一个核心（core）比喻成一个办公室工人，他**功能强大**，上知天文下知地理，琴棋书画无所不能，**它可以串行地一件接着一件处理交给它的任务**。很久之前的时候大多数CPU只有一个核心，不过在现在的硬件设备上CPU通常会有多个核心，因为多核心CPU可以大大提高手机和电脑的运算能力。



图形处理器 - 或者说GPU（**G**raphics **P**rocessing **U**nit）是计算机的另外一个重要组成部分。和功能强大的CPU核心不一样的是，单个GPU核心只能处理一些简单的任务，不过它胜在数量多，单片GPU上会有很多很多的核心可以同时工作，也就是说它的**并行计算能力是非常强**的。图形处理器（GPU）顾名思义一开始就是专门用来处理图形的，所以在说到图形**使用GPU**（using）或者**GPU支持**（backed）时，人们就会联想到图形快速渲染或者流畅的用户体验相关的概念。最近几年来，随着**GPU加速概念**的流行，在GPU上单独进行的计算也变得越来越多了。



### CPU调度策略（CPU调用进程的方式）

首先，我们要明白我们的算法应该让什么更好呢？**面对客户**：银行调度算法的设计目标应该是**用户满意**；而**面对进程**：CPU调度的目标应该是**进程满意**。

那怎么才能让进程满意呢？那就是时间了。

进程希望**尽早地结束任务**，这就是**周转时间(从任务到达到任务结束)要短**，而且希望**用户的操作能够尽快地被响应**，这就是**响应时间(从操作发生到响应)要短**。而且**系统内耗时间要少，吞吐量(任务的完成量)要大**，系统需要把更多的时间用再任务的执行上，而不能老是去做无关紧要的事情，例如：频繁切换任务，切换栈，分配资源等事情。同时，系统还要去合理地调配任务。

**那么，CPU的调度策略如何做到合理呢？**

**首先得明白系统中有以下的几种矛盾。**

**1.吞吐量和响应时间之间有矛盾**

响应时间小=>切换次数多=>系统内耗大=>吞吐量小

由于需要较短的响应时间，那么就得频繁地切换任务，这样系统的很多时间都花在切换任务上面了，系统的内耗大了，吞吐量就小了。

**2.前台任务和后台任务的关注点不同**

前台任务关注响应时间，后台任务关注周转时间。

前台任务例如我们的word文档，我们打一个字，需要立马显示在文档中，这就是word文档这个任务关注的是响应时间；而后台任务中，例如我们的javac编译java代码，它的周转时间要小，即该任务从进入到结束所花的时间要小，即编译完成的时间要小。

**3.IO约束型任务和CPU约束型任务各有各的特点**

IO约束型任务就是使用CPU的时间较少，进行IO操作的时间较长，CPU约束型的任务就是使用CPU的时间较长。

**因此，要做到合理，需要折中、综合考虑以上的几种矛盾。**

**由此，产生了以下一些CPU的调度算法。**

各种CPU调度算法

**批处理时代**

**FCFS, First Come，First Served**

先来先服务的调度算法，哪个任务先进来，就为哪个任务先服务。

**SJF, Shot Job First**

短作业优先，就是哪个任务的服务时间短就先调度哪个

**HRRN，Highest Response Ratio Next**

**高响应比优先**

综合考量进程的两个属性：**等待时间**和**要求服务时间**——等待时间长，要求服务时间短（就是短进程）的进程更容易被选中。

为了量化，我们制定了一个公式：响应比 = （等待时间+要求服务时间）/ 要求服务时间。响应比高的算法会先执行。

**并发时代（伪并发）**

**RR算法,Round Robin**

**按时间片来轮转调度**

那按时间片轮转的调度算法是设置一个时间片，比如为10的CPU时间，然后不停地在A、B、C、D四个进程中切换，每个进程执行时间10，时间到了就切换到下一个进程执行时间10，直到全部执行完毕。

为每个进程分配10的CPU时间，轮转调度执行，这样每个进程的响应时间就变小了。

如果时间片设置过大，那响应的时间就会太长，如果时间片设置过小，那整个系统都在不停地切换进程，系统很多时间都浪费在切换进程上面了，造成系统的吞吐量小，折中考虑后，时间片设置为10~100ms，切换的时间为0.1~1ms.

**VRR算法，Virtual Round Robin**

虚拟轮转法，通过一个辅助队列，解决了I/O密集型进程性能响应问题

> I/O 密集型进程不这么认为，他对我说：“调度器大哥，时间片轮转没有照顾到我们这类进程啊！我们经常在 CPU 没呆到一半时间片，就遇到了阻塞操作，被你赶下去。而且我们在**阻塞队列**，往往要停留很长时间。等阻塞操作结束，我们还得在**就绪队列**排好长时间队。那些处理器密集型进程，使用了大部分的处理器时间，导致我们性能降低，响应时间跟不上”
>
> 考虑到这些进程的要求，我决定为他们创建一个新的辅助队列。阻塞解除的进程，将进入这个辅助队列，进行进程调度时，优先选择辅助队列里的进程。

**优先级调度算法**

每个进程将被赋予一个**优先级**，自己根据自己的情况确定优先级数值，但是，用户进程的优先级**不准高于**内核进程的优先级。

切换程序的时候，我会从优先级 1 的队列里选择一个进程，如果优先级 1 队列为空，才会选择优先级 2 中的进程，以此类推。

当然，为了保证低优先级进程不会**饥饿**，我会调高等待时间长的进程的优先级。

> 进程饥饿，即为Starvation，指当等待时间给进程推进和响应带来明显影响称为进程饥饿。当饥饿到一定程度的进程在等待到即使完成也无实际意义的时候称为饥饿死亡。



**总结：先来先服务算法，短进程优先算法，高响应比优先算法，时间片轮询调度算法，虚拟轮转算法，优先级调度算法。**

**还有一些比如最短剩余时间优先算法，多级队列调度算法等等**

以上算法还可以分类为**抢占式调度和非抢占式调度**

**抢占式调度**

在“抢先式调度”中，大多数任务都分配有其优先级。有时，即使较低优先级的任务仍在运行，在另一个较低优先级的任务之前运行具有较高优先级的任务也很重要。较低优先级的任务会保留一段时间，并在较高优先级的任务完成执行时恢复。

**非抢占式调度**

在这种调度方法中，已将CPU分配给特定的进程。使CPU保持繁忙的进程将通过切换上下文或终止来释放CPU。这是可用于各种硬件平台的唯一方法。那是因为它不需要抢先式调度之类的特殊硬件（例如计时器）。

| **抢占式调度**                                               | **非抢占式调度**                                             |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| 可以抢占处理器以在任何当前进程执行的中间执行不同的进程。     | 处理器开始执行后，必须先执行它，然后再执行另一个。它不能在中间暂停。 |
| 与非抢先式调度相比，CPU利用率更高。                          | 与抢先式调度相比，CPU利用率较低。                            |
| 抢占式调度的等待时间和响应时间更少。                         | 非抢占式调度方法的等待时间和响应时间较长。                   |
| 优先调度优先级高的进程。最高优先级的过程是当前使用的过程。   | 当任何进程进入运行状态时，该进程的状态永远不会从调度程序中删除，直到完成其工作为止。 |
| 抢占式调度非常灵活。                                         | 非抢占式调度是严格的。                                       |
| 示例：最短剩余时间优先，优先级调度算法，最短作业优先，高响应比优先算法等。 | 示例：先到先服务，时间片轮询调度算法等。                     |

> **调度是抢占式还是非抢占式？**
>
> 要确定调度是抢占式还是非抢占式，请考虑以下四个参数：
>
> 1. 进程从运行状态切换到等待状态。
> 2. 特定过程从运行状态切换到就绪状态。
> 3. 特定过程从等待状态切换到就绪状态。
> 4. 进程完成其执行并终止。
>
> **仅条件1和4适用，调度称为非抢先。**
>
> **所有其他调度都是抢占式的。**



参考文章：

​	几种CPU调度策略：https://cloud.tencent.com/developer/article/1472672

​	进程调度， 一个调度器的自白：https://segmentfault.com/a/1190000020525157



### 操作系统基础——进程管理之五状态模型

- 创建状态
- **就绪状态**
- **阻塞状态**
- **执行状态**
- 终止状态

详见：

操作系统基础(三)---进程管理之五状态模型 https://segmentfault.com/a/1190000023024872?hmsr=coffeephp.com&utm_medium=coffeephp.com&utm_source=coffeephp.com

