# 面试Q&A

字节的一个面试题，一个东西，settime就出一个，可以随时终止，利用异步的思想。

赛马问题。



### 透明与黑盒

透明：指客观存在并且运行着但是我们看不到的特性。客观存在的，但对于某些开发人员而言又不需要了解的东西，这就是计算机所指的透明性

黑盒：指客观存在并运行着，但开发人员看得见，且无法探究其内部东西，是不“透明的”。



### 如何使集群共享session且稳定？

先说说方法：

1. 找一块公共地方来存储session，而不是将session存储在集群节点的某个服务器上，这样每一台服务器都能访问这块空间，实现session共享
2. 每台服务器仍存储session，不做修改，但采取另外一种同步机制，实时同步每一台服务器的session信息

具体实现方案：

1.持久化session到数据库，即使用数据库来储存session。数据库正好是我们普遍使用的公共储存空间，一举两得，推荐使用mysql数据库，轻量并且性能良好。

**优点：**就地取材，符合大多数人的思维，使用简单，不需要太多额外编码工作。

**缺点：**对mysql性能要求较高，访问mysql需要从连接池中获取连接，又因为大部分请求均需要进行登录鉴权，所以**操作数据库非常频繁，当用户量达到一定程度之后，极易造成数据库瓶颈，不适用于处理高并发的情况。**

2.用redis共享session。redis是一个key-value的储存系统。可以简单的将其理解为一个数据库，与传统数据库的区别是，它将数据储存于内存中，并自带有内存到硬盘的序列化策略，即按策略将内存中的数据同步到磁盘，避免数据丢失，是目前比较流行的解决方案。

**优点：无需增加数据库的压力，因为数据存储于内存中，所以读取非常快，高性能，并能处理多种类型的数据。**

**缺点：**额外增加一些编码，以便操作redis。

3.使用Cookie共享session。此方案可以说是独辟蹊径了，将分布式思想用到了极致。如上文分析所说，session-cookie机制中，session与cookie相互关联，以cookie做中转站，用来找到对应的session，其中session存放在服务器。那么如果将session中的内容存放在cookie中呢，那么则省略了服务器保存session的过程，后台只需要根据cookie中约定的标识进行鉴权校验即可。

**优点：**完美的贯彻分布式的理念，将每个用户都利用起来，无需耗费额外的服务器资源；

**缺点：**受http协议头长度限制，cookie中存储的信息不宜过多；为了保持cookie全局有效，所以其一般依赖在根域名下，所以基本上所有的http请求都需要传递cookie中的这些标记信息，所以会占用一些服务器的带宽；鉴权信息全存储于cookie中，cookie存在于客户端，服务器并没有储存相关信息，cookie存在着泄露的可能，或则其他人揣摩出规则后可以进行伪装，其安全性比其他方案差，故需要对cookie中信息进行加密解密，来增强其安全性。 

4.使用memcache同步session，memcache可以实现分布式，可将服务器中的内存组合起来，形成一个“内存池”，以此充当公共空间，保存session信息。

**优点：**数据储存在内存中，读取非常快，性能好；

**缺点：**memcache把内存分成很多种规格的存储块，有大有小，不能完全利用内存，会产生内存碎片，浪费资源，如果储存块不足，还会产生内存溢出。

 

### 编译性语言和解释性语言

高级语言若想被计算机执行，都必须将其转换为计算机语言，也就是机器码。而转换的方式有两种：

**编译**与**解释**

所以高级语言也分为**编译型语言（C C++）和解释性语言（Python JS）** 

> JS是脚本语言，脚本语言不需要编译，是由js解释器逐行解释并执行的

**主要区别在于，前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。**

**编译性语言**

特点：

在编译型语言写的程序执行之前，**需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可**，如直接运行exe文件。**因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。**

总结：

1.一次性的编译成平台相关的机器语言文件，**运行时脱离开发环境，运行效率高**；

2.与特定平台相关，一般无法移植到其他平台；

**解释性语言**

特点：

解释型语言**不需要事先编译，其直接将源代码解释成机器码并立即执行**，所以只要**某一平台提供了相应的解释器即可运行该程序。**

总结：

1.解释型语言每次运行都需要将源代码解释成机器码并执行，**效率较低**；

2.只要平台提供相应的解释器，就可以运行源代码，所以可以**方便源程序移植**；

**两者各有利弊**

前者由于**程序执行速度快，同等条件下对系统要求较低**，因此像**开发操作系统、大型应用程序、数据库系统**等时都采用它

而一些网页脚本、服务器脚本及辅助开发接口这样的**对速度要求不高、对不同系统平台间的兼容性有一定要求**的程序则通常使用解释性语言

> JAVA即是编译的，也是解释的。非要归类的话，从概念上来讲，应该会定义到解释性语言中
>
> JAVA先编译，但编译后不能直接运行，要通过JVM来解释运行，所以是解释语言（但现在的JVM有一些有JIT优化，它又会把.class的二进制代码编译为本地的代码直接运行，就又是编译语言了）



### 面向对象的三大特性，五大基本原则

**三大特性：**

- 封装：封装就是**隐藏对象的属性和实现细节**，仅仅对外公开接口，控制在程序中属性的读写的访问级别，**将抽象得到的数据和行为相结合，形成一个有机的整体**，也就是将数据和操作数据的源代码相结合，形成"类"，其中数据和函数都是类的成员

  封装的目的就是**增强安全性和简化编程**，使用者不必了解具体的实现细节，而要通过外部接口，特定的访问方法来使用类的成员

- 继承：继承允许创建分等级层次的类。继承就是**子类继承父类的特征和行为**，使得子类对象（实例）有父类对象（实例的方法）的属性和方法。

  有时我们**抽取共有特征和方法形成更高一层的类**，再用详细的子类去继承，**提高了代码的复用率**

- 多态：**同一个行为具有多个不同表现形式或形态的能力**，指一个类实例（对象）的相同方法在不同情形中有不同的表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。

  **多态的优点：**

  1. 消除类型之间的耦合关系

  2. 可替换性

  3. 可扩充性

  4. 接口性

  5. 灵活性

  6. 简化性

  　　一般来说，多态存在的三个必要条件：

  - 继承
  - 重写（子类继承父类后对父类方法进行重新定义）
  - 父类引用指向子类对象（暂时没理解）

  简言之，多态其实是在继承的基础上的。

  > 但TypeScript中多态就可以直接写，不用在继承的基础上

**五大基本原则**

1. 单一职责原则(SRP)

   一个类应该有且只有一个去改变它的理由，也就是一个类应该只有一个工作

2. 开放封闭原则(OCP)

   对象或实体应该对扩展开放，对修改封闭。

   > 更改封闭即是在我们对模块进行扩展时，勿需对源有程序代码和DLL进行修改或重新编译文件！这个原则对我们在设计类的时候很有帮助，坚持这个原则就必须尽量考虑接口封装，抽象机制和多态技术！

3. 里氏替换原则(LSP)

   在对象 x 为类型 T 时 q(x) 成立，那么当 S 是 T 的子类时，对象 y 为类型 S 时 q(y) 也应成立。（**即对父类的调用同样适用于子类**）

4. 依赖倒置原则(DIP)

   高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。具体实现应该依赖于抽象，而不是抽象依赖于实现

   > 可以这样理解，上面我举例子的时候先说了兔子和绵羊，然后才推出食草动物。但如果我们继续认识了牛、马等食草动物，我们会发现我们需要不断调整食草动物的描述，这样程序会变得僵化，所以我们不应该让子类依赖于实体，不应该让父类模块依赖于子类模块。所以我们需要将食草动物设计为抽象类，即**抽象类或接口**。这样下层只需要实现相应的细节而不会影响父类。

5. 接口隔离原则(ISP)

   不应强迫客户端实现一个它用不上的接口，或是说客户端不应该被迫依赖它们不使用的方法，使用多个专门的接口比使用单个接口要好的多！

   > 比如，为了减少接口的定义，将许多类似的方法都放在一个接口中，最后会发现，维护和实现接口的时候花了太多精力，而接口所定义的操作相当于对客户端的一种承诺，这种承诺当然是越少越好，越精练越好，过多的承诺带来的就是你的大量精力和时间去维护！

参考文章：

- 面向对象的三大特征，五大基本原则 https://www.cnblogs.com/fzz9/p/8973315.html



### 类的概念

虽然 JavaScript 中有类的概念，但是可能大多数 JavaScript 程序员并不是非常熟悉类，这里对类相关的概念做一个简单的介绍。

- 类（Class）：定义了一件事物的抽象特点，包含它的属性和方法
- 对象（Object）：类的实例，通过 `new` 生成
- 面向对象（OOP）的三大特性：封装、继承、多态
- 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据
- 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性
- 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 `Cat` 和 `Dog` 都继承自 `Animal`，但是分别实现了自己的 `eat` 方法。此时针对某一个实例，我们无需了解它是 `Cat` 还是 `Dog`，就可以直接调用 `eat` 方法，程序会自动判断出来应该如何执行 `eat`
- 存取器（getter & setter）：用以改变属性的读取和赋值行为
- 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 `public` 表示公有属性或方法
- 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现
- 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口



### Git的相关概念

四个区域：

工作目录：敲代码的地方

暂存区：git add之后的地方

本地仓库：git commit了之后的地方

远程仓库：git push了之后的地方，远程大家公用的项目代码仓库

前三个 合并共称为**开发环境**



### 说几个Git常用的命令

git clone 克隆仓库内容到本地

git init + git remote add origin + 仓库地址 	初始化&配置仓库地址

git add 从工作区保存到暂存区

git commit 从暂存区提交到本地仓库

git push 将本地仓库的代码传到远程仓库

git pull 拉取/同步远程仓库的代码

git status -s 查看工作区状态

git checkout 切换分支

git branch 创建分支

git reset 回退到目标分支 https://www.jianshu.com/p/c2ec5f06cf1a

> reset三种模式区别和使用场景
>
> 区别：
>
> 1. **--hard**：重置位置的同时，直接将 **working Tree工作目录**、 **index 暂存区**及 **repository** 都重置成目标**Reset**节点的內容,所以效果看起来等同于清空暂存区和工作区。
> 2. **--soft**：重置位置的同时，保留**working Tree工作目录**和**index暂存区**的内容，只让**repository**中的内容和 **reset** 目标节点保持一致，因此原节点和**reset**节点之间的【差异变更集】会放入**index暂存区**中(**Staged files**)。所以效果看起来就是工作目录的内容不变，暂存区原有的内容也不变，只是原节点和**Reset**节点之间的所有差异都会放到暂存区中。
> 3. **--mixed（默认）**：重置位置的同时，只保留**Working Tree工作目录**的內容，但会将 **Index暂存区** 和 **Repository** 中的內容更改和reset目标节点一致，因此原节点和**Reset**节点之间的【差异变更集】都会放入**Working Tree工作目录**中。所以效果看起来就是原节点和**Reset**节点之间的所有差异都会放到工作目录中。



### Git Merge 和 Git Rebase的区别

共同的作用：**都是把不同分支的提交合并到一起**

**Git Merge**

 把源分支的提交放到目标分支里。在这个过程中，只有目标分支改变，而源分支保持原样

**优点**

- 简单易上手
- 保留了提交历史和时间次序
- 保留了分支的结构

**缺点**

- 提交历史被大量的 merge 提交污染了

- 使用 git bisect 调试变得更困难了

  >  git bisect 是通过二分法找到哪一次代码提交引入了错误
  >
  > ```
  > $ git bisect start [终点] [起点]
  > $ git bisect good
  > $ git bisect bad
  > 通过二分不断重复，找到出现问题的那一次提交
  > $ git bisect reset 退出查错，回到最近一次的代码提交
  > ```

如何使用

使用 checkout 和 merge 命令把 master 分支 merge 到 feature 分支。

```text
$ git checkout feature
$ git merge master

(or)

$ git merge master feature
```

这将会在 feature 分支上创建一个新的 “Merge 提交” 用来保留合并记录。



**GitRebase**

变基命令

Rebase 把所有的提交压缩成一个 “patch”。然后把 patch 添加到目标分支里，生成一个新的分支。

和 merging 不同，rebasing 清除了历史，因为它完全是从一个分支转移到了另一个分支。在这个过程中，多余的记录被移除了。

**优点**

- 把复杂的历史变成优雅的提交线
- 操作单个提交变得很简单（比如，reverting）
- 避免了庞大的仓库、海量的分支以及烦人的 merge 提交
- 线性合并清除了中间的无用提交，对于 DevOps 团队来说是个好消息

**缺点**

- Rebase 后 feature 分支间的上下文模糊了
- 在团队里 rebasing 公共分支是高风险的事
- 工作变多了：feature 分支需要经常更新
- Rebasing 到远程分支需要 force push。最大的问题是人们经常已经 force push 了，才发现忘记了设置 git push 默认值。结果本地远程所有同名的分支都进行了更新，清理起来很要命。

使用

下面的命令把 feature 分支 rebase 到 master 分支上。

```text
$ git checkout feature
$ git rebase master
```

它把整个 feature 分支的提交移动到了 master 分支上。通过给每个源(feature) 分支创建了一个 brand 来 re-writing 项目的历史。

> feature1落后master分支的提交，命令把 feature 分支 rebase 到 master 分支上的过程
>
> 首先，`git` 会把 `feature1` 分支里面的每个 `commit` 取消掉；
> 其次，把上面的操作临时保存成 `patch` 文件，存在 `.git/rebase` 目录下；
> 然后，把 `feature1` 分支更新到最新的 `master` 分支；
> 最后，把上面保存的 `patch` 文件应用到 `feature1` 分支上；

> **Interactive Rebasing**
>
> 这个命令可以在移动 commit 前改变它们。这比普通的 rebase 更加强大，它提供了对分支提交历史的完整控制。另外，在合并 feature 分支到 master 前，还可以用它来清理混乱的提交历史。
>
> ```text
> $ git checkout feature
> $ git rebase -i master
> ```
>
> 他会打开编辑器列出将要被移动的提交。
>
> ```text
> pick 22d6d7c Commit message#1
> pick 44e8a9b Commit message#2
> pick 79f1d2h Commit message#3
> ```
>
> 它清晰地展示了分支在 rebase 后的样子。通过重新调整，提交历史可以变成任何你想要的样子。如，可以把 `pick` 换成 `fixup` , `squash` , `edit` 等命令。

Git Rebase保持了合并记录的整洁，但它是一个危险的命令，它改变了历史。如果是多人合作的一个分支，不建议使用Git Rebase，容易出现提交记录不一致的错误。

参考文章：

- https://chinese.freecodecamp.org/news/an-introduction-to-git-merge-and-rebase-what-they-are-and-how-to-use-them/



### 提交时发生冲突，解释下开发中冲突是如何产生的，你是如何解决的

方法一：git pull --rebase 修改冲突 git add . Git rebase --continue git push

方法二：

发生冲突时，我会先保存工作区的修改，将远程仓库中的内容拉到本地，消除冲突，再推上去。

通过一些命令进行解决

1. git stash命令，把工作区的修改提交到栈区，目的是保存工作区的修改
2. git pull命令，拉取远程上的文件合并到本地，目的是消除冲突
3. git stash pop命令，把保存在栈区的修改部分合并到最新的工作区

> 什么时候会使用git stash命令？
>
> - 解决冲突文件时，会先执行git stash，然后解决冲突
> - 遇到紧急开发任务但目前任务不能提交时，会先执行git stash，然后进行紧急任务的开发，然后通过git stash pop取出栈区的内容继续开发
> - 切换分支时，当前工作空间内容不能提交时，会先执行git stash再进行分支切换



### Git的撤销与回滚？

**在git commit之前**

在git commit之前，未添加添加到暂存区的撤销：git checkout -- filename来撤销修改

在git commit之前，已添加到暂存区的撤销：git reset HEAD file

**在git commit之后**

使用git revert + commit id(通过git log 查看记录，用reset也行)

> 还有就是如果想回到之前某个版本，可以用reset命令，可以回退到某次提交，那该提交之后的提交都会回滚，不过这种覆盖是不可逆的，之前的提交记录都没有了(但git revert 不会)。所以平时开发中尽量注意，避免使用reset。
>
> 用法：git  reset --hard  commit_id



### 本地存储相关技术

indexedDB诞生背景：Cookie 的大小不超过4KB，且每次请求都会发送回服务器，LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。

IndexedDB是浏览器提供的本地数据库， 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。

https://segmentfault.com/a/1190000020522975

与本地存储相关的有webStorage webSql和indexedDB，后面两个都是浏览器数据库

与存储数据相关的还有cookie，经常与webStorage技术来比较



### 网页加载慢，如何进行前端的性能优化

答5点

**减少HTTP请求次数**，每次HTTP请求都有成本的，既包含时间成本也包含资源成本。另外浏览器进行并发请求的请求数量是有上限的，请求数增多，浏览器会进行分批次请求。如何实现减少HTTP请求呢？

1. 从设计层面简化页面，保持页面简洁，减少资源是最直接的方法
2. 设置合理的HTTP缓存。对于很少变化的图片资源可以设置很长的过期时间，对于变化不频繁的资源可以使用Last-Modified或者E-tag进行验证，尽可能让资源在缓存中呆的久一点
3. 资源的合并与压缩，尽量把外部脚本、样式进行合并，多个合为一个。响应的图片、视频、JS文件、CSS文件都可以使用相应的工具压缩
4. 使用CSS 精灵图 CSS Sprites，合并CSS请求的图片，是减少请求次数的一个好办法，background-position
5. 使用懒加载图片，这种情况下能减少页面初始化时HTTP请求数，只有在用户向下滚动屏幕时才会再次请求加载
6. 使用更高版本的HTTP，在HTTP2中会采用多路复用，浏览器推送等优化机制

**在渲染页面时的优化**

解析html时，遇到一些链接资源，会单独发起网络请求去下载资源

1. 对于CSS资源，虽然下载时异步，不会阻止浏览器构建DOM树，但是会阻塞渲染，在构建render树时，要等待CSS下载完毕后才执行（这里是浏览器自带的优化，避免了重复构建），但声明了media query的CSS不会阻塞渲染（下方专门针对CSS与渲染页面写了）
2. 对于JS资源，会阻塞浏览器的解析，只有等待脚本下载完并执行后才会继续解析HTML，但加上了async和defer后，脚本就变成异步的了，可以等HTML解析完毕后再执行

> defer和async是有区别的： **defer是延迟执行，而async是异步执行。**但只要是**JS执行，就会暂停HTML解析**
>
> - `async`是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在`load`前，但不确定在`DOMContentLoaded`事件的前或后
> - `defer`是延迟执行，在浏览器看起来的效果像是将脚本放在了`body`后面一样，等待HTML解析完毕后才执行脚本（虽然按规范应该是在`DOMContentLoaded`事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）

合理利用光栅线程和合成线程的机制，这里涉及浏览器相关知识

**通过原生JS的技巧来进行性能优化**

1. 在JS代码解析过程中减少**回流和重绘**，每次回流和重绘会造成额外的计算消耗，通过减少回流和重绘，可以提升页面性能
   1. 最小化重绘和回流，多次修改CSS样式可以改成采用cssText和修改css class；
   2. 批量修改DOM，先让DOM脱离文档流，对其进行多次修改，再将元素带回到文档流中。如隐藏文档，拷贝文档
   3. 使用CSS3硬件加速（GPU加速），让一些动画不会引起回流和重绘
   4. 使用虚拟DOM，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。
2. **事件委托**，通过事件委托减少内存消耗，因为访问的DOM减少了，设置事件处理程序所需时间更少, 加快了整个页面的交互就绪时间，还可以动态绑定事件，减少重复的工作。使用事件委托时注意**非快速滚动区**

**使用CDN加速**，能够使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率，就算一个服务器或者源服务器宕机了，还有其他CDN缓存服务器可以提供资源。

​	如何做到加速的呢？CDN 网站的内容缓存在网络边缘。不同地区的用户就会访问到离自己最近的相同网络线路上的CDN节点。当请求达到CDN节点后，节点会判断自己的内容缓存是否有效，如果有效，则立即响应缓存内容给用户，从而加快响应速度。

​	CDN是在DNS解析的过程中起作用的，当给一个域名开通了CDN，要先给**这个域名的DNS解析设置的后台**添加一条CDN专用的解析记录，这条解析记录会让域名被解析后指向**一个CDN网络专用的处理DNS请求的服务器**，这个CDN专用的处理DNS请求的服务器会给浏览器返回**一台专门用来给各个请求分配合适CDN服务器的服务器的IP**地址，这种服务器叫负载均衡系统服务器。然后浏览器就会去访问这台负载均衡系统浏览器，负载均衡服务器会根据你浏览器的网络地址，在CDN网络中找**一台在各种条件下都比较适合给你设备提供服务的服务器**，将这个服务器的IP返回给你的浏览器，那么浏览器在收到这个IP地址后，就会去访问这台CDN服务器了，去请求文件资源了

> 不同地区的用户会访问到离自己最近的相同网络线路上的CDN节点，当请求达到CDN节点后，节点会判断自己的内容缓存是否有效，如果有效，则立即响应缓存内容给用户，从而加快响应速度。如果CDN节点的缓存失效，它会根据服务配置去**一层一层的向上**获取最新的资源响应给用户，并将内容缓存下来以便响应给后续访问的用户，这就意味着一个地区的用户只需要访问一次服务器，后续的用户都能因此受益。

**预解析DNS**。通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以**尽快地完成 DNS 解析**。

​	通过设置X-DNS-Prefetch-Control头控制浏览器的DNS预解析功能。先在meta信息告诉浏览器开启X-DNS-Prefetch-Control，再在link里面强制对DNS进行预解析

> 浏览器会对 a 标签的 href 自动启用 DNS Prefetching，所以 a 标签里包含的域名不需要在 head 中手动设置 link。但是在 HTTPS 下不起作用，需要 meta 来强制开启功能



### CSS与页面解析

首先

CSS资源是异步下载的

**CSS不会阻塞DOM的解析。**

因为浏览器解析DOM生成DOM树，结合解析CSS生成的CSS树，最终组成渲染树Render Tree，再渲染页面。

由此可见，**CSS会阻塞页面解析**

基于性能与用户体验的考虑，浏览器会尽量减少渲染的次数，因为`CSS`顺理成章地阻塞页面渲染。

但声明了媒体查询Media Query的CSS不会阻塞渲染

> 如果没有这个策略，页面首先会呈现出一个原始的模样，待`CSS`下载完之后又突然变了一个模样。用户体验可谓极差
>
> 而且渲染是有成本的

但是

**在一些特殊的场景下，CSS会“阻塞”DOM的解析**：

当CSS阻塞了JS时，而JS就会阻塞DOM的解析。如果脚本的内容是获取元素的样式，宽高等`CSS`控制的属性，浏览器是需要计算的，也就是依赖于`CSS`。浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，再执行`JS`。

所以script与link同时在头部的话，script在上可能会更好，不会被未知的样式所阻塞（遇到获取样式，没有就略过，可能）。之所以是可能，是因为如果link的内容下载更快的话，是没影响的，但反过来的话，JS就要等待了，然而这些等待的时间是完全不必要的。





### 什么是负载均衡

负载均衡是一种策略，将外部发来的请求均匀分配到某一台服务器中，接收到请求的服务器独立地回应客户的请求

优点：

1. 解决网络拥塞问题，服务就近提供，实现地理位置无关性；
2. 为用户提供更好的访问质量；
3. 提高服务器响应速度；
4. 提高服务器及其他资源的利用效率。

常见的软件负载均衡技术有：

1. 基于DNS的负载均衡
2. 反向代理负载均衡
3. 基于NAT的负载均衡

> Nginx的负载均衡常用算法
>
> 1. 轮询
> 2. 加权轮询
> 3. IP哈希
> 4. URL_hash



### Cookie与Session的区别：

1. Cookie与Session都是会话技术（跟踪会话），Cookie保存在客户端上，Session保存在服务器端上，当服务器访问量增多，Session会比较占服务器的性能
2. Cookie有大小限制（3K）以及浏览器存在的Cookie的个数也有限制；理论上来说Session是没有大小限制的，Session大小与服务器内存大小有关
3. Cookie存在安全隐患，通过拦截或本地文件能找到受害者的cookie并利用攻击，所以重要的用户数据存储在session中，cookie可以存储其他数据
4. 若未设置过期时间，cookie的生命周期为浏览器会话时间，若设置了有效期的cookie不会随着浏览器的关闭而消失，而是到了有效期才会消失。Session的默认有效期是30min，服务器可以自己配置。

> 存储的位置
>
> cookie：设置了失效时间的话，存在本地；如果没有设置，就存在浏览器里，可以在设置里面找到存储的cookie
>
> localStorage：每个浏览器都会把localStorage存储在自己的UserData中

详细理解cookie和session https://www.cnblogs.com/andy-zhou/p/5360107.html



### 如何提高cookie的安全性

1. 对存入cookie里的敏感信息必须加密

2. 设置HttpOnly为true。

   1、该属性值的作用就是防止Cookie值被页面脚本读取。

   2、但是设置HttpOnly属性，HttpOnly属性只是增加了攻击者的难度，Cookie盗窃的威胁并没有彻底消除，因为cookie还是有可能传递的过程中被监听捕获后信息泄漏。

3. 设置Secure为true

   1、给Cookie设置该属性时，只有在https协议下访问的时候，浏览器才会发送该Cookie。

   2、把cookie设置为secure:true，只保证cookie与WEB服务器之间的数据传输过程加密，而保存在本地的cookie文件并不加密。如果想让本地cookie也加密，得自己加密数据。

   > secure和httonly都是cookie的属性

4. 给cookie设置有效期

   1、如果不设置有效期，万一中间人获取到用户的Cookie后，就可以一直使用用户身份登录。

   2、在设置Cookie认证的时候，需要加入两个时间，一个是“即使一直在活动，也要失效”的时间，一个是“长时间不活动的失效时间”，并在Web应用中，首先判断两个时间是否已超时，再执行其他操作。



### 关于Token

token的意思是“令牌”，是服务器生成的一串字符串，**作为客户端进行请求的一个标识**

> 当用户第一次登录后，服务器生成了一个token并返回这个token给客户端，客户端之后只需要带上这个token前来请求数据即可，无需再带上用户名和密码
>
> 简单的token的组成：
>
> uid（用户唯一的身份标识符），time（当前时间的时间戳），sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串，为防止token泄露） 存疑 不如看下面的token原理

为什么要使用token？

- Token是无状态、可扩展的，可以在多个服务器之间共享
- Token完全由应用管理，所以它可以避开同源策略
- Token可以避免CSRF攻击

因为http协议是无状态的，为了区别每个用户的信息，现在一般网页用户登录使用Token机制进行区别，如果使用session辨别用户，当用户数量过大时，这是对服务器巨大的开销，而且严重限制了服务器的扩展能力。所以使用token让用户自己存储，每次请求携带，服务器通过Hash算法和密钥进行解析判断，这样服务器的资源开销减小了，也更容易进行扩展。

**token原理**

　　1.将荷载payload，以及Header信息进行**Base64加密**，形成payload密文，header密文。

　　2.将形成的密文用句号链接起来，用服务端**秘钥**进行**HS256加密**，生成签名.

　　3.将前面的两个密文后面用句号链接签名形成最终的token返回给客户端

注：

　　（1）用户请求时携带此token(分为三部分，header密文，payload密文，签名)到服务端，服务端解析第一部分(header密文)，用Base64解密，可以知道用了什么算法进行签名，此处解析发现是**HS256**。

　　（2）服务端使用原来的秘钥与密文(header密文+"."+payload密文)同样进行HS256运算，然后用生成的签名与token携带的签名进行对比，若一致说明token合法，不一致说明原文被修改。

　　（3）判断是否过期，客户端通过用**Base64**解密第二部分（payload密文），**可以知道荷载中授权时间，以及有效期。通过这个与当前时间对比发现token是否过期**。



token一般存储在localstorage，sessionstorage，cookie

**Storage**

Web存储（localStorage/sessionStorage）可以通过同一域商Javascript访问。这意味着任何在你的网站上的运行的JavaScript都可以访问Web存储，所以容易受到XSS攻击。尤其是项目中用到了很多第三方JavaScript类库。

为了防止XSS，一般的处理是避开和编码所有不可信的数据。但这并不能百分百防止XSS。比如我们使用托管在CDN或者其它一些公共的JavaScript库，还有像npm这样的包管理器导入别人的代码到我们的应用程序中。

如果你使用的脚本中有一个被盗用了怎么办？恶意的JavaScript可以嵌入到页面上，并且Web存储被盗用。这些类型的XSS攻击可以得到每个人的Web存储来访问你的网站。

这也是为什么许多组织建议不要在Web存储中存储任何有价值或信任任何Web存储中的信息。 这包括会话标识符和令牌。作为一种存储机制，Web存储在传输过程中不强制执行任何安全标准。

Cookie

**优点：**

- 可以制定httponly，来防止被JavaScript读取，也可以制定secure，来保证token只在HTTPS下传输。

**缺点：**

- 不符合Restful 最佳实践。 [Restful最佳实践](https://juejin.cn/post/6844903941403049998)

- 容易遭受CSRF攻击（可以在服务器端检查Refer和Origin）

  

**关于token 存在cookie还是localStorage有两个观点**。

- 支持Cookie的开发人员会强烈建议不要将敏感信息（例如JWT)存储在localStorage中，因为它对于XSS毫无抵抗力。
- 支持localStorage的一派则认为：撇开localStorage的各种优点不谈，如果做好适当的XSS防护，收益是远大于风险的。

放在cookie中看似看全，看似“解决”（因为仍然存在XSS的问题）一个问题，却引入了另一个问题（CSRF）

localStorage具有更灵活，更大空间（最大一般是5M），天然免疫 CSRF的特征。Cookie空间有限（不同浏览器不一样，空间最大似乎是4kb），而JWT一般都占用较多字节，而且有时你不止需要存储一个JWT。（[JWT登录鉴权：避免在用户操作的过程中JWT到期跳转登录](https://segmentfault.com/a/1190000040765719)）


- [JSON Web Token 入门教程](https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)
- [Token一般存放在哪里?](https://juejin.cn/post/6922782392390746125)





### HTML文档里head标签中有哪些常见的标签？

每一个HTML文档中都必须有head标签，它作为一个容器，主要包含了用于描述HTML文件的自身信息（元数据）的标签。

这些标签一般不会展现给用户，而是提供信息给浏览器和搜索引擎

一般用到head标签里的标签有：`<title>` , `<base>` , `<link>` , `<style>` , `<meta>` , `<script>` , `<noscript>` 。这些标签也称为元信息标签

\<title>

定义文档的标题，一般会显示在浏览器的标题栏或标签页上，一般会完整地概括整个网页的内容

\<base>

给页面上所有相对 URL 的提供一个基础。一份文档中只能有一个 `<base>` 标签。

\<link>

规定外部资源与当前文档的关系，常用于链接样式表，也有其他作用

```html
<!-- 引入样式 -->
<link rel="stylesheet" href="xxx.css" type="text/css" >
<!-- SEO 搜索引擎优化 主要是给搜索引擎看的 在网站中常有多个 url 指向同一个页面的情况，下面的标签告知搜索引擎页面的主 url 是什么，以便搜索引擎保留主要页面而去除其他重复页面。-->
<link rel="canonical" href="..." >
<!-- 提供RSS订阅的 标签除搜索引擎可以看懂以外，也能被很多浏览器插件识别。-->
<link rel="alternate" type="application/rss+xml" title="RSS" href="...">
<!-- 表示页面icon的 -->
<link rel="icon" href="https://xxx.png">
<!-- 对页面进行预处理的 提前对一个域名做 dns 查询。强制对域名进行预读取在有的情况下很有用。
比如, 在网站的主页上，强制在整个网站上对频繁引用的域名做预解析处理，即使它们不在主页本身上使用。虽然主页的性能可能不受影响，但是会提高站点整体性能。-->
<link rel="dns-prefetch" href="//xxx.com">
```

> “SEO（Search Engine Optimization）：汉译为搜索引擎优化。是一种方式：**利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是让其在行业内占据领先地位，获得品牌收益**。很大程度上是网站经营者的一种商业行为，将自己或自己公司的排名前移。”

\<style>

包含了文档的样式信息

\<meta>

一种通用的元数据信息表示标签，一般以键值对出现，如：`<meta name="xxx" content="yyy">`

```html
<!-- charset 属性 从 HTML5 开始，上述写法被推荐使用，用于声明当前文档所使用的字符编码，推荐放在 <head> 中的第一位。-->
<meta charset="utf-8">
<!-- 在 HTML4 中，上述代码用于声明字符集，但是现在已不被推荐。-->
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!-- name属性-->
<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no">
其实 <meta> 标签可以被自由定义，只要读取和写入的双方约定好 name 和 content 的格式就可以了。
上面这种用法并不在 HTML 标准中，但是却移动端开发的事实标准。这里来解释一下 content 中的内容：

width ：页面宽度，可以是一个正整数；也可以一个字符串 "device-width" ，表示跟设备宽度相等。
height ：页面高度，可以是一个正整数；也可以一个字符串 "device-height" ，表示跟设备高度相等。
initial-scale ：初始缩放比例。
minimum-scale ： 最小缩放比例。
maximum-scale ： 最大缩放比例。
user-scalable ：是否允许用户缩放。
name 属性的值除了可以是 viewport 之外，还有相当多的值：

application-name 、author 、description 、generator 、keywords 、referrer 、robots 等。
```

\<script>

用于嵌入或引用可执行脚本。来看几个 script 标签常见的全局属性：

- async

  使浏览器使用另一个线程下载脚本，这时不会阻塞页面渲染。当脚本下载完成后，浏览器会暂停渲染，执行脚本，执行完毕后继续渲染页面。

  async 无法保证脚本的执行顺序，哪个脚本先下载结束就会先执行。

- defer

  同样会使浏览器并行下载脚本，但是下载完毕不会立即执行，而是会等到 DOM 加载完成后（即刚刚读取完 `</html>` 标签）再执行脚本。

  defer 可以保证脚本的执行顺序就是它们在页面上出现的顺序。

- src

  定义引用外部脚本的地址，指定此属性的 script 标签内不应再有嵌入的脚本。**如果脚本文件使用了非英语字符，还应该注明字符的编码。**如：

  ```xml
  <script charset="utf-8" src="https://www.example.com/script.js"></script>
  ```

- type

  默认值是 text/javascript

\<noscript>

如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在此中定义**脚本未被执行时的替代内容**。



以上只是简单的介绍，很多相关标签都是有特殊需求，在特殊的情况下使用。

参考文章：

1. [head 标签里有什么？](https://segmentfault.com/a/1190000018592638) 





### HTTP1.0 1.1 2

**HTTP/1.1相比HTTP/1.0性能上的改进：**

1. 长连接(Persistent Connection)： HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。
2. 节约带宽：HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。
3. HOST域：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。
4. 缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
5. 错误通知的管理： 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
6. 支持管道(pipeline)网络传输，只要第一个请求发送出去了，**不必等其回来**，就可以发第二个请求出去，可以减少整体的响应时间

HTTP/1.1的**性能瓶颈**

- 请求/响应头**未经过压缩就发送**，首部信息越多延迟越大。只能压缩body部分
- **发送冗长的首部。**每次互相发送相同的首部造成的浪费较多
- 服务器是按请求的顺序响应的，如果服务器响应不到数据，会导致客户端一直请求不到数据，也就是**队头阻塞**
- **没有请求的优先级控制**
- **请求只能从客户端开始，服务器只能被动响应**



**HTTP2基于HTTP1.1的优化**：

HTTP2协议是基于HTTPS的，所以HTTP2的安全性是有保证的。

1. 多路复用：HTTP/2**是在一个连接中并发多个请求或回应，而不用按照顺序一一对应**。移除了HTTP/1.1中串行请求，不需要排队等待，也不会出现队头阻塞问题，降低了延迟，大幅度提高了连接的利用率。

2. 头部数据压缩：HTTP1.1不支持header数据的压缩，HTTP2.0使用**HPACK算法**对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。

   > 如果你同时发送多个请求，它们的头是一样或者相似的，那么协议会帮你**消除重复的部分**。
   >
   > HPACK算法：在客户端和服务器同时维护一张头信息表，所有的字段都会存入这张表，生成一个索引号，以后就不发同样的字段了，**只发索引号**，这样就提高速度了

3. 服务器推送：**服务端推送是一种在客户端请求之前发送数据的机制**。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。**因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的**。为了改善延迟，HTTP2引入了**server push**，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。

4. 二进制协议：HTTP2不再像HTTP/1.1里的纯文本形式的报文，而是全面采用了**二进制模式**，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。虽然这样对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，**无需再将明文的报文转成二进制，而是直接解析二进制报文，这样增加了数据传输的效率**

5. 数据流：HTTP/2的数据包不是按顺序发送的，同一个连接里面连续的数据包，**可能属于不同的回应**。因此必须要对每个数据包做标记，指出它属于哪个回应。所以每个请求或者回应的所有的数据包，被称为一个**数据流**，每个数据流都有独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。**客户端还能指定数据流的优先级。优先级高的请求，服务器就先响应**。



### HTTP/2有哪些缺陷？HTTP/3做了哪些优化？

HTTP/2的主要问题在于，**多个HTTP请求在复用一个TCP连接**，下层的TCP协议是不知道有多少个HTTP请求的。如果**一旦发生了丢包现象**，就会触发TCP的重传机制，这样在一个TCP连接中的**所有的HTTP请求都必须等待这个丢了的包被重传回来**。

- HTTP/1.1中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了
- HTTP/2多个请求复用一个TCP连接，一旦发生丢包，就会阻塞所有的HTTP请求

**优化**

这是基于传输层的问题，所以**HTTP/3把HTTP下层的TCP协议改成了UDP协议！！！**

因为UDP发送不管顺序，也不管丢包的，所以不会出现上述的阻塞问题

虽然UDP是不可靠传输，但基于UDP的**QUIC协议**可以实现类似TCP的可靠性传输

- QUIC有自己的一套机制可以保证传输的可靠性。当某个流发生丢失时，只会阻塞这个流，**不会影响其他流**
- TLS3**升级成了最新的1.3版本**，头部压缩算法**也升级成了QPack**
- HTTPS要建立一次连接，要花费六次交互，先是建立三次握手，然后是TLS/1.3的三次握手。QUIC直接把以前的六次交互合并成了3次，减少了交互次数

> QUIC是一个新协议，是一个在UDP之上的伪TCP+TLS+HTTP/2的多路复用的协议
>
> 对于很多网络设备来说，根本不知道什么是QUIC，只会被当做UDP来处理，所以现在HTTP/3的普及进度非常慢



### HTTP请求的方法有哪些

HTTP/1.0定义了三种请求方法：GET，POST和HEAD方法

HTTP/1.1新增了五种请求方法: OPTIONS,PUT,DELETE,TRACE和CONNECT方法

- GET: **请求指定的页面信息**，并返回实体主体
- HEAD: 类似于get请求，只不过返回的响应中**没有具体的内容**，只用于获取报头
- POST: **向指定资源提交数据进行处理请求**（如表单提交和上传文件）数据被包含在请求体中。POST请求可能会导致新的资源建立或修改已有的资源
- PUT: 从客户端向服务器传送的数据**取代指定文档的内容**
- DELETE: 请求服务器**删除指定页面**
- CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器？
- OPTIONS: 允许客户端**查看服务器性能**，了解**请求的资源在请求/响应过程中可以使用的功能选项，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施**，
- TRACE: **回显服务器收到的请求，主要用于测试或诊断**

> 注意：
> 1）**方法名称是区分大小写的**，当**某个请求所针对的资源**不支持对应的请求方法的时候，服务器应当返回状态码405（Mothod Not Allowed）；当**服务器**不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented）
> 2）HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持**扩展自定义的方法**。



### Get和Post的区别

Get和Post实质上没有区别，只是报文格式的不同。

Get和Post只是HTTP协议中两种请求方式，而HTTP协议是基于TCP/IP的关于数据如何在网络上通信的协议。

所以GET和Post的底层也是TCP/IP，能做的事是一样的，要给Get加上request body或者要给post带上url参数，技术上是可以实现的（服务端要能处理）。**HTTP只是个行为准则，规定了Get，Post的语法，而TCP才是GET和POST怎么实现的基本**。

> 注意：
>
> 有些说法说的是Get只产生一个TCP数据包，而Post要产生两个数据包。对于get请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于post，浏览器会先发送header，服务器响应100 continue，浏览器才会再次发送data，服务器响应200
>
> 但是不是说post性能就比get差，在网络好的情况下，一次与两次的区别并不大，而网络不好的情况下，两次TCP都会验证数据完整性，是个非常大的优点。而且不是所有的浏览器都会分开发送，比如firefox chrome就不会，这不是post的必然行为
>
> 注意：
>
> Get方法参数写法不是固定的，在?后面写&只是约定中的写法。服务端解析TCP报文，用正则等工具获取Header和Body，从里面获取参数，所以我们可以自定义约定参数的写法

所以Get和Post的区别要么是http协议规定的，要么是浏览器、服务器约束的：

- Get的请求在参数在URL上，而Post在Request Body上，所以Get不能用来传递敏感信息（但实际上都不是安全的）
- Get的请求参数有长度限制，而Post的没有（这是个错误的说法，Get和Post都没有限制，只是浏览器有限制）
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
- Get在回退时是无害的，而Post会再次提交请求
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

.....等等 之类的（后面可答可不答）

- GET产生的URL地址可以被Bookmark，而POST不可以
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。



GET和POST方法都是安全和幂等的吗？

- 在HTTP协议里，所谓的`安全`是指请求方法不会`破坏`服务器上的资源
- 所谓的`幂等`，意思就是**多次执行相同的操作，结果都是相同的**

很明显**GET**方法就是**安全且幂等**的，只是因为它是只读操作，无论操作多次，服务器上的数据都是安全的，且每次结果都是相同的

POST因为是**新增或是提交数据**的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以是不幂等的 



### Http请求发生两次及OPTIONS请求

https://www.cnblogs.com/mamimi/p/10602722.html#3053162651

自后台restful接口流行开来，请求了两次的情况（options请求）越来越普遍。为什么会先发一次OPTIONS请求？

options请求的官方定义：OPTIONS方法是用于**请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项**。通过这个方法，**客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能**。

用白话说就是：在发生正式的请求之前，先进行一次**预检请求。看服务端返回一些信息，浏览器拿到之后，看后台是否允许进行访问。**

**产生OPTIONS请求的原因**：

**1：产生了复杂请求**。复杂请求对应的就是简单请求。

​	简单请求的定义是：

1.  请求方法是GET、HEAD或者POST，并且当请求方法是POST时，Content-Type必须是application/x-www-form-urlencoded, multipart/form-data或着text/plain中的一个值。
2.  请求中没有自定义HTTP头部。

所谓的自定义头部，在实际的项目里，我们经常会遇到需要在header头部加上一些token或者其他的用户信息，用来做用户信息的校验。

**2：发生了跨域。**

**options请求有什么作用**

官方将头部带自定义信息的请求方式称为**带预检（preflighted）的跨域请求**。在实际调用接口之前，会首先发出一个options请求，检测服务端是否支持真实的请求进行跨域的请求。真实请求在options请求中，通过request-header将 Access-Control-Request-Headers与Access-Control-Request-Method发送给后台，另外浏览器会自行加上一个Origin请求地址。服务端在接收到预检请求后，根据资源权限配置，在response-header头部加入access-control-allow-headers（允许跨域请求的请求头）、access-control-allow-methods（允许跨域请求的请求方式）、access-control-allow-origin（允许跨域请求的域）。另外，服务端还可以通过Access-Control-Max-Age来设置一定时间内无须再进行预检请求，直接用之前的预检请求的协商结果即可。浏览器再根据服务端返回的信息，进行决定是否再进行真实的跨域请求。这个过程对于用户来说，也是透明的。

另外在HTTP响应头，凡是浏览器请求中携带了身份信息，而响应头中没有返回Access-Control-Allow-Credentials: true的，浏览器都会忽略此次响应。

总结：**只要是带自定义header的跨域请求，在发送真实请求前都会先发送OPTIONS请求，浏览器根据OPTIONS请求返回的结果来决定是否继续发送真实的请求进行跨域资源访问。所以复杂请求肯定会两次请求服务端。**



### 什么是DOM？

DOM（文档对象模型）是HTML和XML文档的编程接口，它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。

一个Web页面就是一个文档



### DOM事件监听和观察者模式有什么不同？（发布订阅模式和观察者模式有什么不同）

DOM事件监听，其实就是“发布订阅者模式”的应用。（再去详细去了解）

添加事件（回调函数）-> 触发点击，事件中心派发指定事件->执行事件。

**发布订阅模式和观察者模式有什么不同？**

首先，观察者是经典软件`设计模式`中的一种，但发布订阅只是软件架构中的一种`消息范式`。

其次，就是实现二者所需的角色数量有着明显的区别。观察者模式本身只需要`2个`角色便可成型，即`观察者`和`被观察者`，其中`被观察者`是重点。而发布订阅需要至少`3个`角色来组成，包括`发布者`、`订阅者`和`发布订阅中心`，其中`发布订阅中心`是重点。

详细介绍：[理解【观察者模式】和【发布订阅】的区别](https://juejin.cn/post/6978728619782701087)



### 详解一下Event Loop事件循环工作机制

首先我们说JS是个单线程的语言，在浏览器的单个Tab页，也就是单个**浏览器渲染进程**中**JS引擎线程**只有一个。

然后JS的代码分为**同步任务**和**异步任务**，同步任务都在主线程（JS引擎线程）上，形成一个**执行栈**。

主线程之外，**事件触发线程**管理着**任务队列**，只要异步任务有了结果，就在**任务队列**之中放置该事件。

而任务队列分为**宏队列**（macrotasks）和**微队列**（microtasks），微任务优先级高于宏任务。

> 异步任务分为宏任务和微任务

所以

首先执行栈中执行一个宏任务（如果没有就去宏任务队列（事件队列？）中获取）

执行过程中，遇到微任务就添加到微任务队列，遇到宏任务就添加到宏任务队列

执行栈中的任务执行完成后，立即开始执行微任务队列中所有的微任务（调入执行栈中执行）

如果执行完微任务队列后又新增了微任务，那么再一次执行微任务

执行完毕后，开始检查渲染，由GUI线程接管渲染

渲染完毕后，JS引擎线程接管，从宏任务队列中取出下一个宏任务，然后开始执行，没有就开始休眠

以上就是Event Loop事件循环机制

> 有哪些任务会放在microtasks，有哪些会放在macrotasks呢？
>
> - microtasks
>   - process.nextTick
>   - promise
>   - Object.observe (废弃)
>   - MutationObserver（用于监听DOM树结构变化的事件，与Mutation Events不一样）
> - macrotasks
>   - 主代码块
>   - setTimeout
>   - setImmediate
>   - setInterval
>   - I/O
>   - UI 渲染
>
> 上述的事件循环的核心是：JS引擎线程和事件触发线程
>
> 然而还会用到一个线程，定时器触发线程。
>
> 什么时候会用到定时器线程？当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。
>
> 注意，是当读到定时器代码后，定时器线程就开始计时推入，而不是说执行栈执行完了之后才开始计时。
>
> 
>
> 理解Process.nextTick
>
> https://www.jianshu.com/p/deb8bc589377
>
> **process.nextTick 中的回调函数是在当前tick执行完之后，下一个宏任务执行之前调用的。比setTimeOut(fn,0)快得多**
>
> 在事件循环中，**每进行一次循环操作称为tick**



### 为什么Javascript需要事件循环

因为JS是单线程语言，直白来说就是一个时间点下JS引擎只能去做一件事情，而Java这种多线程语言，可以同时做几件事情。

JS做的任务分为同步和异步两种，所谓 "异步"，简单说就是一个任务不是连续完成的，先执行第一段，等做好了准备，再回过头执行第二段，第二段也被叫做回调；同步则是连贯完成的。

像读取文件、网络请求这种任务属于异步任务：花费时间很长，但中间的操作不需要JS引擎自己完成，它只用等别人准备好了，把数据给他，他再继续执行回调部分。

如果没有特殊处理，JS引擎在执行异步任务时，应该是存在等待的，不去做任何其他事情。如果没有事件循环，在执行异步任务时有大量的空闲时间被浪费（可以涉及CPU，I/O事件来说明）。实际上这是大多数多线程语言的处理办法。但对于JS这种单线程语言来说，这种长时间的空闲等待是不可接受的：遇到其他紧急任务，Java可以再开一个线程去处理，JS却只能忙等。

所以采取了“异步任务回调通知”模式，在等待异步任务准备的同时，JS引擎去执行其他同步任务，等到异步任务准备好了，再去执行回调。这种模式的优势显而易见，完成相同的任务，花费的时间大大减少，这种方式也被叫做非阻塞式。

而实现这个“通知”的，正是事件循环，把异步任务的回调部分交给事件循环，等时机合适交还给JS线程执行。事件循环并不是JavaScript首创的，它是计算机的一种运行机制。





### 为什么异步任务会分为宏任务和微任务

事件循环中的任务被分为宏任务和微任务，**是为了给高优先级任务一个插队的机会：微任务比宏任务有更高优先级。**

完成当下的宏任务后，会立刻执行所有在此期间入队的微任务。

这种设计是为了给紧急任务一个插队的机会，否则新入队的任务永远被放在队尾。区分了微任务和宏任务后，本轮循环中的微任务实际上就是在插队，这样微任务中所做的状态修改，在下一轮事件循环中也能得到同步。



### 为什么JavaScript是单线程语言

因为JS作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM，如果JavaScript同时有多个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器不能确定以哪个线程为准，会增加编程复杂性。



### Node中的事件循环

Node的事件循环是由**libuv**提供的，libuv是Node另外一个重要的基石。

libuv引擎中的事件循环分为6个阶段，会按照顺序反复运行。

每当进入某一个阶段的时候，都会从每个阶段对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设置的阈值时，就进入下一个阶段。

六个阶段分别是

- timers阶段：执行setTimeout,setInterval的回调
- I/O callbacks阶段：处理一些上一轮循环中的少数未执行的I/O回调
- idle,prepare阶段：仅供node内部使用
- poll阶段：获取新的I/O事件，适当条件下node将阻塞在这
- check阶段：node专门处理setImmediate的回调
- close callbacks阶段：执行socket的close事件回调

平时我们学习最主要的就是timers,poll和check这三个阶段

而在node中，微任务是不在事件循环阶段中的，node只有process.nextTick和Promise callbacks两个微任务，都有各自的队列，不属于事件循环的一部分。nextTick的优先级比promise要高。

**timers**:

timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，**在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行**。

**poll**:

取出新完成的 `I/O` 事件；执行与 `I/O` 相关的回调（除了关闭回调，计时器调度的回调和 `setImmediate` 之外，几乎所有这些回调） 适当时，`node` 将在此处阻塞。

poll是一个至关重要的阶段，这一阶段中

poll阶段有两个主要的功能：一是执行下限时间已经达到的timers的回调，一是处理poll队列里的事件。



当事件循环进入poll阶段：

- `poll`队列不为空的时候，事件循环肯定是先遍历队列并同步执行回调，直到队列清空或执行回调数达到系统上限。
- `poll`队列为空的时候，这里有两种情况。
  - 如果代码已经被`setImmediate()`设定了回调，那么事件循环直接结束`poll`阶段进入`check`阶段来执行`check`队列里的回调。
  - 如果代码没有被设定`setImmediate()`设定回调：
    - 如果有被设定的timers，那么此时事件循环会检查timers，如果有一个或多个timers下限时间已经到达，那么事件循环将绕回timers阶段，并执行timers的有效回调队列。
    - 如果没有被设定timers，这个时候事件循环是**阻塞**在poll阶段等待事件回调被加入poll队列。

Poll阶段，当js层代码注册的事件回调都没有返回的时候，事件循环会暂时阻塞在poll阶段，解除阻塞的条件：

> 1. 在poll阶段执行的时候，会传入一个timeout超时时间，该超时时间就是poll阶段的最大阻塞时间。
> 2. timeout时间未到的时候，如果有事件返回，就执行该事件注册的回调函数。timeout超时时间到了，则退出poll阶段，执行下一个阶段。
>
> 这个 timeout 设置为多少合适呢? 答案就是 Timer Phase 中最近要执行的回调启动时间到现在的差值, 假设这个差值是 detal. 因为 Poll Phase 后面没有等待执行的回调了. 所以这里最多等待 delta 时长, 如果期间有事件唤醒了消息循环, 那么就继续下一个 Phase 的工作; 如果期间什么都没发生, 那么到了 timeout 后, 消息循环依然要进入后面的 Phase, 让下一个迭代的 Timer Phase 也能够得到执行.
> Nodejs 就是通过 Poll Phase, 对 IO 事件的等待和内核异步事件的到达来驱动整个消息循环的.
>
> 消息循环也就是事件循环

**check**:
这个阶段只用来处理setImmediate的回调函数

> 在node11版本之前微任务的执行和11版本微任务的执行是不一样的，具体看下方解释

**Nodejs执行JS代码过程及事件循环过程**

- 1、node初始化

  - 初始化node环境
  - 执行输入的代码，执行**同步代码，把各个回调函数放入各个阶段的回调队列中**
  - 执行`process.nextTick`回调
  - 执行微任务(microtasks)

- 2、进入事件循环

  - 2.1、进入`Timer`阶段

    - 检查`Timer`队列是否有到期的`Timer`的回调，如果有，将到期的所有`Timer`回调按照`TimerId`升序执行
    - 检查是否有`process.nextTick`任务，如果有，全部执行
    - 检查是否有微任务(promise)，如果有，全部执行
    - 退出该阶段

  - 2.2、进入`Pending I/O Callback`阶段

    - 检查是否有`Pending I/O Callback`的回调，如果有，执行回调。**如果没有退出该阶段**
    - 检查是否有`process.nextTick`任务，如果有，全部执行
    - 检查是否有微任务(promise)，如果有，全部执行
    - 退出该阶段

  - 2.3、进入idle，prepare阶段

    这个阶段与JavaScript关系不大，略过

  - 2.4、进入`Poll`阶段

    - 首先检查是否存在尚未完成的回调，如果存在，分如下两种情况：
      - 第一种情况：有可执行的回调
        - 执行所有可用回调(包含到期的定时器还有一些IO事件等)
        - 检查是否有`process.nextTick`任务，如果有，全部执行
        - 检查是否有微任务(promise)，如果有，全部执行
        - 退出该阶段
      - 第二种情况：没有可执行的回调
        - 检查是否有`immediate`回调，如果有，退出Poll阶段。如果没有，阻塞在此阶段，等待新的事件通知，有限时

  - 2.5、进入`check`阶段

    - 如果有immediate回调，则执行所有immediate回调
    - 检查是否有`process.nextTick`任务，如果有，全部执行
    - 检查是否有微任务(promise)，如果有，全部执行
    - 退出该阶段

  - 2.6、进入`closing`阶段

    - 如果有immediate回调，则执行所有immediate回调？
    - 检查是否有`process.nextTick`任务，如果有，全部执行
    - 检查是否有微任务(promise)，如果有，全部执行
    - 退出该阶段

- 3、检查是否有活跃的`handles(定时器、IO等事件句柄)`

  - 如果有，继续下一轮事件循环
  - 如果没有，结束事件循环，退出程序

**注意：**

事件循环的每一个子阶段退出之前都会按顺序执行如下过程：

- 检查是否有 process.nextTick 回调，如果有，全部执行。
- 检查是否有 微任务(promise)，如果有，全部执行。

随着Node v11版本的发布，一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这样就和浏览器的事件循环保持了一致，而Node v11版本之前只有阶段结束后才执行微任务队列

关于poll阶段还有些许疑问，后续要继续学习

阅读的几篇博客及原文：

https://juejin.cn/post/6844903761949753352#heading-0

https://juejin.cn/post/6844904137662922760#heading-0

https://segmentfault.com/a/1190000018730085



### JavaScript的类型

JS的类型分为两种

- 原始数据类型：布尔值，数值，字符串，null，undefined和新类型Symbol,BigInt
- 对象类型

**null和undefined的区别**

两个都是表示“无”的值。

区别：

Number转换的值不同，Number(null)输出为0, Number(undefined)输出为NaN

**null表示“没有对象”，即该处不应该有值。**

- 作为函数的参数，表示函数的参数不是对象
- 作为对象原型链的终点 （Object.getPrototypeOf(Object.prototype)）
- 定义一个值为null是合理的，但定义为undefined不合理（var name = null）

而**undefined表示“缺少值”，就是此处应该有一个值，但是还没有定义**

- 变量被声明了还没有赋值，就为undefined
- 调用函数时应该提供的参数还没有提供，该参数就等于undefined
- 对象没有赋值的属性，该属性的值就等于undefined
- 函数没有返回值，默认返回undefined



### JavaScript Number的范围

**所有 JavaScript 数字均为 64 位**

JavaScript 不是类型语言。与许多其他编程语言不同，JavaScript 不定义不同类型的数字，比如整数、短、长、浮点等等。

在JavaScript中，数字不分为整数类型和浮点型类型，所有的数字都是由 浮点型类型。JavaScript 采用 IEEE754 标准定义的 64 位浮点格式表示数字，它能表示最大值（Number.MAX_VALUE）为 **±1.7976931348623157e+308**，最小值（Number.MIN_VALUE）为 **±5e-324**。

此格式用 64 位存储数值，其中 0 到 51 存储数字（片段），52 到 62 存储指数，63 位存储符号

但是精度上来看，整数（不使用小数点或指数计数法）最多为 15 位，小数的最大位数是 17，但是浮点运算并不总是 100% 准确。

**八进制和十六进制**

如果前缀为 0，则 JavaScript 会把数值常量解释为八进制数，如果前缀为 0 和 "x"，则解释为十六进制数。

`Number.MAX_SAFE_INTEGER` 常数给出了可以安全递增的最大可能整数。是Math.pow(2,53) - 1(下面记为safemax);

safemax + 1是准确的，而safemax + 2是不准确的

**BigInt的出现**

**`BigInt`** 是一种内置对象，它提供了一种方法来表示大于 `2^53 - 1` 的整数。这原本是 Javascript中可以用 [`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 表示的最大数字。**`BigInt`** 可以表示**任意大的整数**。

可以用在一个整数字面量后面加 `n` 的方式定义一个 `BigInt` ，如：`10n`，或者调用函数 `BigInt()`（但不包含 `new` 运算符）并传递一个整数值或字符串值。

它在某些方面类似于 [`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) ，但是也有几个关键的不同点：不能用于 [`Math`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math) 对象中的方法；不能和任何 [`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为 `BigInt` 变量在转换成 [`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 变量时可能会丢失精度。

`BigInt` 可以成为实现 `BigDecimal` 的基础。



### JavaScript中的顶层对象和全局变量

顶层对象，在浏览器环境指的是**window**对象，在Node指的是**global**对象。

ES5之前，顶层对象和全局变量是等价的，此被称为JavaScript设计的最大的败笔之一。

ES6之后，顶层对象和全局变量将逐渐脱钩。ES6为了改变这一点，又为了保持兼容性

- 一方面，var、function命令声明的全局变量，依旧是顶层对象的属性
- 另一方面，let、const、class命令声明的全局变量，不属于顶层对象的属性

> ES5中顶层对象和全局变量是等价的，全局变量对编程者来说造成了很大的麻烦，因为一个疏忽就把变量泄露到了全局，全局变量的属性到处都是可读可写的，非常不流于模块化编程
>
> 全局变量是window对象（浏览器中的顶层对象）的属性。顶层对象不是任何对象的属性，所以它没有名称。顶层对象在浏览器环境中是指window,在node环境中是指global。



**JS中的错误类型有**

1. SyntaxError 语法错误
2. ReferenceErro 引用错误
3. RangeError 范围错误
4. TypeError 类型错误
5. URLError URL错误：主要是相关函数的参数不正确。
6. EvalError eval错误： 当eval()函数没有被正确执行时，会抛出evalError错误。但是ES5以上的JS已经不再抛出这个错误，但依然可以通过new关键字来自定义该类型的错误提示

这些错误，连同原生Error都是构造函数，可以自己生成错误对象的实例

```javascript
throw new Error('出错了！');
throw new TypeError('类型错误！');
```



### JavaScript中this

this是在运行时进行绑定的，并不是编写时绑定的，它的上下文取决于函数调用时的各种条件。

也就是说 **this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。**

> 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈），函数的调用方式、传入的参数等信息。this就是这个记录中的一个属性，会在函数执行的过程中用到。

调用位置：函数在代码中被调用的位置，其决定了this的绑定。

最重要的就是分析调用栈（就是为了达到当前执行位置所调用的所有函数）。**我们关心的调用位置就在当前正在执行的函数的前一个调用中。**

学习四种绑定规则

**默认绑定**

是最常用的**独立函数调用**，在无法应用其他规则时的默认规则，就是根据调用位置决定的this

如果是严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined

**隐式绑定**

**显示绑定**

**new绑定**

《你不知道的JavaScript 上卷》



### 防抖和节流

防抖和节流都有一个共同的概念：通过限制调用次数来进行**性能优化**

**防抖**

触发事件一定时间后才会执行，如果在这段时间内再一次触发了这个事件，则重新计时这段时间

```javascript
function debounce(fn,delay = 3000){
	let timer = null;
    return (...args) => {
		if(timer) clearTimeout(timer); 
        timer = setTimeout(() => {
            fn(...args);
        },delay);
    }
}
```

> 代码一步一步、一行一行的说，说的过程中可以提及一些已经改进的代码，比如timer私有变量写在内部，使用扩展运算符，箭头函数

**节流**

每隔一段时间内，事件只触发一次

节流会稀释事件执行频率

```javascript
function throttle(fn , delay = 3000){
	let timer = null;
    return (...args) => {
        if(timer) return;
        timer = setTimeout(() =>{
            fn(...args);
            timer = null;
        },delay);
    }
}
```

相同点：目的都是降低回调次数，节省资源；

不同点：防抖关注一定时间内连续执行的事件，只执行最后一次；节流侧重于一段时间内，只执行一次

**应用场景**：

防抖：手机号，邮箱号的输入；窗口大小的调整，防止重复渲染

节流：滚动加载；表单的多次提交



### JS中的new关键字

JS中的new关键字会进行以下操作：

1. 创建一个空的简单JS对象，即{}
2. 为新建的对象添加\__proto__，将该属性链接至构造函数的原型对象（修改原型链）
3. 将新建的对象作为传入函数的this上下文（this绑定）
4. 如果构造函数内部显示返回对象数据类型，则返回该数据；否则返回新创建的对象

> 如果原本的构造函数内部返回基础类型，那么最后new的返回值还是创建的对象
>
> 如果是返回的一个对象，则new返回这个对象（对应第四条）

 手写一个new

```javascript
    function _new (fn,...args){
        const obj = Object.create(fn.prototype);
        const res = fn.apply(obj,args);
        return res instanceof Object ? res : obj;
    }
```

> 这里不能用typeof进行类型判断
>
> 因为用typeof去判断null，得到的结果是'object'
>
> 这是一个JS自己的bug，null应该是原始数据基本类型。
>
> 而instanceof 是看被判断的数据（实例对象）的原型链上是否有后面这个构造函数的原型对象，就不会出现误判null为object的情况

**为什么typeof null === ‘obejct’ ？**

在 JavaScript 最初的实现中，JavaScript 中的值是由**一个表示类型的标签**和**实际数据值**表示的

对象的类型标签是 0。但由于 null 代表的是空指针（大多数平台下值为 0x00），因此，**null 的类型标签也是 0**

typeof判断是判断其类型标签，typeof null 也因此返回 "object"。

参考文章：

- 详解 JS 中 new 调用函数原理 https://juejin.cn/post/6844903630605123598
- MDN typeof https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#null



### 闭包

闭包就是指**有权调用另一个函数作用域中变量的函数**（外面的这个函数，不是返回的函数）

**闭包的主要作用是**

- 延伸了变量的**作用范围**
- 隐藏变量，避免了**全局污染**

> 因为函数内部声明 的变量是局部的，只能在函数内部访问到，但是函数外部的变量是对函数内部可见的，这就是作用域链的特点了。子级可以向父级查找变量，逐级查找，找到为止

**闭包的危害**

- 不恰当的使用闭包可能会造成内存泄露的问题

为什么会发生内存泄露？

JS规定在一个函数作用域中，程序执行完后变量就会被销毁，这样可以节省内存（JS的垃圾回收机制）。而使用闭包时，由于作用域链的特点，变量一直不会被销毁，因为会被函数一直调用，从而造成了内存泄露

> 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

闭包的底层原理与**作用域链**相关 https://www.cnblogs.com/digdeep/p/4817141.html

- 什么是闭包？（另外一种说法，感觉更专业，更绕一点）闭包就是同时含有对函数对象以及作用域对象引用的对象。实际上，所有JavaScript对象都是闭包。
- 闭包是什么时候被创建的？因为所有JavaScript对象都是闭包，因此，当你定义一个函数的时候，你就定义了一个闭包。
- 闭包是什么时候被销毁的？当它不被任何其他的对象引用的时候。





### JS的垃圾回收机制（GC）

JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理

一般来说，垃圾回收器有自己的回收策略

譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）

JS常用的两种垃圾回收规则是：

- 标记清除
- 引用计数

JS引擎基础GC方案是**mark and sweep**（标记清除）,简单的解释如下：

1. 遍历所有可访问的对象
2. 回收已不可访问的对象

> 当变量进入环境时，例如声明一个变量，就将这个变量标记为“进入环境”
>
> 从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们
>
> 而当变量离开环境时，则将其标记为“离开环境”
>
> GC会在运行的时候会给存储在内存中的所有变量加上标记
>
> 然后它会去掉环境中的变量和被环境中变量引用的变量（相关应用变量）的标记（比如闭包）
>
> 在此之后被加上标记的变量就会视为准备被删除的变量，原因是环境中的变量已经无法访问到这些变量了
>
> 最后垃圾回收期完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间
>
> （和可达性分析算法类似）



关于**引用计数**

跟踪记录每个值被引用的次数，当一个值被引用时，次数`+1`，减持时`-1`，下次垃圾回收器会回收次数为`0`的值的内存（当然了，容易出循环引用的内存泄露）

> 什么是循环引用？
>
> 当对象 1 中的某个属性指向对象 2，对象 2 中的某个属性指向对象 1 就会出现循环引用，（当然不止这一种情况，不过原理是一样的）
>
> 如果出现上述情况，代码执行完后，会将变量赋值为null，引用完后变量计数都为1，并不为0，并不会进行垃圾回收，就会造成内存泄露



**GC的缺陷**

和其他语言一样，JS的GC策略避免一个问题：**GC时，停止响应其他操作**

这是为了安全考虑。

而JS的GC在**100ms甚至以上**

对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。

这就是引擎需要优化的点： **避免GC造成的长时间停止响应。**

> 只要采用标记清除方法，就会产生内存碎片，需要对内存碎片进行处理（内存调整，或者说是用空链表记录）这里我还不知道JS怎么处理这个内存碎片。



**GC优化策略**

这里要用到：**分带回收**

目的是通过区分“临时”与“持久”对象：

- 多回收“临时对象”区
- 少回收“持久对象”区
- 减少每次需要遍历的对象，从而减少每次GC的耗时



### JS内存泄露的四种方式及如何解决？

内存泄露是很多问题的根源：反应迟钝，崩溃，高延迟以及其他应用问题

**常见的JS内存泄露**

- 意外的全局变量，如在函数里不用var 就声明变量，或者直接用this.param声明变量

> 在 JavaScript 文件头部加上 `'use strict'`，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。
>
> 尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于 临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，**确保用完以后把它设置为 null 或者重新定义**。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。

- 被遗忘的计时器或回调函数（不懂）
- 脱离DOM的引用（不懂）
- 闭包

**解决方法**

- 优化代码逻辑，避免出现上述的JS泄露情况，及时将不需要的变量赋为null或者重新引用
- Chrome内存剖析工具概览Timeline和Profiles
- 使用ES6推出的新的数据结构：WeakSet和WeakMap。它们对值的引用是弱引用，不计入垃圾回收机制（这里针对引用计数机制）



### JS中的堆与栈

**栈(stack)：**是栈内存的简称，栈是**自动分配**相对**固定大小**的内存空间，并由系**统自动释放，**栈**数据结构**遵循**FILO**（first in last out）**先进后出**的原则，较为经典的就是乒乓球盒结构，先放进去的乒乓球只能最后取出来。

**堆(heap)：**是堆内存的简称，堆是**动态分配**内存，**内存大小不固定**，也**不会自动释放，**堆**数据结构**是一种无序的树状结构，同时它还满足key-value键值对的存储方式；我们只用知道key名，就能通过key查找到对应的value。比较经典的就是书架存书的例子，我们知道书名，就可以找到对应的书籍。

**栈的特点**

开口向上、速度快，容量小

**堆的特点**

速度稍慢、容量比较大

**基本数据类型**：**Undefined,String,Boolean,Null,Number，**都是直接按值存放在栈内存中，占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。

**引用数据类型**：指那些可能由多个值构成的对象，如**对象(Object)、数组(Array)、函数(Function)** ，它们是通过拷贝和new出来的，这样的数据存储于堆中。



**传值和传址的区别**

**基本类型**：采用的是**值传递**。

**引用类型**：则是**地址传递**。

**引用类型的数据的地址指针是存储于栈中的**，将存放在栈内存中的地址赋值给接收的变量。当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，**再通过地址指针找到堆中的所需要的数据**（保存在堆内存中,包含引用类型的变量实际上保存的不是变量本身，而是指向该对象的指针）。

**内存分配垃圾回收**

**1.内存分配：**

**（1）栈内存：**线性有序存储，容量小，系统分配效率高。

**（2）堆内存：**首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要低一些了。 

**2.垃圾回收**：

**（1）栈内存：**变量基本上用完就回收了，相比于堆来说存取速度会快，并且栈内存中的数据是可以共享的。

**（2）堆内存**：堆内存中的对象不会随方法的结束而销毁，就算方法结束了，这个对象也可能会被其他引用变量所引用(参数传递)。创建对象是为了反复利用（因为对象的创建成本通常较大），这个对象将被保存到运行时数据区（也就是堆内存）。只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。

>  在JavaScript中，作用域对象是在堆中被创建的（至少表现出来的行为是这样的）

文章：https://juejin.cn/post/6854573215327617031



### 栈溢出及一些解决办法

调用栈是JavaScript引擎追踪函数执行的一个机制

https://blog.poetries.top/browser-working-principle/guide/part2/lesson08.html#_2-%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%88stack-overflow%EF%BC%89

https://juejin.cn/post/6930793361833984007

http://www.ruanyifeng.com/blog/2015/04/tail-call.html



### 简述一些操作数组的函数

简单的、常见的有

- concat 连接两或者更多的数组
- push 数组末尾添加元素
- pop 删除数组最后一个元素
- shift 删除数组第一个元素
- unshift 数组开头添加元素
- sort 排序
- toString 转换成字符串
- for...of   for...in（一般不用）  forEach() item index arr

等等一堆函数

ES6新增的有

- from 把类数组转换成真正的数组
- find 用于找出第一个符和条件的成员，里面是个回调函数 item index  arr
- findIndex 在find的基础上变成了找位置
- includes 是否包含给定的值

**for...of 和for...in有什么区别**

for in是遍历对象的属性名（键名），所以用for in遍历数组时，拿到的是每个元素的索引。一般不用在数组里，用于对象的遍历。

for of是遍历对象的属性的值（键值），只能用于可迭代的数据（涉及迭代器知识），包括数组，set，map，字符串，不包括对象。



### 什么是Node.JS

https://segmentfault.com/a/1190000019854308



### Node.js 和 JS的区别

> Node.js是基于V8引擎的运行环境，是一个能让JS**运行在服务器端的平台**，让JS成为PHP、Python等服务端语言平起平坐的脚本语言
>
> Node.js就是把浏览器的解释器封装起来作为服务器运行平台，用类似JavaScript的结构语法进行编程，在Node.js上运行

1. Node.js是平台，JS是编译语言

2. JavaScript组成：ECMAScript, DOM, BOM

   Node.js组成：ECMAScript, OS, file, net, database

3. 顶层对象不同，JS的顶层对象是window，node的顶层对象是global



### CommonJs和Es Module

https://juejin.cn/post/6938581764432461854

import() 动态导入:https://zh.javascript.info/modules-dynamic-imports



### 数组与字符串的一些常用方法

都有的方法有：

param.concat 给param连接一个或多个，不改变param，返回新的字符串（字符串可以使用 + ，更方便，但大量的+拼接字符串比较耗时）









### 设计模式

**工厂模式**

不暴露创建对象的具体逻辑，而是将逻辑装在一个函数中，这个函数被视为一个工厂

优点：将创建对象的工作转移到了工厂类；面向接口编程，体现了面向对象的思想；

分类：简单工厂模式，工厂方法模式，抽象工厂模式

**简单工厂模式** 可以解决多个相似的问题，一个工厂对象来创建某一类产品的实例

**简单工厂只能作用于创建的对象数量较少，对象的创建逻辑不复杂时使用**

（应用：网络请求的封装）

**工厂模式**

**将实际创建对象的工作推迟到子类中，这样核心类就变成了抽象类。**



**抽象工厂方法** 也是抽象类，只是在工厂模式的前提下多了其他大类产品， 是用于对产品类簇的创建。也就是多了个产品抽象类，如果只有一个产品抽象类，那就变成了工厂模式。但又回到了简单工厂的问题，每新增一个抽象类，要修改核心抽象工厂和其子类，违背了开放封闭原则



**单例模式**

保证一个类仅有一个实例，并且自行实例化提供这个实例

只能被实例化(构造函数给实例添加属性与方法)一次

用一个变量（锁）来实现，或者一个简单的判断

应用：模态框，弹窗

https://segmentfault.com/a/1190000012842251



**安全沙箱模式**

将一个函数放在立即执行函数里，用变量接收闭包暴露的接口。这样才能调用里面的值

沙箱里面不会受到外界影响，全局污染，相对来说算是安全的

应用：只受函数调用的计数器



**观察者模式（发布者订阅模式）**

定义对象间的一种一对多依赖关系，使得每当一个对象发生改变时，其相依赖的对象得到通知并更新

应用：vue



**构造函数模式**

就是最常使用的构造函数

应用：很多，ES6之前的继承就可以通过构造函数和原型对象来实现



**代理模式**

为一个对象提供一个代用品或占位符，以便控制对它的访问

某一个开销很大的操作，可以通过虚拟代理的方式延迟到**需要它的时候才创建**

应用：图片懒加载



**装饰器模式**

动态的向一个现有的对象添加新的功能，同时又不改变其结构，不会影响原有的功能。这种类型的设计模式属于结构型模式，它是作为现有的对象的一个包装。



https://xie.infoq.cn/article/88c926822394aa1c80847dd2a

https://juejin.cn/post/6844903653774458888







### 原型链和原型链继承	

首先，JS规定每个一个构造函数都有一个prototype属性，指向一个对象，这个对象被称为原型对象，该对象上的方法和属性，都会被其构造函数所拥有，每一个构造函数都有一个原型对象。

每一个构造函数所创建的实例对象，都有一个__proto属性指向构造函数的原型对象，这样每个实例化对象也可以访问原型对象上的方法和属性。三者的关系就如同一个三角形一般。

而原型链，简单的说就是用原型对象组成的链。

因为构造函数的prototype里也有一个__proto属性，它指向的是创建prototype这个对象的构造函数的原型对象，一般来说也就是Object构造函数的原型对象。

Object，Object的原型对象，某个对象的原型对象，这三者的关系与前面提到的关系是一样的。

Object的原型对象的__proto则指向null。而这一系列属性的指向，如同链一样把原型给链接起来了，这就形成了一个原型链。

**原型链继承**

在ES6之前，没有class和extends，只能用构造函数和原型对象**模拟实现继承**，也叫组合继承

首先要用到call或者apply函数，这两个函数可以修改执行某个函数的this指向

在构建子类的构造函数时，用call或者apply调用父类构造函数，再通过修改子类构造函数的原型对象，将其构造成父类的原型方法（new Father()  改constructor），这样就获得了父类的属性方法，而自己的属性方法照常实现，这样就模拟了继承

从**本质上**来看ES5的继承实质就是在创建子类实例对象后，再把父类的方法属性添加到新建的这个this上

> ES6的继承机制完全不同，**实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this**。
>
> static不能被子类的实例继承，也不能被自身实例继承，但可以直接通过构造函数（子类父类都可以）来调用
>
> 如何像JAVA一样通过设置私有方法让子类不能继承到父类的某些方法呢？



### 详细说一下浏览器获得URL，到页面加载的过程

导航——文档加载阶段——关闭TCP，浏览器处理后续操作

**导航**

1.处理输入

浏览器tab外面发生的一切都是有浏览器进程（browser process）控制的。Browser Process进程中有很多负责不同工作的线程，其中包括绘制浏览器顶部按钮和导航栏输入框组件的UI Thread ，管理网络请求的Network Thread，以及控制文件读写的存储线程Storage Thread。

当在浏览器导航栏输入框输入URL时，UI线程会处理你的输入

在部分浏览器如Google浏览器，UI线程的**第一件事就是判断输入的字符串是搜索的关键字还是一个URL地址**

当用户在导航栏输入信息的时候UI线程要进行一系列的解析来判定是将用户输入发送给搜索引擎还是直接请求你输入的站点资源



2.开始导航

用户按下回车后，UI线程会叫网络线程初始化一个网络请求来获取站点网页内容。此时tab上会展示一个提示资源正在加载中的旋转圆圈，且网络线程会进行一系列诸如**DNS寻址和请求建立TLS连接（HTTPS保证安全的连接）的操作**

对于输入的域名需要通过DNS域名解析来查询对应的IP

1. 浏览器会先检查自己缓存中有没有被解析过的这个域名对应的IP地址，如果有，解析结束。域名被缓存时间可以设置TTL（Time To Live）属性来设置

   > 域名中的TTL是Time-To-Live简称，意思是跳域名解析记录在DNS服务器中的存留时间。
   >
   > TTL是域名解析的生命周期，TTL值全称是“生存时间（Time To Live)”，简单的说它表示DNS记录在DNS服务器上的缓存时间。
   >
   > TTL简单的说它表示DNS记录在附件在服务器上的缓存时间。对于用户来说，每一次访问网站A，不会每次都到DNS服务器域名解析，而是用户第一次访问时才到DNS服务器进行解析。

2. 如果浏览器缓存没有命中，浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析过程。在windows的C盘下有一个hosts的文件来设置，如果在这里指定了一个域名对应的IP地址，那么浏览器会首先使用这个IP地址

   > 但是这种操作系统级别的域名解析规程也被很多黑客利用，通过修改你的hosts文件里的内容把特定的域名解析到他指定的ip地址上，造成所谓的**域名劫持**。所以**将hosts文件设置成了readonly，防止被恶意篡改**。

3. 如果系统缓存依旧没有命中，才会去请求本地域名服务器LDNS来解析这个域名。这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。

如果这步还没解决，后续还会涉及到Root Server域名解析服务器，这里暂且不表

如果访问的网站进行了CDN服务，那么访问网站时会进行CDN加速

> 这时如果网络线程收到服务器的HTTP 301重定向响应，它就会告知UI线程进行重定向然后它会再次发起一个新的网络请求。



3.读取响应

网络线程在收到HTTP响应的主体流（payload stream）时，在必要的情况下它会检查一下流的前几个字节以确定响应主体的具体媒体类型（MIME Type）。

> 响应的媒体类型一般可以通过HTTP响应的Content-type来确定，但有时Content-type是缺失和错误的，这时就需要进行MIME类型嗅探来确定响应类型了

如果响应的主体是一个HTML文件，浏览器会将获取的数据交给渲染进程来进行下一步工作。

如果拿到的响应数据是一个压缩文件(Zip File)或者其他类型的文件，响应数据就会交付给**下载管理器**来处理

> 网络线程在把内容交付给渲染进程之前还会对内容做SafeBrowsing检查。
>
> 如果请求的域名或者响应的内容和某个已知的病毒网站匹配，网络线程会给用户展示一个警告的画面。
>
> 除此之外，网络线程还会做CORB(Cross Origin Read  Blocking)检查来确定那些敏感的跨站数据不会被发送至渲染进程



4.寻找一个渲染进程

在网络线程做完所有的检查后并且能够确定浏览器应该导航到该请求的站点，它会通知UI线程所有的数据都已经被准备好了。UI线程在收到网络线程的确定后会为这个网站**寻找一个渲染进程来渲染界面**

> 由于网络请求可能需要长达几百毫秒的时间才能完成，为了缩短导航需要的时间，浏览器会在之前的一些步骤里面做一些优化。例如在第二步中当UI线程发送URL链接给网络线程后，它其实已经知晓它们要被导航到哪个站点了，所以在网络线程干活的时候，UI线程会主动地为这个网络请求启动一个渲染进程。如果一切顺利的话（没有重定向之类的东西出现），网络线程准备好数据后页面的渲染进程已经就准备好了，这就节省了新建渲染进程的时间。不过如果发生诸如网站被重定向到不同站点的情况，刚刚那个渲染进程就不能被使用了，它会被摒弃，一个新的渲染进程会被启动。



5.提交导航

到这一步的时候，数据和渲染进程都已经准备好了，浏览器进程（browser process）会通过IPC（进程间通信）告诉渲染进程去提交本次导航（commit navigation）。除此之外浏览器进程还会将刚刚接收到的响应数据流传递给对应的渲染进程让它继续接收到来的HTML数据。

一旦浏览器进程收到渲染线程的回复说导航已经被提交了（commit），导航这个过程就结束了，文档的加载阶段（document loading phase）会正式开始。

> 到了这个时候，导航栏会被更新，安全指示符（security indicator）和站点设置UI（site settings UI）会展示新页面相关的站点信息。
>
> 当前tab的会话历史（session history）也会被更新，这样当你点击浏览器的前进和后退按钮也可以导航到刚刚导航完的页面。为了方便你在关闭了tab或窗口（window）的时候还可以恢复当前tab和会话（session）内容，当前的会话历史会被保存在磁盘上面。



**文档加载阶段**

渲染进程处理页面内容。渲染进程负责标签（tab）内发生的所有事。在渲染进程里面，主线程（main thread）处理了绝大多数你发送给用户的代码。如果你使用了web worker或者service worker，相关的代码将会由工作线程（worker thread）处理。合成（compositor）以及光栅（raster）线程运行在渲染进程里面用来高效流畅地渲染出页面内容。

**渲染进程的主要内容是将HTML,CSS,以及JavaScript转变为我们可以进程交互的网页内容**

> 渲染进程里面有：一个主线程(main thread)，几个工作线程(work thread)，一个合成线程(compositor thread)及一个光栅线程(raster thread)

1.解析

**构建DOM树**，渲染进程在收到**提交导航**的消息后，渲染进程就会开始接收HTML数据，同时主线程开始解析接收到的文本数据并把它转换成一个DOM对象

> DOM对象即是浏览器对当前页面的内部表示，也是Web开发人员通过JavaScript与网页进行交互的数据结构和API

**子资源加载**，在加载到一些子资源如图片，CSS样式以及JavaScript资源时，这些文件会从**缓存或网络**中获取。主线程会在构建DOM树时遇到的顺序发起网络请求。有时为了效率，浏览器会同时运行“预加载扫描程序”

> JS资源会阻止DOM树解析。因为JS中可能会有诸如document.write()这样的代码来改变文档树结构。如果不阻塞，会引起重绘等性能问题，这也是浏览器自带的优化机制
>
> 给浏览器加载资源的提示
>
> 开发人员可以通过给JS标签添加async和defer使JS标签异步加载
>
> \<link rel="preload"> 资源预加载可以用来告诉浏览器这个资源在当前的导航肯定会被用到，你想要尽快加载这个资源

**样式计算**。通常我们会为页面设计样式，主线程会解析页面的CSS从而确定每个DOM的计算样式。计算样式是主线程根据CSS样式选择器（CSS selectors）计算出的每个DOM元素应该具备的具体样式，你可以打开devtools来查看每个DOM节点对应的计算样式。

> 即使你的页面没有设置任何自定义的样式，每个DOM节点还是会有一个计算样式属性，这是因为每个浏览器都有自己的默认样式表。

2.布局与绘画

只知道网站的文档流以及每个节点的样式是远远不足以渲染出页面内容的，还需要通过**布局（layout）**来计算出每个节点的**几何信息**（geometry）布局的具体过程是：主线程会遍历刚刚构建的DOM树，根据DOM节点的计算样式计算出一个布局树（layout tree）。

布局树上每个节点会有它在页面上的x，y坐标以及盒子大小（bounding box sizes）的具体信息。布局树长得和先前构建的DOM树差不多，不同的是这颗树只有那些可见的（visible）节点信息。举个例子，如果一个节点被设置为了**display:none**，这个节点就是不可见的就不会出现在布局树上面（**visibility:hidden**的节点会出现在DOM树上面，你可以思考一下这是为什么）。同样的，如果一个伪元素（pseudo class）节点有诸如`p::before{content:"Hi!"}`这样的内容，它会出现在布局上，而不存在于DOM树上。

知道了DOM节点以及它的样式和布局其实还是不足以渲染出页面来的。为什么呢？举个例子，假如你现在想对着一幅画画一幅一样的画，你已经知道了画布上每个元素的大小，形状以及位置，你还是得思考一下每个元素的绘画顺序，因为画布上的元素是会互相遮挡的（z-index）。

在绘画这个步骤中，主线程会遍历之前得到的布局树（layout tree）来生成一系列的绘画记录（paint records）。绘画记录是对绘画过程的注释，例如“首先画背景，然后是文本，最后画矩形”。

3.合成

**如何绘制一个页面？**

到目前为止，浏览器已经知道了关于页面以下的信息：**文档结构，元素的样式，元素的几何信息以及它们的绘画顺序**。那么浏览器是如何利用这些信息来绘制出页面来的呢？**将以上这些信息转化为显示器的像素的过程叫做光栅化（rasterizing）**。

可能一个最简单的做法就是只光栅化视口内（viewport）的网页内容。如果用户进行了页面滚动，就移动光栅帧（rastered frame）并且光栅化更多的内容以补上页面缺失的部分。Chrome的第一个版本其实就是这样做的。然而，对于现代的浏览器来说，它们往往采取一种更加复杂的叫做合成（compositing）的做法。

### 什么是合成

合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程（compositor thread）里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。页面的动画效果实现也是类似，将页面上的层进行移动并构建出一个新的帧即可。

**页面分层**

为了确定哪些元素需要放置在哪一层，主线程需要遍历渲染树来生成一棵层次树。

当层次过多时，渲染性能反而会下降，因此要衡量渲染层数

**在主线程之外光栅化和合成页面**

一旦页面的层次树创建出来并且页面元素的绘制顺序确定后，**主线程就会向合成线程（compositor thread）提交这些信息**。然后合成线程就会光栅化页面的每一层。因为页面的一层可能有整个网页那么大，所以合成线程需要将它们切分为一块又一块的小图块（tiles）然后**将图块发送给一系列光栅线程（raster threads）**。光栅线程会栅格化每个图块并且把它们存储在GPU的内存中。

合成线程可以给不同的光栅线程赋予不同的优先级（prioritize），进而使那些在视口中的或者视口附近的页面可以先被光栅化。为了响应用户对页面的放大和缩小操作，页面的图层（layer）会为不同的清晰度配备不同的图块。

当图层上面的图块都被栅格化后，合成线程会收集图块上面叫做**绘画四边形**（draw quads）的信息来构建一个**合成帧**（compositor frame）。

- 绘画四边形：包含图块在**内存的位置**以及图层合成后图块在页面的位置之类的信息。
- 合成帧：代表页面一个帧的内容的绘制四边形**集合**。

上面的步骤完成之后，合成线程就会通过IPC向浏览器进程（browser process）提交（commit）一个渲染帧。这个时候可能有另外一个合成帧被浏览器进程的UI线程（UI thread）提交以改变浏览器的UI。这些合成帧都会被发送给GPU从而展示在屏幕上。如果合成线程收到页面滚动的事件，合成线程会构建另外一个合成帧发送给GPU来更新页面。

合成的好处在于这个过程没有涉及到主线程，所以合成线程不需要等待样式的计算以及JavaScript完成执行。这也就是为什么说[只通过合成来构建页面动画](https://link.zhihu.com/?target=https%3A//www.html5rocks.com/en/tutorials/speed/high-performance-animations/)是构建流畅用户体验的最佳实践的原因了。如果页面需要被重新布局或者绘制的话，主线程一定会参与进来的。

**关闭TCP链接，浏览器处理用户后续操作**



### DNS为什么即使用TCP又使用UDP？

首先UDP报文最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节后，协议的TC标志出现删除标志，这时则使用TCP发送。

我了解的，DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议

域名解析时使用UDP协议：

客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器**负载更低，响应更快**。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，**很多DNS服务器进行配置的时候，仅支持UDP查询包**。

> 区域传输：DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中**主DNS服务器从自己本机的数据文件**中读取该区的DNS数据信息，而辅助DNS服务器则**从区的主DNS服务器中**读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫区域传输



### HTTP报文格式

**HTTP请求报文**

- 请求行（request line）：请求方法  URL 协议版本
- 请求头部（header）：许多key-value的值，如Accept-Encoding，User-Agent
- 空行(CR+LF) ：请求报文中空行表示header和请求数据的分割
- 请求数据（request data） ： GET方法不会携带数据，POST方法会携带一个body

**HTTP响应报文**

- 状态行：HTTP版本号 状态码 状态值组成
- 响应头类似请求头，是一系列的key-value值
- 空行：同上，响应报文也用空白行来分隔header和数据
- 响应体：响应的data



### HTTP常见字段有哪些？

**Host字段：**客户端发送请求时，用来指定服务器的域名

> Host：www.A.com

**Refere字段：** 当前请求页面的**来源页面的地址**，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 `Referer` 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等，还能防范CSRF攻击。

> Refere:\<url\>

Origin字段：表示了请求来自于哪个站点。该字段仅指示服务器名称，不包含任何路径信息

> Origin: <scheme> "://" <host> [ ":" <port> ]

**Content-Length字段：**服务器在返回数据时，会有Content-Length字段，表明本次回应的数据长度

> Content-Length:1000

**Connection字段：**最常用于客户端要求服务器使用TCP持久连接，以便其他请求复用，HTTP/1.1默认连接都是持久连接，但为了兼容老版本，需要制定Connection字段值为Keep-Alive

> Connection:Keep-Alive

这不是一个标准的字段

**Content-Type字段：**用于服务器回应时，告诉**客户端本次数据是什么格式**

> Content-Type:text/html;charset = utf-8
>
> 发送的是网页，编码是utf-8

客户端请求的时候，可以用**Accept**字段声明自己可以接受哪些数据格式

> Accept:*/*
>
> 客户端声明自己可以接受任何格式的数据

**Content-Encoding：**说明**数据的压缩方法**。表示服务器返回的数据使用了什么压缩格式

> Content-Encoding:gzip
>
> 表示服务器返回的数据采用了gzip方式压缩，告诉服务端需要采用此方式解压

客户端在请求时，可以用**Accept-Encoding**字段说明自己可以接受哪些压缩方法

> Accept-Encoding：gzip,deflate

**User-Agent ：**用户代理，一个特殊字符串头，是一种**向访问网站提供**你所使用的浏览器类型及版本、操作系统及版本、浏览器内核等信息的标识。

> 但是我们可以人为的修改或者添加一些信息在这里面。标记当前所在的环境，比如在哪一个客户端环境下，是在QQ里，还是微信，还是钉钉下。一般用于镶嵌在客户端或者小程序里的h5页面里

**Authorization：**请求消息头含有服务器用于验证用户代理身份的凭证，通常会在服务器返回[`401`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/401) `Unauthorized` 状态码以及[`WWW-Authenticate`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/WWW-Authenticate) 消息头之后在后续请求中发送此消息头。

> Authorization: type credentials (比如 Bearer token)
>
> token也可以放在请求body或者url上



### Content-Type具体有什么格式类型

常见的媒体类型格式：

1. text/html HTML格式
2. text/plain 纯文本格式
3. text/xml XML格式
4. image/gif gif图片格式
5. image/jpeg jpeg图片格式
6. image/png png图片格式

以application开头的媒体格式类型：

1. application/json JSON数据格式
2. application/x-www-form-urlencoded 最常见的 POST 提交数据的方式了，浏览器的原生 form 表单，提交的数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码
3. application/pdf pdf格式
4. application/msword word文档格式
5. application/xml XML数据格式
6. application/octet-stream 二进制流数据（如常见的文件下载）

另一种常见的媒体格式是上传文件的时用到的

multipart/form-data 需要在表单中进行文件上传，就需要使用该格式

> charset = utf-8 后面还可以跟个charset，表示编码是什么，比如这里就表示编码是utf-8
>
> 编码，就是以特定的编码规则将字符编码成字节。
>
> 解码，是将字节以特定的编码规则转换为字符。
>
> 乱码：字符以某种特定的编码方式转换成字节，字节又以另一种编码方式转换成字符，因为在这个过程中编码和解码所用的编码方式不同，导致乱码。所以乱码经常发生在网络I/O过程中，客户端和服务器的编码方式不同导致乱码。



### HTTP特点

HTTP最凸出的优点是：简单，灵活和易于扩展、应用广泛和跨平台

1. HTTP基本报文就是header+body，头部信息也是key-value简单文本格式，易于理解，**简单**易懂
2. HTTP协议里各类请求方法，状态码，头文字等每个组成都没有被固定死，**允许开发人员自定义和扩充**
3. HTTP的应用范围非常广泛，天然具有跨平台的优越性
4. 支持B/S及C/S模式？

缺点：

1. HTTP是无状态的协议
2. HTTP信息是明文传递，虽然在调试时提供了极大的便利性，但存在安全问题



### HTTP和HTTPS的区别

1. HTTP是超文本传输协议，信息是明文传输，存在信息安全风险问题。HTTPS解决了HTTP不安全的缺陷，在TCP和HTTP之间加入了SSL/TLS安全协议，使得报文能够加密传输
2. HTTP连接建立相对简单，TCP三次握手后便可以进行HTTP的报文传输。而HTTPS在TCP三次握手后，还要进行SSL/TLS的握手过程，才能进行加密的报文传输
3. HTTP的端口号是80，HTTPS的端口号是443
4. HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的



### HTTPS是如何解决HTTP的安全问题的？

HTTP存在的安全问题：**窃听风险，篡改风险，冒充风险**

HTTPS很好的解决了上述风险：**信息加密，校验机制，身份证书**

1.**混合加密的方式实现信息的机密性，解决了窃听的风险**

HTTPS采用的是**对称加密**和**非对称加密**结合的混合加密方式：

- 在通信建立前采用非对称加密的方式交换会话秘钥，后续就不再使用非对称加密。
- 在通信过程中全部使用对称加密的会话秘钥的方式加密明文数据

采用混合加密的方式原因：

- 对称加密只使用一个密钥，虽然运算速度快，但密钥必须保密，无法做到安全的密钥交换
- 非对称加密使用公钥和私钥，公钥可以任意分发而私钥保密，虽然解决了密钥交换的安全问题，但运算速度慢

HTTPS就结合这个两种加密方式，先使用非对称加密保证密钥交换的安全，等生成了会话密钥后因无需进行密钥交换，这时候就使用对称加密

> 对称加密：就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。
>
> 如DES,AES,3DES等
>
> 非对称加密：加密和解密使用不同的秘钥，一把作为公开的秘钥（公钥），另一把叫做私钥。公钥加密的信息，只有私钥能解密；私钥加密的信息，只有公钥能解密。
>
> 如RSA,ECC等

2.**摘要算法的方式来实现完整性，它能够为数据生成独一无二的`指纹`，指纹用于校验数据的完整性，解决了篡改的风险**

客户端在发送明文前会通过摘要算法算出明文的指纹，然后把`指纹 + 明文`一同加密发送，服务器解密后，用相同的摘要算法算出发送过来的明文的指纹，通过比对指纹判断数据是否完整

3.**将服务器公钥放入数字证书中，解决了被冒充的风险**

客户端向服务器索要公钥，然后用公钥加密，服务器收到密文后，用自己的私钥解密。

为了保证客户端索要的公钥没有被篡改，需要借助第三方权威机构CA，**服务器将自己的公钥放在数字证书里，只要证书可信（本地的CA公钥来判断），公钥就是可信的。**



### SSL/TLS协议建立的详细流程

1. 首先客户端要向服务器发起加密请求（**ClientHello**），发送以下信息：

   - 客户端支持的SSL/TLS协议版本
   - 客户端生成的随机数A
   - 客户端支持的密码套件列表，如RSA加密算法

2. 服务器收到客户端请求后，向客户端发出响应（**SeverHello**），响应以下信息：

   - 确认SSL/TLS协议版本，如果浏览器不支持，则关闭加密通信
   - 服务器生成的随机数B
   - 确认密码套件列表
   - 服务器的数字证书（里面存放服务器的公钥）

3. 客户端收到这些信息后，首先通过浏览器或者操作系统中**早已备好**的CA公钥，确定**数字证书的真实性**。如果证书没问题，客户端会从数字证书中取出公钥（服务端的），**用这个公钥来加密报文**，向服务器发送这些信息：

   - 一个被服务器公钥加密随机数C
   - 加密通信算法改变的通知，表示之后的信息都会用会话密钥加密通信
   - 客户端握手结束的通知，同时把之前所有的内容数据发个摘要，用于服务端校验

   这样整个握手阶段就有三个随机数ABC了，接着就**用双方协商的加密算法，各自生成本次通信的会话密钥**

4. 服务器收到客户端的第三个随机数C后，通过加密算法，生成会话密钥。然后向客户端发送最后的信息：

   - 加密通信算法改变的通知，表示之后的信息都会用会话密钥加密通信
   - 服务器握手结束的通知，同时把之前所有的内容数据发个摘要，用于客户端校验

至此，整个SSL/TLS的握手阶段全部结束。接下来服务器和客户端进入加密通道，就是完全使用普通的HTTP，只不过用**会话密钥加密内容**



### HTTP缓存

按缓存的位置上来看，可以分为四种，从上往下依次检查是否命中，如果但都没有命中则重新发起请求。

- **Service Worker**是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用Service Work的话，传输协议必须是https

- **Memory Cache**是内存中的缓存，主要包含的是当前页面已经抓取到的资源，例如页面上下载的样式，脚本，图片等。读取内存的数据肯定比读取磁盘快，但内存数据虽然高效，缓存持续性很短，会随着进程的释放而释放。一旦我们关闭了tab标签页，内存中的缓存也就被释放了。

  > 内存缓存中有一块重要的缓存资源是preloader相关指令下载的资源。它可以一边解析js/css文件，一边网络请求下一个资源。

- **Disk Cache**是存储在硬盘中的缓存，读取速度较慢，但什么都能存储到磁盘中，比Memory Cache胜在容量和存储时效性上。

  > 绝大部分的缓存都来自Disk Cache，在HTTP头中设置

- **Push Cache**是推送缓存，是HTPP/2中的内容，当以上三种缓存都没命中时，它才会使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在chrome浏览器中只存在5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

缓存又分为两大类型：**强缓存和协商缓存**

区别：

- 强缓存时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求  200 from cache
- 协商缓存，浏览器会向服务器发起http请求，然后服务器告诉浏览器文件未改变，让浏览器使用本地缓存 304

关于缓存的http头部字段简述：

属于**强缓存控制**的：

http/1.0  

**Pragma**

Pragma严格来说不是专门缓存控制头部，但它设置no-cache时可以让本地强缓存失效

指令：

no-cache

与 Cache-Control: no-cache 效果一致。强制要求缓存服务器在返回缓存的版本之前将请求提交到源头服务器进行验证（协商缓存）。

**Expires**

Expires响应头包含日期/时间， 即在此时候之后，响应（缓存）过期。

指令：

一个 HTTP-日期 时间戳

Expires是服务器端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存。



http1.1 

**Cache-control** 

Cache-Control通用消息头字段，被用于在http请求和响应中，通过指定指令来实现缓存机制。

指令：

可缓存性

- public，表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。
- private，表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。
- no-cache，在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。
- no-store，缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。

到期

- max-age=\<seconds\>  设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，max-age时间是相对于**请求的时间**。
- s-maxage=\<seconds> 覆盖max-age或者Expires头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它

重新验证和重新加载

- must-revalidate 一旦资源过期（比如已经超过`max-age`），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。（告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。）
- proxy-revalidate 与 must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。

其他

- no-transform 不得对资源进行转换或转变。`Content-Encoding`、`Content-Range`、`Content-Type`等HTTP头不能由代理修改。
- only-if-cached 表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。

> 还有很多指令，这里只有一部分

指定 `no-cache` 或 `max-age=0, must-revalidate` 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。(也就是协商缓存)

如果cache-control与expires同时存在，cache-control的优先级高于expires



属于**协商缓存控制**的：

协商缓存需要跟服务端通过特殊标示连接，即第一次请求的**响应头**带上某个字段（**Last-Modified**或者**Etag**），则后续请求则会带上对应的请求字段（**If-Modified-Since**或者**If-None-Match**），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。

http1.0 If-Modified-Since/Last-Modified

If-Modified-Since/Last-Modified成对出现，属于协商缓存的内容，在发起请求时，如果`If-Modified-Since(浏览器的头部)`和`Last-Modified(服务器的头部)`**匹配**，**那么代表服务器资源并未改变，因此服务端不会返回资源实体**，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified 顾名思义，指的是文件最后的修改时间

1. 浏览器第一次跟服务器请求一个资源，respone的header里加上Last-Modified：**表示这个资源在服务器上的最后修改时间**
2. 浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header：上一次请求时返回的Last-Modified的值
3. 服务器再次收到资源请求时，会判断**最后修改时间**是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容，Last-Modified会被修改为最新的值。如果没有变化，服务器返回304 Not Modified，Last-Modified不会修改，response header中不会再添加Last-Modified的header
4. 浏览器收到304的响应后，就会从缓存中加载资源



http1.1 If-None-Match/E-tag

If-None-Match/E-tag，这两个是成对出现的属于协商缓存的内容，其中浏览器的头部是`If-None-Match`，而服务端的是`E-tag`，同样，发出请求后，如果`If-None-Match`和`E-tag`匹配，则代表内容未变，通知浏览器使用本地缓存。

由服务器生成的**每个资源的唯一标识字符串**，只要资源有变化就这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个**ETag返回**，即使这个ETag跟之前的没有变化。

1. 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
3. 某些服务器不能精确的得到文件的最后修改时间。

Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。



**区别**

- Max-Age相比Expires的话，Expires使用的是服务器端的时间，而Max-Age是相对于客户端请求的时间。如果出现客户端和服务器时间不同步，使用Expires会造成浏览器本地缓存无效或一直无法过期
- E-tag和Last-Modified
  - Last-Modified表示服务端文件最后何时改变，只能**精确到1s**，有些改变频繁的文件，在秒以下的时间内进行了修改，而Last-Modified精准度不够，导致缓存失效
  - E-tag是一种指纹机制，代表文件的相关指纹，**没有时间限制**，只要文件一变，E-tag立马改变



浏览器请求过程：有无缓存 -> 强缓存 -> 协商缓存

**缓存头优先级：Cache-Control > Expires > Etag > Last-Modified**

顺序访问图参考：https://segmentfault.com/a/1190000017311517

关于Cache-Control/Etag存在拿去验证后，是否还需要去验证Expires/Last-Modified，存疑



如何明确禁止缓存？

禁止强缓存：Pragma: no-cache(让本地强缓存失效，效果和Cache-Control: no-cache类似)

禁止所有缓存：Cache-Control: no-store



**用户对缓存的影响**

- 地址栏输入地址，先查看Disk Cache中是否匹配，没有匹配则发送网络请求。
- 普通的刷新F5，优先使用Memory Cache，其次才是Disk Cache
- 强制刷新Crtl + F5，浏览器不适用缓存

| 用户操作        | Expires/Cache-Control | Last-Modified/Etag |
| --------------- | --------------------- | ------------------ |
| 地址栏回车      | 有效                  | 有效               |
| 页面链接跳转    | 有效                  | 有效               |
| 新开窗口        | 有效                  | 有效               |
| 前进后退        | 有效                  | 有效               |
| F5刷新          | 无效                  | 有效               |
| Ctrl+F5强制刷新 | 无效                  | 无效               |



### Vue2.x和Vue3的区别

1. **数据的双向绑定原理不同**

   2.x使用的是Object.defineproperty()进行数据劫持，结合发布订阅者模式实现的

   而3使用的是es6提供的proxy API进行数据代理

   > 使用proxy的好处：
   > Object.defineproperty()只能监听对象的某一个属性，不能全对象监听，需要使用遍历，递归的方式处理对象，而proxy可以直接绑定整个对象，且不用对数组进行特异性处理，proxy可以监听数组内部数据变化
   >
   > [proxy详解](https://juejin.cn/post/6878097147649064974)

2. **使用了懒观察模式**

   在2.x中不管数据有多大，都会在一开始为其创建观察者。当数据很大的时候，这可能会在页面载入时造成明显的性能压力。

   在3版本中，只会对用于页面初始加载的数据创建观察者，所以3版本的观察者更高效

3. 重写了**虚拟DOM的实现和Tree-Shaking**

4. **新增了一些特性**

   生命周期钩子函数出现了很大的不同，2.x中的beforeCreate和created都变成了setup，后续的生命周期钩子也发生了改变。

   新的Composition（组合）API，新的一些组件，比如文档碎片Fragment，还有语法上的更新等等



### Vue工作原理

比如 一个输入框 输入文本后 怎么更新数据呢



### Vue-router有哪些模式

vue-router有三种模式：

1. hash模式：后面hash值的变化，浏览器既不会向服务器发出请求，浏览器也不会刷新，每次hash的值的变化会触发hashchanged事件
2. history模式：利用了HTML5中新增的pushState和replaceState方法，这两方法应用于浏览器的历史记录栈，提供对历史记录修改的功能。只是当它们修改时，虽然改变了当前的URL，但浏览器不会立即向后端发送请求
3. abstract模式：适用于所有JavaScript环境，例如服务器端和Node.js. 如果没有浏览器API，路由器将自动强制进入此模式。



### 什么是路由？

在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。



### 路由详解

[理解Web路由](https://zhuanlan.zhihu.com/p/24814675)



### React-Router有哪些模式，并讲一下其原理

在单页应用中，一个`web`项目只有一个`html`页面，一旦页面加载完成之后，就不用因为用户的操作而进行页面的重新加载或者跳转，React-router可以做到：

- 改变 url 且不让浏览器像服务器发送请求
- 在不刷新页面的前提下动态改变浏览器地址栏中的URL地址

其中主要分成了两种模式：

- hash 模式：在url后面加上#，如http://127.0.0.1:5500/home/#/page1
- history 模式：允许操作浏览器曾经在标签页或者框架里访问的会话历史记录

**Hash模式**

1.改变路由

```
**window.location.hash**
```

通过`window.location.hash ` 属性获取和设置 `hash `值。

2.监听路由

```
**onhashchange**
window.addEventListener('hashchange',function(e){
    /* 监听改变 */
})
```

**History模式**

1.改变路由

```javascript
history.pushState(state,title,path)
```

1 `state`：一个与指定网址相关的状态对象， popstate 事件触发时，该对象会传入回调函数。如果不需要可填 null。

2 `title`：新页面的标题，但是所有浏览器目前都忽略这个值，可填 null。

3 `path`：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个地址。

```javascript
history.replaceState(state,title,path)
```

参数和`pushState`一样，这个方法会修改当前的` history `对象记录（但不会触发popstate事件）， `history.length` 的长度不会改变。

2.监听路由

```javascript
window.addEventListener('popstate',function(e){
    /* 监听改变 */
})
```

同一个文档的 `history` 对象出现变化时，就会触发` popstate` 事件 ， `history.pushState` 可以使浏览器地址改变，但是无需刷新页面。

**注意⚠️的是：用 `history.pushState()` 或者 `history.replaceState()` 不会触发 `popstate` 事件**。 `popstate` 事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮或者调用 `history.back()、history.forward()、history.go()`方法。

**流程分析**

**当地址栏改变url，组件的更新渲染都经历了什么？** 拿history模式做参考。当url改变，首先触发histoy，调用事件监听`popstate`事件， 触发回调函数`handlePopState`，触发history下面的`setstate`方法，产生新的location对象，然后通知Router组件更新`location`并通过``context上下文传递，`switch`通过传递的更新流，匹配出符合的Route组件渲染，最后有`Route`组件取出`context`内容，传递给渲染页面，渲染更新。

**当我们调用`history.push`方法，切换路由，组件的更新渲染又都经历了什么呢？**

我们还是拿history模式作为参考，当我们调用`history.push`方法，首先调用history的`push`方法，通过`history.pushState`来改变当前`url`，接下来触发history下面的`setState`方法，接下来的步骤就和上面一模一样了，这里就不一一说了。



[「源码解析 」这一次彻底弄懂react-router路由原理](https://juejin.cn/post/6886290490640039943#heading-28)

[面试官：说说React Router有几种模式？实现原理](https://vue3js.cn/interview/React/React%20Router%20model.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88)



### 项目中的亮点

**大文件的断点续传**

首先利用**Spark-md5**插件获取每个文件唯一的hash表示码，这里读取的是Blob文件，把文件解析为**arrayBuffer**数据类型。

> 通过FileReader进行解析，用FileReader.readAsArrayBuffer（用于读取二进制文件）把文件转换成buffer格式数据（这是异步的）
>
> 再返回FileReader.onload的事件对象的e.target.result，这就是我们要的文件buffer数据

然后使用Math.ceil（file.slice() 更好？）函数对文件进行切片，创建一个切片列表，将所有切片push进去。

然后根据切片列表，创建一个请求列表，列表里面每一个函数都是发送一个切片的请求，每次请求都会带上每一片的序号（按需），和整个文件的hash标识

存在文件上传状态的变量，根据这个变量判断是否上传，这样能实现文件上传暂停功能

存在文件片上传片数的记录变量，只有切片请求列表每一次上传成功后，变量才会累加，防止文件切片丢失

在开始上传前会对这个文件（利用唯一hash表示码）在服务端的状态进行判断（发送请求），会返回这个文件是否存在，如果存在，则片数记录变量直接等于切片数，通知服务器合并文件，实现秒传效果；如果不存在或者只传了n片，则从0片或者从n+1片开始传，实现断点续传的效果

**后续优化**

切片数量：对于每个文件所应该切出来的片数，这里我直接固定每一片的大小chunksize，根据固定的chunksize来获取切片的数量。

并发传输：拿到大文件的MD5 hash值，向后端请求该文件是否存在，并获取已上传的切片列表，将其与所有切片列表进行对比，从而获取未上传的分片，生成请求push到requestList，然后调用Promise.all并发上传所有切片

上传进度：通过XMLHttpRequest提供的progress事件获取进度，这个事件会返回文件已上传的大小和总大小。项目使用 [axios](https://www.kancloud.cn/yunye/axios/234845) 对 ajax 进行封装，可以在 config 中增加 `onUploadProgress` 方法，监听文件上传进度。

前端接收文件前：检查文件类型，文件是否安全，文件大小是否超标。

如何提高大文件的获取 MD5 hash值的速度：**并行计算一个大文件的哈希码，**只要从头到尾按顺序接收文件，就可以增量计算哈希值。



**RBAC权限管理**

RBAC是基于角色的权限控制，这个模式的核心在于用户和权限之间引入了角色的概念。用户和权限没有直接的关联，而是给用户赋角色，管理角色的权限来间接地给用户赋权限。

我的项目中是使用的是最基础的RBAC0的模式，用户和角色是**一对多**的方式，一个用户只能是一个角色，一个角色可以有多个用户。

具体的实现，首先我项目中有个后台系统，在这个页面系统中有个权限管理页面，里面有我的角色列表，固定的有老师、学生、管理员三种角色。

后台可以对角色进行增删改查，比如为角色添加新的用户，增添新的角色，删除存在的角色，移除角色中的某个用户的功能。

每一个角色有修改权限的按钮，点进去是一排一排分类的权限开关，可以修改开关来修改角色的权限。**比如~~~**

前端对于某些功能做了处理，有这个权限的才会渲染出这个功能相关的东西。

并且关于一些页面做了路由守卫，根据router.beforeEach的第一个参数to ，即将进入的路由对象的path属性来进行操作，通过next函数进行路由的调整，有这个权限才能访问这个页面。

这些是前端对于权限的控制，当然我们后端同学也会对请求进行权限管理，如果请求的用户没有这个权限就并不会处理并返回错误信息

> 对于权限的处理还有可以优化的地方



### 项目中下载文件是如何实现的

首先我采用Get请求，请求时修改了responseType的值为blob，也就是说我请求了一个类似文件的二进制数据对象。responseType设置的特定类型需要确保服务器所返回的类型和设置的返回值的类型是兼容的。

然后我新建了Blob对象，参数就是response.data。然后创建了新的a元素，调用window.URL.createObjectURL创建了下载链接，而参数就是新建的Blob对象。然后把创建的下载链接赋给了新的a元素的href，将新的a标签添加到页面文档中。

最后下载完成后移除元素，调用window.URL.revokeObjectURL释放掉刚刚创建的下载链接



Blob对象表示一个不可变，原始数据的类文件对象。

它的数据可以按文本或二进制的格式进行读取，也可以转换成 `ReadableStream`来用于数据二进制流操作。 

> 流操作API中，ReadalbeStream接口呈现了一个可读取的二进制流操作
>
> ReadableStream() 构造器创建并返回包含处理函数的**可读流**实例



URL.createObjectURL()静态方法会创建一个 DOMString，DOMString包含一个参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document绑定，但为了获得最佳性能和内存使用情况，还是及时使用URL.revokeObjectURL来释放



### ArrayBuffer和Blob

`ArrayBuffer` 对象是以数组的语法处理二进制数据，也称二进制数组。

`ArrayBuffer` 对象**代表储存二进制数据的一段内存（中二进制数据）**，它不能直接读写，只能通过视图（`TypedArray`视图和`DataView`视图）来读写，视图的作用是以指定格式解读二进制数据。

`Blob` 对象表示一个二进制文件的数据内容，通常用来**读写文件**，比如一个图片文件的内容就可以通过 `Blob` 对象读写。

与 `ArrayBuffer` 区别：

- `Blob` 用于操作**二进制文件**
- `ArrayBuffer` 用于操作**内存**

> 上面写的大文件的断点续传，接收文件时文件时Blob对象，然后用FileReader中的方法readAsArrayBuffer()变成ArrayBuffer类型对象，再进行操作内存中的数据进行切片断点续传



https://segmentfault.com/a/1190000018003839

https://cloud.tencent.com/developer/article/1558929 可以重点看！



### 项目为什么要选择这些技术栈

为什么使用Vue？

首先当初是写项目是刚接触前端不久，学完基础后听学长同学介绍Vue**上手比较简单，对初学者比较友好**，刚好我们小组的前端人员也是初学者。

而且**Vue具有更好的性能**，学习生态较好，遇到问题的能很好的解决。



### 遇到传输特大文件的时候，如何进行优化？

使用Web workers

通过使用Web Workers，Web应用程序可以在独立于主线程的后台线程中，运行一个脚本操作。这样做的好处是可以在独立线程中执行费时的处理任务，从而允许主线程（通常是UI线程）不会因此被阻塞/放慢。

进行多线程处理



### Webpack

Webpack是一个前端资源加载/打包的工具。

它根据模块间的依赖关系进行静态分析，按照指定规则生成对应的静态资源。

简单多说，可以将多种静态资源JS,CSS,LESS转换成一个静态文件，减少了页面的请求



Webpack本身只能处理JS模块，要处理其他类型的模块，要使用loader进行转换

> 所以如果我们需要在应用中添加 css 文件，就需要使用到 css-loader 和 style-loader，他们做两件不同的事情，css-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们，style-loader 会把原来的 CSS 代码插入页面中的一个 style 标签中。



当然，我们可以将一下编译的配置放在配置文件webpack.config.js文件中

> 自己理解的 ，后续需要改动
>
> entry：内部依赖图的入口起点，可以有一个或多个
>
> output：打包出来的文件
>
> Modules：有哪些编译的模块
>
> plugins：配置插件信息的地方
>
> loader
>
> mode

**各类哈希的区别，或，各类哈希如何选择？（面试题）**
hash、chunkhash、contenthash，首先生成效率越来越低，成本越来越高，影响范围越来越小，精度越来越细。

hash是一整个项目，一次打包，只有一个hash值，是项目级的

chunhash是从入口entry出发，到它的依赖，以及依赖的依赖，依赖的依赖的依赖，等等，一直下去，所打包构成的代码块(模块的集合)叫做一个chunk，也就是说，入口文件和它的依赖的模块构成的一个代码块，被称为一个chunk。

contenthash是哈希只跟内容有关系，内容不变，哈希值不变。与chunkhash的区别可以举上面contenthash的例子，同时可以说明contenthash跟内容有关，但是chunkhash会考虑很多因素，比如模块路径、模块名称、模块大小、模块id等等。


（chunkhash的设计与package.json中的版本号有关吗？

（找个时间 实战使用一下

https://www.jianshu.com/p/6d81adb31601

https://blog.csdn.net/qq_17175013/article/details/119250701

webpack配置常用部分：https://segmentfault.com/a/1190000006863968



### Webpack 模块联邦 -- Module Federation

模块联邦是 webpack5 引入的特性，能**轻易实现**在两个使用 webpack 构建的项目之间**共享代码**，甚至**组合不同的应用为一个应用**。

Webpack  模块联邦是微前端的无框架解决方案。

> 微前端：将**巨大**的**单体**前端系统拆分成**多个独立**的小型系统，最后集成为一个系统的架构思路，**分而治之**，让系统
> 更加容易维护、更易扩展，实施微前端是一个**先拆分**，**后合并**的过程。
>
> 这里的前端应用指的是**前后端分离**的**单页应用**，在这基础上谈论微前端才有意义。
>
> 微前端和微服务都是为了解决大项目和大团队的难题：大项目实现**模块解耦**，大团队实现**人员解耦**，这两大难题是《软件工程》这门课程研究的主要问题。
>
> 康威定律：软件结构体现人员结构，人员结构决定软件结结构。
>
> **为何需要微前端**
>
> 巨石单体系统随着业务的增加，变得越来越臃肿，多个团队一起开发，沟通成功高，编译、部署、测试、维护困难，微前端可解决这些问题。
>
> 1. 应用自治：各个应用相互独立，规模更小，更容易扩展、测试、构建、维护、排错、升级依赖等；
> 2. 团队自治：应用独立后，团队也会独立，减少很多人在一个巨石应用中同时开发，相互影响，提高开发效率；
> 3. 技术无关：各个应用**可**选择不同的框架开发，**尽量保持统一**，否则应用之间交互会可能遇到麻烦，也不利于组件复用，比如无法共享组件级别的代码；
> 4. 尝试新技术：应用拆分后，很容易在系统里尝试新技术。
> 5. 老系统增量重构。
>
> 缺点：
>
> 1. 代码规范统一比较困难（人员多、项目多），容易克服
> 2. 开发时可能需要同时运行多个项目，容易克服
> 3. 集成测试比较困难
> 4. UI、交互等容易不统一，容易克服
>
> 实施建议：
>
> 1. 一致的工作方法：团队成员要达成一致的工作方法，尤其是宿主应用和远程应用之间的**交互协议**，需要提前约定好；
> 2. 结合业务：在使用为微前端架构之前，思考**业务划分**和微前端给团队给来的价值；
> 3. 遵从一致的代码风格，方便后期维护；
> 4. 不要过度使用：希望能实现拆分人员或者技术的目标，或者有必要拆分人员或者技术时才使用。

[Module Federation 官网](https://link.segmentfault.com/?enc=CVBEEnQS7yGgf8BECA0gcw%3D%3D.YgznW9Uq%2BSlNEXCHD5KeB0E44NwWCGy0ooi1Da3BehNyob1xaXOFj3Y1YU0VXNAe)

[webpack 5 模块联邦实现微前端](https://segmentfault.com/a/1190000041329448)



### Vue中的key有什么作用

**key的作用主要是为了高效的更新虚拟DOM**，在diff算法中，key可以管理可复用的元素，减少不必要的元素的重新渲染，让有必要的元素重新渲染。有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误。

它也可以用于强制替换元素/组件而不是重复使用它。

另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们。



> vue应用 **in-place patch（就地复用）策略**。列表里的顺序发生改变的时候比如shuffle（列表打乱）的时候，vue为了提升性能，不会移动dom元素，只是更新相应元素的内容节点。



### 常见的HTTP状态码

- 1xx 是信息类状态码，表示收到了http请求，正在进行下一步处理
  - 100 客户端继续请求
  - 101 切换协议
- 2xx 是成功类状态码，表示用户被正确接收，处理
  - 200 请求成功
  - 201 成功请求并创建了新的资源
  - 202 已接收请求，但未处理完成
- 3xx 是重定向类状态码，表示没有请求成功，必须采取进一步的动作
  - 301 永久移动，请求的资源已被永久移动到新的URL，浏览器会自动定向到新的URL，今后请求也会用新的URL
  - 302 临时移动，与301类似
  - 304 所请求的资源未修改，不会返回任何的资源。客户端通常会去缓存访问过的资源
- 4xx 是客户端错误类状态码，表示客户端提交的请求包含错误或不能正确执行
  - 400 客户端请求语法错误
  - 401 要求认证用户身份，未授权
  - 402 请求需付费
  - 403 服务器理解客户请求，但拒绝此请求，禁止访问
  - 404 服务器无法根据请求找到资源
  - 405 客户端请求的方法被这个资源禁止
  - 406 无法接受该请求
  - 408 请求超时
  - 409 指令冲突
  - 413 请求实体过大
  - 414 请求的URL地址过长
- 5xx 是服务端错误类状态码 表示服务器不能正确执行一个正确的请求
  - 500 服务内部错误
  - 501 服务器不支持该请求的功能，无法完成请求
  - 503 服务器超载或者系统维护，暂时无法处理客户端请求
  - 507 存量不足

> 哪些情况需要用到301重定向？
>
> 1. 一个站点绑定了多个域名的时候
> 2. 同一个页面存在多个URL路径
> 3. 已有页面URL发生变化时，当一个页面被收录后，若是改变该页面的url路径，那么之前的路径就会成为网站死链，这个页面上的关键词排名与收录将会消失。那么就需要做301定向，将老链接跳转到新链接
> 4. 域名改版  当我们想换个域名的时候，除了域名以外，其余内容完全一样的情况下，想把老域名的收录于排名全部过渡到新域名上，这就需要做301定向。每个页面的链接需要一一对应。





### instanceof，typeof和Object.prototype.toString的用法和区别

**instanceof**

定义： instanceof运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上

语法：

```javascript
object instanceof constructor

object：某个实例对象     constructor：某个构造函数

用来检测  constructor.prototype 是否存在于参数  object 的原型链上。
返回结果是布尔值
```

能判断基本数据类型，数组，函数，判断对象的话需要结合起来判断（用多个）

**typeof**

定义：typeof用来判断数据类型，但只能出基础数据类型：number，string，undefined，boolean，object，function,bigint

对于对象，数组（函数除外）来说，统一返回'obejct'，

语法：

```javascript
typeof param
typeof(param)

返回的结果是字符串，上面六种类型的小写
```

**toString**

定义：默认情况下，`toString()` 方法被每个 `Object` 对象继承，但是不同的数据类型会覆盖默认的方法，如果未覆盖，toString()方法返回[object type]字符串，type是对象的类型。

可以利用call,apply来判断变量的类型

语法：

```javascript
Object.prototype.toString.call(param)
```



### 浅拷贝和深拷贝

浅拷贝和深拷贝是针对复杂数据类型来说的。

浅拷贝只拷贝一层，只会把栈里面变量的引用地址拷贝过来，而非堆里的值，对象的变化相互影响。

深拷贝会每一层都拷贝，每一级别的数据都会拷贝，通常使用递归来实现，两个对象的改变不会相互影响。

```JavaScript
function deepCopy(newObj,oldObj){
  for(let k in oldObj){
    var tmp = oldObj[k];
    if(tmp instanceof Array){
      newObj[k] = [];
      deepCopy(newObj[k],tmp); 
    }else if(tmp instanceof Function){
      newObj[k] = tmp;
    }else if(tmp instanceof Object){
      newObj[k] = {};
      deepCopy(newObj[k],tmp);
    }else{
      newObj[k] = tmp;
    }
  }
}
```

Object.assign(target,sources) es6新增方法可以实现拷贝，target拷贝给谁，sources拷贝来源。

Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

因为Object.assign()拷贝的是属性值。

假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。

也就是说，如果对象的属性值为简单类型（如string， number），通过Object.assign({},srcObj)，得到的新对象为深拷贝；**如果属性值为对象或其它引用类型**，那对于这个对象而言其实是**浅拷贝**的。

数组方法concat和slice与这个原理一样

```javascript
进阶版：考虑了其他类型和循环引用

function deepClone(target,hash = new WeakMap()){
    let result;
    if(typeof target === 'object'){
      if(hash.has(target))  return hash.get(target);
      if(target instanceof RegExp || target === null){
        result = target;
      }else if(target instanceof Function){
        result = cloneFunction(target);
      }else if(target instanceof Set){
          result = new Set();

          for(let item of target){
              result.add(deepClone(item,hash));
          }
      }else if(target instanceof Map){
        result = new Map();
        
        for(let item of target){
            result.set(deepClone(item[0],hash),deepClone(item[1],hash));
        }
      }else if(target instanceof Array){
        result = [];
        
        for(let item of target){
          result.push(deepClone(item,hash));
        }
      }else{
        result = {};
        
        for(let item in target){
          result[item] = deepClone(target[item],hash);
        }
      }
      hash.set(target, result);
    }else{
      result = target;
    }
    return result;
}

// 关于函数的克隆
function cloneFunction(func) {
  const bodyReg = /(?<={)(.|\n)+(?=})/m;
  const paramReg = /(?<=\().+(?=\)\s+{)/;
  const funcString = func.toString();
  if (func.prototype) {
      console.log('普通函数');
      const param = paramReg.exec(funcString);
      const body = bodyReg.exec(funcString);
      if (body) {
          console.log('匹配到函数体：', body[0]);
          if (param) {
              const paramArr = param[0].split(',');
              console.log('匹配到参数：', paramArr);
              return new Function(...paramArr, body[0]);
          } else {
              return new Function(body[0]);
          }
      } else {
          return null;
      }
  } else {
      return eval(funcString);
  }
}    
```

参考文章：

- 如何写一个惊艳面试官的深拷贝？ https://segmentfault.com/a/1190000020255831



### 简述OSI网络七层模型

这七层分别是：

1. 物理层：**物理连接**，主要是物理介质传输媒介（网线或者是无线），以二进制数据形式在物理媒体上传输数据
2. 数据链路层：建立逻辑连接、**进行硬件地址寻址**
3. 网络层：**逻辑地址寻址，实现不同网络之间的路径选择** （**为数据包选择路由**） IP ARP
4. 传输层：**实现两个用户进程间端到端的可靠通信，处理数据包的错误等传输问题** TCP UDP
5. 会话层：负责网络中两节点的建立，在数据传输中维护计算机网络中两台计算机之间的通信连接，并决定何时终止通信（**负责建立或解除与其他接点的联系**）
6. 表示层：主要负责**数据格式的转换**，确保一个系统的应用层发送的消息可以被另一个系统的应用层读取；**数据加密**
7. 应用层：**为用户提供常用的应用程序，每个网络应用对应着不同的协议**。例如文件运输访问和管理，电子邮件等。HTTP SMTP

但分层过多，增加了网络工作的复杂性，最后TCP/IP模型保留为四层

1. 接口层
2. 网络层
3. 传输层
4. 应用层



这个网络模型究竟是干什么呢？**简而言之就是进行数据封装的**。

我们平常使用的程序（或者说软件）一般都是通过应用层来访问网络的，程序产生的数据会一层一层地往下传输，直到最后的网络接口层，就通过网线发送到互联网上去了。数据每往下走一层，就会被这一层的协议增加一层包装，等到发送到互联网上时，已经比原始数据多了四层包装。整个数据封装的过程就像俄罗斯套娃。

当另一台计算机接收到数据包时，会从网络接口层再一层一层往上传输，每传输一层就拆开一层包装，直到最后的应用层，就得到了最原始的数据，这才是程序要使用的数据。

给数据加包装的过程，实际上就是在数据的头部增加一个标志（一个数据块），表示数据经过了这一层，我已经处理过了。给数据拆包装的过程正好相反，就是去掉数据头部的标志，让它逐渐现出原形。

你看，在互联网上传输一份数据是多么地复杂啊，而我们却感受不到，这就是网络模型的厉害之处。我们只需要在代码中调用一个函数，就能让下面的所有网络层为我们工作。

我们所说的 [socket](http://c.biancheng.net/socket/) 编程，是站在传输层的基础上，所以可以使用 TCP/UDP 协议，但是不能干「访问网页」这样的事情，因为访问网页所需要的 http 协议位于应用层。

两台计算机进行通信时，必须遵守以下原则：

- 必须是同一层次进行通信，比如，A 计算机的应用层和 B 计算机的传输层就不能通信，因为它们不在一个层次，数据的拆包会遇到问题。
- 每一层的功能都必须相同，也就是拥有完全相同的网络模型。如果网络模型都不同，那不就乱套了，谁都不认识谁。
- 数据只能逐层传输，不能跃层。
- 每一层可以使用下层提供的服务，并向上层提供服务。

> 物理地址是数据链路层和物理层使用的地址，是网络设备的唯一身份标识
>
> IP地址是网络层及以上层使用的地址。
>
> 填入什么样的mac地址（物理/硬件地址）是由网络层的地址解析协议（ARP）完成的。



### 子网掩码

子网掩码是另外一种划分网络号与主机号的形式。（子网掩码为1的位数就是网络号的位数）

将子网掩码和IP地址按位计算AND，就可以得到网络号

更重要的我们要通过子网掩码进行**划分子网**

子网划分实际上是将**主机地址分成了两个部分：子网网络地址和子网主机地址**

**子网划分的优点**

1. 有效利用IP地址，不浪费IP地址
2. 限定了广播的传播，通过子网隔离用户，保证了网络的安全



### TCP与UDP的区别

**TCP与UDP都位于网络模型中的传输层，负责传输应用层产生的数据**

1. 最基础的，TCP是**面向连接的**、**可靠的**、**有状态**的传输协议，而UDP是**无连接的，不可靠、无状态**的传输协议。TCP提供可靠的服务，先建立三次握手连接，支持差错检验，拥塞控制等实现不丢失、不重复、不失序的数据传输；UDP没有三次握手的连接建立，尽最大努力可靠交付交付
2. TCP是点对点的传输；UDP可以一对多，多对多的传输
3. TCP对系统资源要求较多，UDP对系统资源要求较少
4. TCP允许的报文长度超过512字节，UDP报文的最大长度为512字节
5. TCP提供可靠的服务，应用在一些对安全性、数据传输量大的场景，如HTTP，FTP文件传输；而UDP工作效率高，应用在实时性要求高的场景，如视频，音频等多媒体

> 无状态的含义：指协议对于事务处理没有记忆能力，服务器不知道客户端的状态。



### TCP三次握手的过程

1. 首先，一开始客户端和服务器都是处于**CLOSED状态**。服务端主动监听某个端口，服务器处于LISTEN状态
2. 客户端会随机初始化序列号（client_isn），将这个序号置于TCP首部的序号字段中，同时把SYN标识位设为1，发送这个**SYN**报文给服务端，表示向服务器**发起连接**，该报文不包含应用层数据，之后客户端处于**SYN-SENT状态**
3. 服务器收到客户端的SYN报文后，服务端也随机初始化自己的序号（server_isn），将此序号填入TCP报文中序号字段中，其次在TCP首部的**确认应答号**字段中填入之前收到的SYN报文中的序列号**（client_isn）+ 1**，并且把**SYN和ACK标志位设为1**。最后把该报文发送给客户端，该报文也不含应用层数据，之后服务端处于**SYN-RCVD(同步收到 SYN-RECEIVED)状态**
4. 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，**ACK标识为1**，**确认应答号是client_isn + 1**，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，然后**客户端处于ESTABLISHED（建立）状态**
5. 服务器收到客户端的应答报文后，也**进入ESTABLISHED状态**。此时已完成建立，客户端和服务端就可以相互发送数据了。

> 第三次握手是可以携带数据的，前两次握手是不可以携带数据的



### 为什么TCP要三次握手，不是两次握手？不是四次握手？

首要原因是TCP为了**防止已经失效的连接报文突然又传到了服务端**，因而产生了错误。

client发送的第一个连接请求因为网络问题延时了，成为了一个已失效的报文段，但是server后续收到了这个已失效的，误认为client要建立新的连接，于是向client发送确认报文段，同意建立连接。如果不采用三次握手，那么只要server发出确认请求了，连接就建立了，而client不会理会server端，这样server端的**资源就白白浪费了**，而采用三次握手就能防止上述现象出现。

还有个原因是**TCP需要seq序列号来做可靠传输，需要双方同步ISN（初始seq序列号）**。当client发送携带初始序列号的SYN报文时，需要server回一个ACK应答报文，同理，server发送携带初始序号的SYN报文时，需要client的应答报文。这样一来一回，**两次往返，才能确保双方的初始序列号同步，确保了双方都有发送和确定的过程**。这样看来四次握手也可以实现，但由于server的应答报文和SYN报文**可以优化成一步**，这样节约资源，所以就成了三次握手

> 顺带一提的是：
>
> 两次握手更容易受到SYN Flood洪水攻击。
>
> 
>
> 三次握手的原则设计是防止旧复用链接的初始化导致问题，为了解决此问题，我们设计了`reset`这个特别的控制信号来处理。
>
> 如果接收中的 TCP 在一个未同步状态如 `SYN-SENT, SYN-RECEIVED`，它会返回 `reset` 给对方，对方又变成listen状态。



### TCP头部报文格式

**序列号**：在建立连接时生成一个**随机数作为其初始值**，通过SYN包传给接收端，每发一次数据，就累加一次该数据字节大小，用来**解决网络包乱序问题**

**确认应答号**：指下一次**期望**收到的数据的序列号，发送端收到这个确认应答号后可以认为在这个号之前的数据都被正常接收（累积回应）。用来**解决不丢包的问题**

**控制号**：

- ACK: 该位为1时，**确认应答号**有效，TCP规定除了最初建立连接时的SYN包之外该位必须设置为1
- RST: 该位为1时，表示TCP连接出现异常必须**强制断开连接**
- SYN: 该位为1时，表示希望建立连接，并在其**序列号**的字段进行序列号初始值的设定（建立连接的前两次握手）
- FIN:  该位为1时，表示今后不会再有数据发送，希望断开连接。当通信双方希望断开连接时，通信双方的主机之间就可以**相互交换FIN位为1的TCP报文**



### 详解一下四次挥手过程

1. 客服端打算关闭连接，此时会发送一个TCP首部FIN为1的报文，即**FIN报文**，此时客户端**进入FIN_WAIT_1状态**
2. 服务端收到该报文后，就向客户端发送**ACK应答报文**，接着服务端**进入CLOSED_WAIT状态**
3. 客户端收到ACK应答报文后，之后**进入FIN_WAIT_2状态**
4. 此时只是客户端向服务端断开了连接，但服务端还可以向客户端发送数据
5. 等待服务器处理完数据后，也向客户端发送**FIN报文**，之后服务端进入**LAST_ACK状态**
6. 客户端收到FIN报文后，**回应ACK应答报文**，**之后进入TIME_WAIT状态**
7. 服务器收到了ACK应答报文后，就进入了**CLOSED状态**，**至此服务端已经完成了连接的关闭**
8. 客户端在经过了2MSL一段时间后，就自动进入CLOSED状态，**至此客户端已经完成了连接的关闭**

> 挥手的过程中每个方向都需要一个FIN和一个ACK
>
> 只有主动关闭连接的一方，才有TIME_WAIT状态
>
> 为什么会有TIME_WAIT状态（和下面的等待2msl原因一样）？
>
> 1. 防止旧连接的数据包被使用相同端口的新连接正常接收，造成数据错乱
> 2. 保证连接的正确关闭



### 为什么挥手需要四次？

- 关闭连接时，客户端向服务端发送FIN报文，**仅仅代表客户端不再发送数据，但是还能接收数据**
- 服务器收到FIN报文后，先回一个ACK报文，**但服务端可能还有数据需要处理和发送**，等服务端不再发送数据时，才发送FIN报文

综上，服务端通常还需等待完数据的处理和发送，所以ACK报文和FIN报文会分开发，**从而比三次握手多了一次**



### 四次挥手会等待2msl，为什么？

首先理解到什么是MSL，MSL是**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

2msl的时间是从客户端**接收到FIN后发送ACK开始计时的**,如果最后的ACK应答报文丢失了，被动关闭方（服务器端）会**触发超时重发FIN报文**，另一方接收到这个超时重发的FIN后，就会重发ACK给被动关闭方，并重新计时，这段时间最久的话是2msl

这样就**确保了连接的关闭**

还有个原因，经过2msl时间，**足以让两方向上的数据包都被丢弃，使得原来连接的数据包在网络中自然消失，防止客户端正常接收过期的报文，产生数据错乱等严重的问题**



### Web安全之四大常见攻击

见已经整理了的MarkDown



### 应用层其他协议

**文件传送协议FTP**，是基于TCP的互联网上使用得最广泛的文件传送协议，使用的是客户服务器模式。

**简单文件传送协议TFTP**，是基于UDP（需要有自己的差错改正措施）的很小且容易实现的文件传送协议，使用的是客户服务器模式。

**远程终端协议TELNET**是简单的远程终端协议，也是互联网的正式标准，也是使用的是客户服务器模式。

**电子邮件的一些标准：**

- 发送邮件的协议：SMTP
- 读取邮件的协议：POP3和IMAP



### 让一个div盒子水平垂直居中的方法

1.grid方法

> Grid布局（网格布局）
>
> grid布局与flex布局有一定的相似性，都可以指定内部多个项目位置。Flex布局是轴线布局，只能指定“项目”针对轴线的位置，是一维布局。Grid布局则是将容器划分成“行”和“列”，产生单元格，然后指定“项目”所在的单元格，可以看做是二维布局

```css
.father{
    display:grid;
}

.son{
    justify-self:center;
    align-self:center;
}


也可以这么写
        body{
            background-color: turquoise;
            height: 600px;
            display: grid;
            justify-items: center;
            align-items: center;
            grid-template-columns: repeat(3,33.3%);
            grid-template-rows: repeat(3,200px);
        }

        .box{
            width: 200px;
            height: 200px;
            background-color: tomato;
            grid-row: 2/3;
            grid-column: 2/3;
        }
```

justify-items 容器中项目的水平对齐方式

align-items 容器中项目的垂直对齐方式

grid-template-row 容器划分行的格子大小

grid-template-columns 容器划分列的格子大小



grid-row 该项目放在第x根线后，第x根线前，行

grid-column 该项目放在第x根线后，第x根线前，列



2.absolute + 负margin

```css
.father{
	position:relavtive;
}

.son{
	position:absolute;
	left:50%;
	top:50%;
	margin-left:-50px;
	margin-right:-50px;
}
```

3.absolute + transform

对第二种方法的改良

```css
.father{
	position:relative;
}
.son{
	postioin:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
}
```

4.absolute + margin

这类方法的另一种变形

```css
.father{
	position:relative;
}

.son{
    position:absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin:auto;
}
```

5.flex布局

```css
.father{
    display:flex;
	justify-content:center;
    align-items:center;
}
```

6.margin + transform（特殊一点）

```css
.father{
	overflow:hidden;
    //也可以使用padding:1px; box-sizing:content-box;
}
.son{
	margin: 50% auto;
    transform:translateY(-50%);
}
或者
.son{
    margin: 0 auto;
    transform: translateY(250px);
}
需要计算一下
```

7.table-cell

```css
.father{
	display:table-cell;
    text-align:center;
    vertical-align:middle;
}
.son{
    display:inline-block;
}
```

8.inline-block + vertical-align

```css
.father{
    text-align:center;
    line-height:300px;
}
.son{
    display:inline-block;
    vertical-align:middle;
}
```

回答：

首先我们可以用grid布局，flex布局方式进行水平垂直居中。

还可以用绝对定位absolute和搭配（正负）margin，或者absolute搭配transform:translate

还有margin和transform的搭配（也有两种）

还有其他方法table-cell和inline-block + vertical-align（不懂 暂时不答）



### 关于margin的一些知识

margin的值就是基于参考线移动的数值。

margin的参考线分为两类

一类是top、left，它们以外元素作为参考线，另一类是right、bottom，它们以自身作为参考线。

- top负值就是以包含块(Containing block) 内容区域的上边或者上方相连元素 margin 的下边为参考线;
- left负值就是以包含块(Containing block) 内容区域的左边或者左方相连元素 margin 的右边为参考线;
- right负值就是以元素本身border的右边为参考线；
- bottom负值就是以元素本身border的下边为参考线

> 以上margin 包含块内容区域的相连元素不是看HTML结构中的元素，是实际上相邻的元素

margin的百分比是相对于包含块的宽度（注意⚠️ 无论top还是left，只与宽度相关）

> 官方定义：一个元素盒子的位置和大小有时相对于某个矩形来计算的，此矩形称为此元素的包含块。简写为：C.B.
> 有以下几种情况：
> 1、根元素所在的包含块是一个长方形，称为初始的包含块。
> 2、假如元素的position设为‘relative’或‘static’，包含块是由最近的父容器块的内容区边缘形成的。
> 3、假如元素的position设为‘fixed’，包含块是由所在的viewpoint或page area决定。
> 4、假如元素的position设为‘absolute’，包含块是由最近带有‘position’属性的祖先决定。

**负margin**

负margin就是，当margin-top、left为负值的时候与参考线的距离减少，当margin-right、bottom为负值的时候参考线就向左、上面移动。

实际应用：

1. 边框去重（一些排列的卡，可以用margin-left: -1px）进行去重

2. 在布局中使用，如圣杯布局，双飞翼布局

   

**外边距重叠**

也叫边距重叠，垂直外边距合并问题

块的上外边距(margin-top)或下外边距(margin-bottom)有时合并(折叠)为单个边距，其大小为单个边距的最大值(或如果它们相等，则仅为其中一个，还有为负时的特殊情况)

以下三种情况会出现外边距重叠：

1. 同一层元素上下相邻时，两个元素之间会发生外边距重叠

2. 没有内容将父元素和后代元素分开时，就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。

   > 这个问题发生的原因是**根据规范，一个盒子如果没有上补白(padding-top)和上边框(border-top)，那么这个盒子的上边距会和其内部文档流中的第一个子元素的上边距重叠**。

3. 空的块级元素，当一个块元素上边界margin-top 直接贴到元素下边界margin-bottom时也会发生边界折叠。

一些需要注意的地方：

- 上述情况的组合会产生更复杂的外边距折叠。
- 即使某一外边距为0，这些规则仍然适用。因此就算父元素的外边距是0，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。
- 如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和,；也就是说如果有-13px 8px 100px叠在一起，边界范围的技术就是 100px -13px的87px。
- 如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。

以上这些内容都是发生在Block-Level的元素，设定floating和absolutely positioned的元素完全不用担心边界重叠的问题。



**auto**

让浏览器自己选择一个合适的外边距。有时，在一些特殊情况下，该值可以使元素居中。

为什么auto只能水平居中，不能实现垂直居中？

因为默认的宽度规则是“适应于父级”规则（在水平方向上自动扩充）。即

margin-left+border-left-width+padding-left+width+padding-right+border-right-width+margin-right= width of containing block

对于绝对定位元素，有以下算式：

left+margin-left+border-left-width+padding-left+width+padding-right+border-right-width+margin-right+right= width of containing block

而auto的作用是：自动填充剩余空间， 所以给div设置margin：auto时，在水平方向上 margin会填充 div这一行中除了left+border-left-width+padding-left+width+padding-right+border-right-width+right的剩余的空间，当左右的margin都设置为auto时，会平分剩余空间，从而实现水平居中。那为什么没有按照上述同样的方式填充垂直方向上的剩余空间呢？

因为在垂直方向上，**块级元素不会自动扩充**，它的外部尺寸没有自动充满父元素，也没有剩余空间可说。所以margin：auto不能实现垂直居中。

但是

**当一个绝对定位元素，其对立定位方向属性同时有具体定位数值的时候，流体特性就发生了**。

**具有流体特性绝对定位元素的margin:auto的填充规则和普通流体元素一模一样**：

如果一侧定值，一侧auto，auto为剩余空间大小；

如果两侧均是auto, 则平分剩余空间

因为此时.son这个元素的尺寸表现为“格式化宽度和格式化高度”。即.son**这个元素的尺寸自动填充父级元素的可用尺寸**。

**总结**：通过position:absolute 和 top:0 bottom:0将元素设为流体特性的元素，这样该元素可自动填充父级元素的可用尺寸。

**格式化宽度**：格式化宽度仅出现在“绝对定位模型中”，也就是出现在position属性值为absolute或fixed的元素中。

对于非替换元素，当left/right或top/bottom对立方位的属性值同时存在时，元素的宽度表现为“格式化宽度”，其宽度大小相对于最近的具有定位特性的祖先元素计算。

“格式化宽度”具有完全的流动性，也就是margin、border、padding、content内容区域同样会自动分配水平和垂直空间。



### 关于position

**定位类型**

- **定位元素（positioned element）**是其[计算后](https://developer.mozilla.org/zh-CN/docs/Web/CSS/computed_value)位置属性为 `relative`, `absolute`, `fixed `或 `sticky` 的一个元素（换句话说，除`static`以外的任何值）。
- **相对定位元素（relatively positioned element）**是[计算后](https://developer.mozilla.org/zh-CN/docs/Web/CSS/computed_value)位置属性为 `relative `的元素。
- **绝对定位元素（absolutely positioned element）**是[计算后](https://developer.mozilla.org/zh-CN/docs/Web/CSS/computed_value)位置属性为 `absolute` 或 `fixed` 的元素。
- **粘性定位元素（stickily positioned element）**是[计算后](https://developer.mozilla.org/zh-CN/docs/Web/CSS/computed_value)位置属性为 `sticky` 的元素。

共五种取值

- `static`

  该关键字指定元素使用**正常的布局行为**，即元素在文档常规流中当前的布局位置。此时 `top`, `right`, `bottom`, `left` 和 `z-index `属性无效

- `relative`

  该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。

  > **`"position:relative"`不会导致元素脱离文档流**。
  >
  > 当元素是浮动，绝对定位或者根元素时，元素被称为"流外元素"，否则被称为"流内元素"。

- `absolute`

  元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。**绝对定位的元素可以设置外边距（margins），且不会与其他边距合并**。

- `fixed`

  元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。`fixed` 属性会创建新的层叠上下文。**当元素祖先的 `transform`, `perspective` 或 `filter` 属性非 `none` 时，容器由视口改为该祖先。**

- `sticky`

  元素根据正常文档流进行定位，然后相对它的*最近滚动祖先（nearest scrolling ancestor）*和 [containing block](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block) (最近块级祖先 nearest block-level ancestor)，包括table-related元素，基于`top`, `right`, `bottom`, 和 `left`的值进行偏移。偏移值不会影响任何其他元素的位置。

  该值总是创建一个新的[层叠上下文（stacking context](https://developer.mozilla.org/en/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)）。注意，一个sticky元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的`overflow` 是 `hidden`, `scroll`, `auto`, 或 `overlay`时），即便这个祖先不是最近的真实可滚动祖先。这有效地抑制了任何“sticky”行为（详情见[Github issue on W3C CSSWG](https://github.com/w3c/csswg-drafts/issues/865)）。

**一些相关的百分比**

**宽高百分比**

非绝对定位元素：

　非绝对定位元素的宽高百分比，是根据父元素的contentbox宽高来计算的；

　所谓content box就是：不包括padding的宽高来计算；

绝对定位元素：

　绝对定位元素的宽高百分比，是根据最近的position不为static的祖先元素（包含块）的paddingbox宽高来计算的；

　所谓padding box就是：包括padding的宽高来计算；

**定位百分比**

首先top（bottom）、 left（right）的百分比的相对值分别是相对于包含块的高度、宽度的。

相对定位元素

​	left,top,right,bottom百分比都是根据包含块content box 宽高来计算的（已自己认证）

绝对定位元素

​	left,top,right,bottom根据包含块的padding box宽高来计算的

​	如果fixed定位造成的绝对定位，那么一般情况下包含块就是视口

> 1. height, top, bottom根据其containing block的`height`进行计算, 如果该`height`没有指定(根据内容自适应), 那么计算值为0
>
> 2. width, left, right, padding, margin根据其containing block的`width`进行计算
>
> 3. transform - translate, translateX, translateY, 根据__自身元素__的实际**宽度高度**计算
>
> 4. background:
>
>    4.1 background-position根据__自身元素(不是containing block)__的宽高计算
>
>    4.2 background-size根据图片的大小进行计算. 需要注意的时, 当使用单个百分比(比如`background-size: 50%;`)计算时, height会隐式设为`auto`, 当其height计算出来的值大于容器的高度时, 超出部分会隐藏. 如果需要全部显示, 需要明确设置宽和高的值(比如, `background-size: 50% 50%;`)
>
> https://segmentfault.com/a/1190000014406904

百分比总结：除了padding和margin是参考包含块的宽度，其他的该参考宽度参考宽度，该参考高度参考高度，postion是参考padding bo x，而非绝对定位参考content box	(fix算绝对定位吗？)



### 为什么要清除浮动？

由于父盒子很多情况下不方便赋值高度，但子盒子浮动又不占有位置，最后父盒子高度就为0，就会影响下面的标准流盒子，影响整个页面布局

清除浮动本质？**本质是清除浮动元素脱离标准流造成的影响**

清除浮动的策略是？闭合浮动，只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子

**有哪些方法？**

1. **额外标签法**。末尾的新标签添加clear:both，且必须是块级元素。缺点：添加许多无意义的标签，结构化比较差。不常用
2. 给父元素**添加overflow**。缺点：无法显示溢出的部分
3. :after伪元素法。在after里添加clear:both，缺点：需要照顾低版本浏览器
4. 双伪元素清楚浮动。代码更简洁，但也需要照顾低版本浏览器

（3、4也被称为.clearfix方法，相对前两个是比较好的方法）



### CSS属性书写顺序

建议遵循以下顺序：

1. 布局定位属性
2. 自身属性
3. 文本属性
4. 其他属性



### 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景

从结构上来讲：

- display:none **会**让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击
- visibility:hidden**不会**让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击
- opacity:0 **不会**让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击(透明度)
- （渲染树？）

从继承上来讲：

- display:none是**非继承属性**，子孙结点的消失是由于该元素从渲染数消失造成的，通过修改子孙结点属性仍无法显示
- visibility:hidden是**继承属性**，子孙节点消失由于继承了hidden，通过设置visibility: visible可以让子孙节点显式。
- opacity:0是**继承属性**，且子孙结点无法通过修改opacity来改变这个继承属性。父节点可以通过rgba间接设定opacity的值，这个不会向下继承；或者把opacity属性放到同级元素实现透明

从性能方面来讲：

- display:none修改元素会造成文档**回流**，性能消耗较大，读屏器不会读取display:none元素内容
- visibility:hidden修改元素只会造成元素本身**重绘**，性能消耗较少，读屏器会读取visibility:hidden元素内容
- opacity:0修改元素造成**重绘**，性能消耗较少，读屏器会读取opacity:0元素内容

共同特点：它们都能让元素不可见

参考文章：

- CSS魔法堂：display:none和visiblity:hidden的恩怨情仇 https://segmentfault.com/a/1190000016570003



### CSS：画一个三角形

等腰直角：宽高设置为0，只设置border宽度，且颜色设置为透明色，需要哪个朝向的三角形，就设置哪个朝向的颜色为需求颜色

中心交汇点到每一个边的距离就是每一个方向上border的宽度

需要其他类型的三角形，可以自定义修改border

```css
边长为3 4 5的三角形
.triangle{
            height: 0;
            width: 0;
            border-top:20px solid transparent;
            border-bottom:30px solid yellow;
            border-left:40px solid transparent;
            /* border-right:20px solid red; */
}
```



### CSS：画一个0.5px边框

详见0.5px边框.md



### CSS如何解决图片底部默认空白间隙

为什么会有空白间隙？因为行内块元素要和文字的基线对齐，文字会多出部分内容，哪怕没有文字，也会多出这点空隙

解决方法：

1. 给图片添加vertical-align，改变它与文字垂直对齐的方式，不让它与文字的基线对齐。
2. 把图片转换为块级元素，display:block;

提倡使用第一种，第二种可能会影响布局

> vertical-align只针对行内块和行内元素



### 溢出文本省略号显示

单行文本溢出显示省略号

```css
{
    /*先强制一行内显示文本 ,默认是normal自动换行*/
    white-space:nowrap;
    /*超出的部分隐藏*/
    overflow:hidden;
    /*文字用省略号代替超出的部分*/
    text-overflow:ellipsis;
}
```

多行文本溢出显示省略号（有较大的兼容性问题，适用于webKit浏览器）

```css
{
    overflow:hidden;
    text-overflow:ellipsis;
    /*弹性伸缩盒子模型显示*/
    display:-webkit-box;
    /*限制在一个块元素显示的文本的行数*/
    -webkit-line-clamp:2;
    /*设置或检索伸缩盒对象的子元素的排列方式*/
    -webkit-box-orient:vertical;
}
```

更推荐让后台人员写这个效果,	后台人员显示多少字，操作更简单。（感觉不是这样的）



### HTML5新特性

1.新增的带有语义化的标签：

1. header 头部
2. nav 导航
3. article 内容
4. section 定义文档某个取余（大号div标签）
5. aside 侧边栏
6. footer 尾部

2.新增的多媒体标签：

1. audio 音频 支持MP3 Wav Ogg格式 
2. video 视频 只支持MP4，WebM，Ogg格式

3.新增了input类型：email,url,date,number,tel,search,color......

4.新增的表单属性（写在input里面）

1. required表单内容不能为空
2. placeholder 表单提示信息
3. autofocus 自动聚焦
4. autocomplete 是否显示已经键入过的值
5. multiple 可多选文件



### CSS：块级元素与行内元素

块级元素：**块级元素一般当做容器使用，既可以容纳内联元素也可以容纳块级元素**

块级元素的特点有：

1. 块级元素既可以容纳内联元素也可以容纳块级元素。
2. 在默认情况下是独占一行的
3. 块级元素的大小是可以控制的，css可以通过设置width与height来设定高度和宽度。宽度的默认值就是它所在的容器的100%
4. 块级元素可以设置margin和padding属性
5. 块级元素对应属性display:block

常见的块级元素有：

1. div：主要用来进行框架布局
2. h1~h6：用来设置不同级别的标题
3. p：用来创建段落，会在其前后创建一些空白
4. hr：用来创建分割行
5. ol： 创建有序列表
6. ul：创建无序列表



内联元素：**任何不是块级元素的可见元素都是内联元素。内联元素只能够容纳文本或者内联元素**

内联元素的特点：

1. 内联元素只能够容纳文本或者内联元素
2. 默认情况下可以和其他内联元素在同一行
3. 默认情况下大小是不可控的
4. 内联元素可以产生代码换行和空格
5. 内联元素对应属性display:inline

常见的内联元素有：

1. strong：加粗强调
2. em：斜体强调
3. s：删除线
4. u：下划线
5. a：超链接
6. span：常用行级，可定义文档中的行内元素
7. img：图片
8. input：表单

> 内联元素的margin和padding属性:
>
> 水平方向的padding-left,padding-right,margin-left,margin- right都产生边距效果
>
> 但竖直方向的padding-top,padding-bottom,margin-top,margin-bottom却不会产生边距效果
>
> 
>
> display：inline-block 
>
> 可以让元素具有块级元素和行内元素的特性：既可以设置长宽，可以让padding和margin生效，又可以和其他行内元素并排。
>
> button就是行内块元素





### CSS3的新特性

**CSS3新增选择器**

1. **属性选择器**

   ```css
   input[value]{
   	xxxxxx
   }
   
   <input type="text" value="请输入用户名">
   <input type="text">
   
   E[att=val]
   E[att^=val]开头
   E[att$=val]结尾
   E[att*=val]包含
   ```

   类、属性、伪类的权重一样

2. **结构伪类选择器**

   ```css
   E:first-child{
   
   }
   还可以写成 ul li:first-child  ul里第一个li标签
   
   :last-child
   :nth-child(n) 第n个 n可以是数字，关键字，公式 even（偶数） odd（奇数） 如果n是公式,会从0开始累加，但第0个元素和超出元素的个数会被忽略掉，公式里的变量只能是n。
   :first-of-type 指定类型E的第一个
   :last-of-type
   :nth-of-type(n)
   
   nth-child还比较特殊，在特定情况下还选不出来指定的标签
   <section>
   	<p>
   	<div>
   </section>
   section div:nth-child(1)这时候选不出来，但nth-of-type就能选出来（观测顺序不一样）
   使用nth-child，会把所有子元素排序，必须是子元素和顺序都匹配上才能选出来，否则选不出来。在上面的案例中就是必须是div的一个元素，而且必须是div标签，而第一个是p标签，所以匹配不了，选不出来。
   而nth-of-type是排列指定元素的序号，section div:nth-of-type(1)就能匹配子元素的第一个div
   ```

   

3. **伪元素选择器**

   可以帮助我们利用CSS新建标签（是行内元素），而不需要HTML标签，可以简化HTML结构（CSS3采用双冒号）

   新建的这个元素在文档树里是找不到的，所以被称为伪元素

   权重和标签选择器一样

   必须有content属性
   
4. 滤镜filter

   如果父元素使用filter，且其子元素有position:fixed的定位元素，那么该定位元素的视口改为父元素

   https://zhuanlan.zhihu.com/p/139687521

5. 渐变颜色linear-gradient

6. 动画transform transition animation

7. Font-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。

8. Box-shadow border-image flex,grid布局等等等



**CSS3动画**

详见CSS动画.md

**其他特性**

让图片变模糊：滤镜filter CSS属性将模糊或颜色偏移等图形效果应用于元素 如 filter:blur(5px)

calc函数，此CSS函数能在声明CSS属性时执行一些计算，+ - * /都可以,运算符前后都需要保留一个空格，任何长度值都可以使用calc()函数进行计算

> calc相比less的运算，有一些限制：
>
> - 运算符前后必须要有空格（*,/不用，但考虑统一性还是要加上），编写麻烦
> - 对运算值有限制，乘法的话必须至少有一个是numbe，除法右边的数必须是number
> - less的运算更强大，甚至可以对颜色进行运算（#22448 / 2）,而calc不行



### Less 到底为 CSS 添加了什么功能？

1. 变量(Variables) 可以自定义变量，用@创建，使用
2. 混合(Mixins) 将一组属性从一个规则集包含（或混入）到另一个规则集的方法，这样另一个规则集也有这一组属性了，使用方法是类名加()，也可是#id()
3. 嵌套(Nesting) 可以将CSS写成像html一样的组织层级结构,这样代码更规范简洁，也不怕变量污染
4. 运算(Operations) 算术运算符 `+`、`-`、`*`、`/` 可以对任何数字、颜色或变量进行运算。如果可能的话，算术运算符在加、减或比较之前会进行单位换算。计算的结果以最左侧操作数的单位类型为准。如果单位换算无效或失去意义，则忽略单位
5. 导入(Importing) 通过@import导入less文件，此文件中的所有变量就可以全部使用了
6. 映射(Maps)  可以将混合（mixins）和规则集（rulesets）作为一组值的映射（map）使用，就像调用对象的属性一样使用
7. 作用域(Scope) 首先在本地查找变量和混合（mixins），如果找不到，则从“父”级作用域继承



### CSS选择器权重

CSS基本选择器有类选择器、属性选择器和ID选择器。

CSS 的选择器有很多，常用的有 [元素选择器](https://blog.csdn.net/qq_42351033/article/details/103225005)、[id 选择器](https://blog.csdn.net/qq_42351033/article/details/103225736)、[class 选择器](https://blog.csdn.net/qq_42351033/article/details/103229023)、[后代选择器](https://blog.csdn.net/qq_42351033/article/details/103244891)、[子代选择器](https://blog.csdn.net/qq_42351033/article/details/103246217)、[并集选择器](https://blog.csdn.net/qq_42351033/article/details/103246871)、[交集选择器](https://blog.csdn.net/qq_42351033/article/details/103280516)、[伪类选择器](https://blog.csdn.net/qq_42351033/article/details/103281108#font_color3399EA_size4stronginput_strongfont_93)、[通配符选择器](https://blog.csdn.net/qq_42351033/article/details/103291503) 等。

CSS选择器的权重预示着CSS选择器样式渲染的先后顺序，元素样式渲染时，权重高的选择器样式会覆盖权重低的选择器样式。

通常将权重分为4个等级，可用0.0.0.0来表示这4个等级。

！important关键字优先级最高。

注意：！important井非选择器，而是针对选择器内的单一样式设置的。当然，不同选择器内应用 ！important的权重也是不一样的，例如，在id选择器内的！important关键字权重要高于类选择器内的 ！important关键字权重，即下面所说的选择器权重组合。

- 内联样式（非元素器）的优先级可看成1.0.0.0
- ID选择器的优先级为0.1.0.0
- 类属性选择器、属性选择器、伪类的优先级为0.0.1.0
- 元素选择器、伪元素选择器的优先级为0.0.0.1
- 通配符选择器对特殊性没有任何贡献值

当把选择器组合使用的时候，相应的层级权重也会递增，例如# id .class的权重为0.1.1.0



> 伪类如 :first-child, :nth-last-child(n), :hover等等
>
> 伪元素选择器如::after, ::before等等



注意：

- 当两个选择器组合权重不一样时，用权重高的选择器，不在意代码中谁上谁下
- 当两个选择器组合权重一样时，看代码中谁上谁下
- 类 ID 和 ID 类的组合权重是一样的
- !important的权重比内联样式还要高
- 选择器组合是没有父级优于子级这一说法的，比如

```html
  <style>
    #box .sp {
      color: green;
    }

    #qqqq .sp {
      color: red;
    }
  </style>
</head>

<body>
  <div id="box">
    <p class="ap" id="qqqq">
      <span class="sp" id="sqqq">text</span>
    </p>
  </div>
</body>
```

组合优先级一样高，red在下面，文字呈现为红色

参考文章：

- 【前端面试题】02—59道CSS面试题(附答案)https://blog.csdn.net/snsHL9db69ccu1aIKl9r/article/details/114297605
- 【CSS】什么是 CSS 中的子代选择器https://blog.csdn.net/qq_42351033/article/details/103246217





### CSS line-height = height为什么能让文字居中

首先来说，line-height是行高，指的是文本行之间基线的垂直距离。

基线是什么？在文本行中，从上到下依次是**半行距，顶线，中线，基线，底线，半行距**。基线所在的位置是除了j g f这类的小写字母的末端，像英文四行格子的第三行

又因为文本间的半行距是相等的，所以行高又可以看成是一行文本的上半行距到下半行距

font-size的大小就是从**顶线到底线**的距离。

在没有给div盒子设置height的时候，div的高度随line-height的变化而变换，且文字居中

当div盒子有高度时，如果line-height = height，文字就是在中间显示；如果大于，文字偏下；如果小于，文字偏上



### CSS3盒子模型

所有的HTML元素在页面上都可以看做是一个盒子，一个盒子包括:外边距margin，边框border，内边距padding和元素实际内容content

CSS3可以通过设置box-sizing来指定盒子模型，有2个值，content-box和border-box，**这样我们计算盒子大小的方式就进行了改变**

- `content-box` 是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。(默认)
- `border-box` 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px，那么这100px会包含它的border和padding，内容区的实际宽度是width减去(border + padding)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。（ie盒模型，也是怪异盒模型）

如果盒子模型我们改为了box-sizing:border-box，那么padding和border就不会撑大盒子（前提padding和border不会超过width宽度）

与盒模型相关的属性：border-image、box-shadow



### CSS中的BFC和IFC

什么是FC？ FC是Fomatting Context，是页面中的一块渲染区域，并且有一套渲染规则。

BFC和IFC都是常见的FC

**BFC**是Block FC  也叫块级格式化上下文

BFC就是一个页面上隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也是如此

一个元素如何触发产生BFC呢？

1. 根元素本身就是BFC
2. float属性不为none;
3. position为absolute或fixed
4. display为inline-block，table-cell,table-caption,flex
5. overflow不为visible

**BFC布局规则**

1. 内部盒子会在**垂直方向**一个一个的摆放
2. 盒子垂直方向的距离由margin决定，**属于同一个BFC的两个相邻BOX的上下margin会发送重叠**（也就是外边距塌陷）
3. 每个元素的左边与包含的盒子的左边相接触，即使存在浮动也是如此
4. BFC区域不会和float重叠
5. 计算BFC高度时，**浮动元素也参与其中**

能解决什么问题：**能完成自适应的两栏布局，清除内部浮动引起的高度塌陷，解决外边距塌陷问题**



**IFC**是Inline FC，也被叫为内联格式化上下文

一个元素如何触发产生IFC呢？

IFC由不包含块级盒的块容器盒子建立（块容器盒中只有内联级盒子）

**IFC布局规则**

1. 盒子是一个接一个水平摆放的
2. 摆放这些框，它们的水平方向的margin,border,padding所占的空间都会被计算在内
3. 行盒的高度由内部最高的inline box决定
4. 垂直方向可以由vertical-align设置文本基线
5. 当内部盒子太多，会折行变成两个或多个line box，在垂直方向无间隔堆叠，但不能重叠
6. 浮动后IFC内部的浮动元素宽高参与IFC的line-box宽高计算并且从换行后的行开始排列

能影响IFC内部布局的CSS属性：font-size,line-height,height,vertical-align



### CSS常见布局

**两列布局**（可以根据具体要求改变代码）：

利用浮动实现

```html
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        .main{
            width: 95%;
            margin: 0 auto;
        }

        .left{
            float: left;
            width: 200px;
            height: 600px;
            background-color: red;
            margin-right: 20px;
        }

        .right{
            display: flex;//如果里面没有溢出的元素，也可以使用overflow 目的是构建BFC，BFC区域不会和float重叠
            //这里自适应宽度，如果是inline-box，就不能自适应宽度
            height: 600px;
            background-color: blue;
        }
    </style>

<body>
    <div class="main">
        <div class="left"></div>
        <div class="right"></div>
    </div>
</body>
```

利用flex布局实现：

```html
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        .main{
            width: 95%;
            margin: 0 auto;
            display: flex;
        }

        .left{
            width: 200px;
            height: 600px;
            background-color: red;
            margin-right: 20px;
        }

        .right{
            flex: auto;
            height: 600px;
            background-color: blue;
        }
    </style>
```

**三列布局**：

使用定位

```html
   <style>
        * {
            padding: 0;
            margin: 0;
        }

        .main {
            width: 95%;
            margin-left: auto;
            margin-right: auto;
            /* 左右居中 */
            height: 300px;
            /* *zoom: 1; */
            position: relative;
        }


        /*左边固定元素定位*/
        .left {
            position: absolute;
            top: 0;
            left: 0;
            width: 200px;
            height: 100%;
            background-color: cyan;
        }


        /* 中间自适应，设置的margin左右距离为左右二边固定宽度元素的 大小*/
        .center-fa {
            width: 100%;
            height: 100%;
        }

        .center {
            height: 100%;
            margin-left: 210px;
            margin-right: 210px;
            background-color: chocolate;
        }


        .right {
            position: absolute;
            top: 0;
            right: 0;
            width: 200px;
            height: 100%;
            background-color: rgb(255, 0, 221);
        }
    </style>

<div class="main">
        <div class="left"></div>
        <div class="center-fa"> <div class="center"></div></div>
        <div class="right"></div>
    </div>
```

使用flex布局

```html
<style>
        * {
            padding: 0;
            margin: 0;
        }

        .main {
            width: 95%;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            display: flex;
            justify-content:space-between;
        }

        .left {
            width: 200px;
            height: 100%;
            background-color: cyan;
        }

        .center {
            flex:auto;
            height: 100%;
            margin-left: 20px;
            margin-right: 20px;
            background-color: chocolate;
        }

        .right {
            width: 200px;
            height: 100%;
            background-color: rgb(255, 0, 221);
        }
    </style>

    <div class="main">
        <div class="left"></div>
        <div class="center"></div>
        <div class="right"></div>
    </div>
```

**圣杯布局**

> 要求：
>
> - header和footer各自占领屏幕所有宽度，高度固定。
> - 中间的container是一个三栏布局。
> - 三栏布局两侧宽度固定不变，中间部分自动填充整个区域。
> - 中间部分的高度是三栏中最高的区域的高度。
> - 中间部分在DOM结构上优先，以便先行渲染

实现方法：浮动  padding 定位 margin

**双飞翼布局**

>  [圣杯布局](https://blog.csdn.net/qq_38128179/article/details/86533976)和[双飞翼布局](https://blog.csdn.net/qq_38128179/article/details/86542447)达到的效果基本相同，都是**侧边两栏宽度固定，中间栏宽度自适应。**主要的不同之处就是在解决中间部分被挡住的问题时，采取的解决办法不一样，圣杯布局是在父元素上设置了padding-left和padding-right，在给左右两边的内容设置position为relative，通过左移和右移来使得左右两边的内容得以很好的展现，而双飞翼则是在center这个div中再加了一个div来放置内容，在给这个新的div设置margin-left和margin-right 。

> 共同要求：
>
> - 两侧宽度固定，中间宽度自适应
> - 中间部分在DOM结构上优先，以便先行渲染
> - 允许三列中的任意一列成为最高列
> - 只需要使用一个额外的div标签

实现方法：浮动 margin

这一类的布局的还有其他的实现方法

1. flex 定位（absolute定位的元素不参与flex布局，但这一特性可能不兼容，relative不受影响，不知道是哪方面的影响）
2. flex order min-width



### 关于Flex布局

面试时被问到的一些地方

**flex属性是哪些属性的集合简写？默认值是什么？**

flex属性是flex-grow,flex-shrink,flex-basis的简写，默认值为0 1 auto   后两个属性可选。

该属性有两个快捷值：auto(1 1 auto)和 none(0 0 auto)

这三个属性分别掌管项目的放大比例，缩小比例和项目占据的固定空间

- flex-grow: 默认为0，**即如果存在了剩余空间，也不放大**。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
- flex-shrink: 默认为1，**即如果空间不足，该项目将缩小**。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。
- flex-basis: **定义了在分配多余空间之前，项目占据的主轴空间**（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。

> 注意：
>
> 单独写还无效？
>
> flex-grow/flex-shrink详解
>
> https://zhuanlan.zhihu.com/p/24372279：grow:也就是说，当所有的元素的 flex-grow 之和小于 1 的时候，剩余空间不会全部分配给各个元素。shrink:此时，并不会收缩所有的空间，而只会收缩 flex-shrink 之和相对于 1 的比例的空间。
>
> **flex-basis与width/flex项目尺寸**
>
> flex-basis的默认值是auto，表示自动，也就是完全根据子列表项自身尺寸渲染。
>
> 在Flex布局中，一个Flex子项的宽度是由元素自身尺寸，**flex-basis**设置的基础尺寸，以及外部填充（flex-grow）或收缩（flex-shrink）规则**3者共同决定**的。
>
> 自身尺寸渲染优先级如下：
>
> ```
> min-width > || max-width > width > Content Size
> ```
>
> 同时，**在Flex布局中，flex-basis优先级是比width高的**（可以理解为覆盖）
>
> 在不同的浏览器中会存在一些不同的情况
>
> flex-basis还支持关键字，但似乎chrome浏览器不支持
>
> https://www.mybj123.com/5233.html
>
> https://www.zhangxinxu.com/wordpress/2019/12/css-flex-basis/



### 手写一个Promise.all Promise.race

考虑了可迭代对象，包括Array,String,Map,Set

```javascript
	function myPromiseAll(iterableParam){
        if(typeof iterableParam[Symbol.iterator] !== 'function'){
            throw new TypeError('参数必须是可迭代对象');       
        }
        const resArr = [];
        let count = 0;
        const length = iterableParam.length || iterableParam.size;
        return new Promise((resolve,reject) => {
            let i = 0;
            for(let item of iterableParam){
                let index = i++;
                Promise.resolve(item).then(
                    (data) => {
                        resArr[index] = data;
                        count++;
                        if(count === length){
                            resolve(resArr);
                        }
                    }
                ).catch(
                    (err) => {
                        reject(err);
                    }
                );
            };
        });
    }

    function myPromiseRace(iterableParam){
        if(typeof iterableParam[Symbol.iterator] !== 'function'){
            throw new TypeError('参数必须是可迭代对象');
        }

        return new Promise((resolve,reject) => {
            for(let item of iterableParam ){
                Promise.resolve(item).then(
                    (data) => {
                        resolve(data);
                    }
                ).catch(
                    (err) => {
                        reject(err);
                    }
                );
            };
        });
    }
```



### 理解一下Promise对象

新建一个Promise对象，参数会是一个回调函数，回调函数会携带两个参数resolve和reject，此时这个两个参数还没什么意义

在这个回调函数里可以写各种逻辑的代码，同步的，异步的都可以，此时把刚刚传入的resolve和reject当成函数来使用，resolve当成逻辑成功时的return，reject当成逻辑失败时的return，传入的这两个`return`的参数也是自定的。

其实当没执行到resolve和reject的时候，Promise是一个未确定的状态pending，当执行到某一个`return`后Promise会根据到底是resolve还是reject来选择变成是fulfilled或者说是rejected状态，而PromiseResult（在浏览器里看见的）就是传入这两个`return`函数的参数

> 但这个return还是不一样的，这个return只是决定了promise的状态，其他的代码还是要执行的
>
> 也就是说
>
> 无论是先resolve或reject ，并不会像return一样停止执行代码，所有的都会执行，如果p后面有then/catch，那么执行到resolve/reject会立即执行then/catch，但并不会影响Promise内其余代码执行
>
>  如果有两个resolve/reject，那么第二个运行到的不会执行

重点就是then方法

如果不调用这个Promise的then方法，这个两个`return`函数就没啥用，此时我们要把早就定义好的resolve和reject变成真正的函数，也就是传入then方法的第一二个回调函数，或者只给then传一个函数，另一个给catch，传入then或者catch里面的参数（也就是回调函数）的参数就是刚刚`return`的返回值，也就是说then方法里面的回调函数顶替了resolve，catch里面的回调函数顶替了reject



### 理解一下Promise.resolve与Promise.reject

**Promise.resolve**

给定一个参数，返回Promise对象

首先说参数：分为四类（对Promise存疑）

一类是空，什么都不传，返回fulfill状态，PromiseResult是undefined

一类是普通的没有then方法的参数，此时返回的Promise是成功态，PromiseResult是该参数（无论是对象还是基本类型）

一类是 本身不是Promise但有then方法的参数，如果then方法没有参数，或者有参数没有当成函数执行，**那么返回的是pending undifened**；如果有两个函数（onFulfill onReject），一个就不用考虑那么多

- Fulfill 在最前面的话，状态就是fulfill，参数是then函数里面的onFulfill里面的参数
- 如果抛出异常或onReject在前面的话，必须在resolve后面跟有处理失败状态的回调函数（then的第二个参数或者catch），否则报错，此时返回的就是then处理过的新的Promise对象了

>   都会执行then里面的其他代码

一类是 传入Promise对象，则原样返回（没有深入研究）



**Promise.reject**

**调用后除了fuifill状态，其他必须跟catch捕捉错误，否则会报错**

给定一个参数，返回Promise对象

首先说参数：

如果是普通的没有then方法的参数时，reject状态和（数据是）数据本身

如果是普通异常，reject状态和（数据是）异常本身

（不正常的情况）如果传入有then方法但没有参数之类的话，**此时返回的Promise是失败态，PromiseResult是该参数（无论是对象还是基本类型）**，但会报错（没有捕捉），如果加上捕捉，不会报错但只会返回pending undifiened且不会执行then和catch的回调

（正常的情况）但then如果有两个函数（onFulfill onReject） 

- **Fulfill 在最前面的话，状态就是fulfill，参数是then函数里面的onFulfill里面的参数！！！很重要**

- 如果抛出异常或onReject在前面的话，必须在resolve后面跟有处理失败状态的回调函数（then的第二个参数或者catch），否则报错，此时返回的就是then处理过的新的Promise对象了

- **这里和resolve的处理方法一样！！！！**

  会执行自身的then

方法可能太复杂，没有统一的规律，日后再理解



### 改变Promise的状态有几种方法

1. resolve(value) : 如果当前状态是pending就会变为resolved
2. reject(reason) : 如果当前状态是pending就会变为rejected
3. 抛异常： 如果当前是pending就会变为rejected

当Promise的状态确定了就不会再改变



### ES6的Map和Set

不能像数组或者对象一样访问（不能通过. 或 []访问），只能通过方法来访问，因为那样访问的是对象的属性，而Map和Set的值都不是属性存储的，存在这个*[[Entries]]*东西里面

**Map**，结构和对象相似，也是键值对的形式存储。

但是和对象很很多地方不同

1. Map的键可以是任意值，甚至可以是NaN；Object只能是字符串或者Symbol
2. Map的key是有序的；Object的key是无序的
3. Map是可以迭代的；而Object是不可以迭代的（Map迭代的item是数组形式的键值对）
4. Map在频繁增删键值的场景下表现更好，而Object不行

可以使用instanceof和toString来进行判断类型

使用

```javascript
let a = new Map();
let b = new Map([[1,2],[3,4]])或者是一个可迭代对象（这里数组迭代出来就是一个个数组）

a.set(key,value)//任意类型
a.get(key)//返回对应值，没有就undifined
b.delete(key)//存在元素返回true，不存在返回false
b.size//多少个键值对
b.has(key)//是否存在，返回布尔值

可以使用...进行扩展，扩展出来是一个个长度为二的数组，也是因为这个特性，可以对多个Map或数组进行合并

//使用for of遍历
for(let i of b) 每一个i是个长度为二的数组
//使用forEach遍历
b.forEach(function(value, key) {
  console.log(key + " = " + value);
})
一个参数是value 第二个参数是key 注意！！！

如果value或者key没有引用类型，则可以直接使用new Map(另一个Map)进行拷贝，是深拷贝
但如果value或者key有引用类型，就要对其进行处理，不然拷贝过来的是引用地址
```

**Set**，允许你存储任何类型的**唯一值**，无论是原始值还是对象引用，可以**按照插入的顺序迭代**它的元素

`NaN`和`undefined`都可以被存储在Set 中， `NaN`之间被视为相同的值（NaN被认为是相同的，尽管 NaN !== NaN）

一些情况下可以用来对数组的去重

没有像数组一样的索引调用，也没有像Map一样的用get调用，单独调用一个值出来好像只能遍历

可以用instanceof 和 toString来进行类型判断

```javascript
let a = new Set();
let b = new Set([1,2,3,44,4,4,5]);或者是一个可迭代对象（这里数组迭代出来就是一个个数组）,不重复的添加到Set里面

大部分和Map类似
a.add(val)//返回该Set对象
let setIter = b.values();//返回新的迭代器对象，
setIter.next().value //1

也可以用扩展运算符...扩展，得出的是一个个值

for of的item是values

b.forEach(callback,[,thisArg])
callback必选
为集合中每个元素执行的回调函数，该函数接收三个参数：
	currentValue, currentKey可选
	currentValue 是正在被操作的元素。并且由于集合没有索引，所以 currentKey 也表示这个正在被操作的元素。
set可选 调用当前 forEach 方法的集合对象
thisArg可选 回调函数执行过程中的 this 值。

关于拷贝，和Map的情况一样
```



### 获取URL中的参数

```javascript
function getUrlParam(sUrl, sKey) {
    sUrl = sUrl.slice(sUrl.indexOf('?') + 1);
    var reg = /(\w+)=(\w+)/g
    var res_obj = {};
    sUrl.replace(reg,function(str,g1,g2){
        if(res_obj[g1] !== void 0){
            res_obj[g1] = [].concat(res_obj[g1],g2);
        }else{
            res_obj[g1] = g2;
        }
    });
    if(sKey === void 0){
        return res_obj;
    }else{
        return res_obj[sKey] || '';
    }
}
```



### 正则表达式

限定符

1. *表示0次或多次
2. +表示1次或多次
3. ?表示0次或1次
4. {6}6次
5. {2,6}2-6次
6. {6,}6次以上

或运算符

1. a|b 匹配a或b

元字符

1. \d 数字 \D 非数字
2. \w 单词字符（英文、数字、下划线） \W 非单词字符
3. \s 匹配空白符（包含换行和Tab） \S非空白符
4. . 任意字符（除了换行符）
5. ^行首 $行尾

转义符号: \

标志：

1. i 忽略大小写
2. g 全局匹配
3. m 多行修饰符：锚点元字符 `^` `$` 工作范围在每行的起始

JS创建正则表达式:

1.  var a = new RegExp(/表达式/)
2.  var a = /表达式/

> RegExp.test(str) 返回布尔值
>
> str.replace(regexp/str,replacement/callback) 
>
> callback(str,p1,p2...,offset,string,NameCaptureGroup)
>
> 第一个参数是匹配到的字符串
>
> p1,p2..表示正则表达式里面的括号
>
> offset表示偏移量
>
> string表示原字符串
>
> NameCaptureGroup命名组匹配的对象 不知道有什么用，普通打印出来的是undifined



### offset,client,scroll区别及联系

首先 offset所涉及的Widht和Height是包括了border,padding和实际内容的

而client所涉及的Widht和Height只包括了padding和实际内容

而scroll所涉及的Widht和Height只包括了实际内容

三者所返回的数值都不带单位，一个比一个包含的内容少，且会涉及清空浏览器渲染队列



其次三者涉及的Top和Left也是不一样的

offset涉及的Top，是元素距离带有定位的父元素或者最近的 `table,``td,``th,``body`元素上方的距离，left同理

而client涉及的Top，是元素上边框的大小，left同理

而scroll涉及的Top，元素顶部到元素可视区域顶部的像素距离（可读写）,left同理

三者区别还是很大的，特别是client与另外两个的区别



### innerHTML和createElement的效率测试

不同浏览器下，innerHTML的效率要比createElement效率高，但这是在innerHTML采用数组拼接的方法的情况，如果采用`+`拼接字符串，效率就会大幅下降

> 还有种动态创建元素的方法
>
> document.write('<div></div>')
>
> 它是把内容直接写入页面的内容流，当文档流执行完毕再执行这个函数的时候，会把原本的内容替换掉，引起页面回流





### 说一些常用的BOM对象

首先BOM是浏览器对象

常用的对象：location对象，history对象，Navigator对象

**location对象**

1. location.href 返回或设置当前文档的URL
2. location.search 返回URL中的查询字符串部分
3. location.hash 返回URL中#的部分
4. location.host 返回URL中的域名部分
5. location.assign 设置当前文档的URL
6. location.replace() 设置当前文档的URL，并且在**history对象**的地址列表中移除这个URL location.replace(newUrl)
7. location.reload() 重载当前页面

**history对象**

1. history.go() 前进或后腿指定的页面数（正数或负数，0是刷新页面）
2. history.back() -- 后退一页
3. history.forward() -- 前进一页
4. history.pushState()
5. history.repalceState()
5. history.popstate()

**Navigator对象**

1. navigator.userAgent 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)也就是HTTP头部的user-agent字段的信息
2. navigator.cookieEnabled 返回浏览器是否支持(启用)cookie



### export和export default的区别

`export`命令对外接口是**有名称的**且`import`命令从模块导入的变量名与**被导入模块对外接口的名称相同**,可以用as来进行更改名字，可以export多个变量，或者用一个export {param1,param2}，接收时也是{param1,param2}

```javascript
export function multiply(x, y) {
  return x * y;
};

import {multiply} from './profile.js'
```



而export default命令对外输出的**变量名可以是任意的，不需要知道原本的变量名**，这时`import`命令后面，**不使用大括号**。

```javascript
export default function(){
}

import param from './profile.js'
```



换一个角度来看，export default就是输出一个default的变量和方法，所以可以用export输出一个default的变量，但实际效果与export default相比我也不是很清楚

> `export default`命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此`export default`命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应`export default`命令。
>
> 两种可以同时使用



### JS迭代器

**迭代器是**什么？迭代器就是为实现**对不同集合进行统一遍历操作**的一种机制

什么是**迭代器模式**？提供一种方法顺序访问一个聚合对象中的各种元素，而**又不暴露该对象的内部元素。**

为什么要**使用迭代器**？JS对于遍历聚合对象中各个元素（Array，Set，Map，Object），会采用不同的遍历方式，如果后端返回的数据结构发生变化，会导致前端大量代码重写，所以使用迭代器，就是要**标准化迭代操作**



**在JavaScript中**，**迭代器**就是一个**对象**（这个对象中有next方法），**这个对象定义一个序列，并在终止时可能返回一个返回值。**

更具体的说，迭代器这个对象通过next()方法返回具有两个属性的对象：**value**（这是序列中的 next 值）和**done**（如果已经迭代到序列的最后一个值，则它就是true），这个有value和done的对象就是迭代器的返回值

>  只能迭代一次的Iterables（例如Generators）通常从它们的**@@iterator**方法中返回它本身，其中那些可以多次迭代的方法必须在每次调用**@@iterator**时返回一个新的迭代器。

**迭代协议**分为两个部分：

1. 可迭代协议
2. 迭代器协议

**可迭代协议**规定了，运行JS对象定义或定制它们的迭代行为。

如何定制呢？要成为可以迭代的对象，对象必须有**@@iterator方法**（[Symbol.iterator]）

**迭代器协议**规定了，产生 **迭代的一系列的值**的标准方式。

当值为有限个时，所有的值都被迭代完毕后，则会返回一个**默认返回值**。

也就是规定了拥有特殊写法的next方法（包括规定返回值，value，done的内容等等），拥有这个next方法，对象才能成为可迭代的对象



**生成器函数**

用**function***这种声明方式表示这个函数是个**生成器函数**，返回一个Generator对象，也就是生成器对象，这对象有**next方法**，满足上述的迭代协议。

> **生成器对象**，既是一个迭代器，也是一个可迭代对象（@@iterator方法返回本身（本身这个迭代器））
>
> 生成器函数最多有255个参数

**生成器函数**在执行时能暂停，后面又能从暂停处继续执行。

调用 `next()`方法时，如果传入了参数，那么这个参数会传给**上一条执行的 yield语句左边的变量**

当在生成器函数中显式 `return `时，会导致生成器立即变为完成状态，即调用 `next()` 方法返回的对象的 `done `为 `true`。如果 `return `后面跟了一个值，那么这个值会作为**当前**调用 `next()` 方法返回的 value 值

不能当构造函数来使用



给对象定制迭代行为

```javascript
两种方法    
var obj = {
        a:1,
        [Symbol.iterator]:function(){
            let index = 0;
            let next = () =>{
                return {
                    value:index++,
                    done: index > 10 ? true : false
                }
            }
            return {
                next
            }
        }
    }

    var obj = {
        a:1, 
        [Symbol.iterator]:function*(){
            yield 1;
            yield 2;
            yield 3;
        }
    }

    for(let i of obj){
        console.log(i);
    }
```



### DOM事件流

1. **事件流：它描述的是事件在页面中传播的顺序。**
2. **事件：它描述的是发生在浏览器里的动作。** 这个动作可以是用户触发的，也可以是浏览器触发的。像点击（click）、鼠标悬停（mouseover）、鼠标移走（mousemove）这些都是事件。
3. **事件监听函数：事件发生后，浏览器如何响应——用来应答事件的函数，就是事件监听函数，也叫事件处理程序。**




JS代码只能执行捕获或者冒泡其中的一个阶段

onclick和attachEvent只能得到冒泡阶段，也就是说是冒泡开始的

addEventListener(type,listener[,options,userCapture,wantsUntrusted])

第四个参数为true,表示在**捕获阶段调用事件处理程序**；

如果是false(默认为fasle)，表示在**冒泡阶段调用事件程序**。

> 其实第三个参数是一个指定有关listener属性的对象。
>
> 属性分别是capture,once,passive
>
> - `capture`:  Boolean，表示 `listener` 会在该类型的事件捕获阶段传播到该 `EventTarget` 时触发。
> - `once`:  Boolean，表示 `listener 在添加之后最多只调用一次。如果是` `true，` `listener` 会在其被调用之后自动移除。
> - `passive`: Boolean，设置为true时，表示 `listener` 永远不会调用 `preventDefault()`。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。
>
> 第五个参数不是标准的参数
>
> wantsUntrusted如果为 `true `, 则事件处理程序会接收网页自定义的事件。此参数只适用于 Gecko（[chrome](https://developer.mozilla.org/zh-CN/docs/Glossary/Chrome)的默认值为true，其他常规网页的默认值为false），主要用于附加组件的代码和浏览器本身。

DOM事件流包括三个阶段。

1. 事件捕获阶段：事件从Document节点自上而下向目标节点传播的阶段；
2. 目标阶段：真正的目标节点接收事件的阶段；
3. 事件冒泡阶段：事件从目标节点自下而上向Document节点传播的阶段。

当事件被触发时，首先经历的是一个捕获过程：事件会从最外层的元素开始“穿梭”，逐层“穿梭”到最内层元素。这个穿梭过程会持续到事件抵达它目标的元素（也就是真正触发这个事件的元素）为止。此时事件流就切换到了“目标阶段”——事件被目标元素所接收。然后事件会被“回弹”，进入到冒泡阶段——它会沿着来时的路“逆流而上”，一层一层再走回去。

[DOM 事件体系](https://juejin.cn/post/6973965991201996814)



### 如何阻止事件发生

三种方法：

标准的：e.preventDefault();

非标准，兼容IE低版本：e.returnValue

特殊的：return false(之后的代码都没用了)



### 如何阻止事件冒泡

标准方法：e.stopPropagation()

兼容IE低版本的方法：e.cancelBubble = true



### 事件委托

事件委托，就是把一个元素的响应事件委托到另外一个元素

一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。

关键点，使用e.target

e.target属性返回事件对象的目标结点（也就是触发该事件的节点）

```javascript
var ul = document.querySelector('ul');
ul.addEventListener('click',function(e){
    Array.from(ul.children).forEach(element => {
        element.className = '';
    });
    e.target.className = 'bk';
})
```

当需要精准匹配的时候，使用Element.matches

Element.matches(selectorString)   selectorString 既是 CSS 那样的选择器规则，比如本例中可以使用 target.matches('li.class-1')，他会返回一个布尔值，如果 target 元素是标签 li 并且它的类是 class-1 ，那么就会返回 true，否则返回 false。

```javascript
var ul = document.querySelector('ul');
ul.addEventListener('click',function(e){
    if(e.target.matches('li.c1'))
        e.target.className += ' bk';
})
```

这种方法存在兼容性问题，需要IE9及以上的现代化浏览器版本

可以使用**Polyfill**来解决兼容性上的问题

**好处**：

1. 减少内存消耗，不用一个函数一个元素的绑定，对列表每一个元素都绑定，对于内存消耗较大
2. 因为访问的DOM减少了，设置事件处理程序所需时间更少, 加快了整个页面的交互就绪时间
3. 动态绑定事件，减少重复的工作

**局限性**：

1. 事件委托基于冒泡，不冒泡的事件不支持事件委托，如focus、blur之类的事件本身并没有冒泡机制，无法委托
2. 层级过多的情况下，冒泡过程可能被中间层阻止
3. 当事件委托过多时，可能会出现事件误判，即不该触发该事件的元素被绑定了



### 事件委托：能不能把所有事件都绑定到document上？

> DOM*是HTML文档的内存中对象表示，它提供了使用JavaScript与网页交互的方式。*DOM*是节点的层次结构（或树），其中*document节点作为根，是根元素。

我个人不建议这样做。

虽然事件委托能减少内存消耗，加快页面交互就绪时间，但层级过多的情况下， **冒泡过程可能会被中间某一层阻止**，而且**当事件委托过多，可能会出现事件误判，不该触发的元素被触发绑定了，并且一些事件没有冒泡阶段，比如blur**。

还要考虑到浏览器的**非快速滚动区域**，因为页面的JavaScript脚本是在主线程（main thread）中运行的，所以当一个页面被合成的时候，合成线程会将页面那些注册了事件监听器的区域标记为“非快速滚动区域”（Non-fast Scrollable Region）。由于知道了这些信息，当用户事件发生在这些区域时，合成线程会将输入事件发送给主线程来处理。如果输入事件不是发生在非快速滚动区域，合成线程就无须主线程的参与来合成一个新的帧。

如果给document绑定事件，body元素绑定了事件监听器后其实是将整个页面都标记为一个非快速滚动区域，这就意味着即使你页面的某些区域压根就不在乎是不是有用户输入，当用户输入事件发生时，合成线程每次都会告知主线程并且会等待主线程处理完它才干活（主线程执行事件监听函数）。因此这种情况下合成线程就丧失提供流畅用户体验的能力了。

（为了减轻这种情况的发生，您可以为事件监听器传递`passive：true`选项。 这个选项会告诉浏览器您仍要在主线程中侦听事件，可是合成线程也可以继续合成新的帧。）

并且这并不符合我们编程习惯中的**单一职责原则**，如果把所有执行的事件操作**都绑定在document一个元素的事件监听函数上，会导致函数过于臃肿，且代码可读性不高，逻辑不够清晰，以后维护起来较困难**。



### React中对事件绑定的优化

首先书写方式是小驼峰书写方式。

另外在 React 中另一个不同点是你不能通过返回 `false` 的方式阻止默认行为。你必须显式的使用 `preventDefault`。

默认是在冒泡阶段执行，且在底层抹平了不同浏览器的差异，在上层面向开发者暴露统一的、稳定的、与 DOM 原生事件相同的事件接口。

会把所有事件委托绑定在document，相较于上个知识点，应该是做了优化。



React 事件系统的设计动机是什么？

1. **合成事件符合W3C规范，在底层抹平了不同浏览器的差异，在上层面向开发者暴露统一的、稳定的、与 DOM 原生事件相同的事件接口**。开发者们由此便不必再关注烦琐的底层兼容问题，可以专注于业务逻辑的开发。
2. 自研事件系统使 React 牢牢把握住了**事件处理的主动权**.

对 React 来说，事件委托主要的作用应该在于帮助 React 实现了对所有事件的中心化管控。

> 事件的绑定是在组件挂载过程中完成的，即 `completeWork` 中完成的。
>
> completeWork 有三个关键动作：创建 DOM 节点、将 DOM 节点插入到 DOM 树中、为 DOM 节点设置属性。
>
> 事件的触发本质上是对 `dispatchEvent` 函数的调用。
>
> 核心工作流：
>
> 事件触发，冒泡至 `document` -> 执行 `dispatchEvent` -> 创建事件对应的合成事件对象（`SyntheticEvent`）->
> 收集事件在捕获阶段所波及的回调函数和对应的节点实例 -> 收集事件在冒泡阶段所波及的回调函数和对应的节点实例 ->
> 将收集回来的回调按顺序执行，执行时 `SyntheticEvent` 会作为如参被传入每个回调

更详细的内容：[特别的事件系统：React 事件与 DOM 事件有何不同](https://blog.ahulib.com/other/React_%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F.html)



### 使用useState时，React并没有对数组方法unshift,pop,push等做优化

数组，对象指向依旧没有改变，不会重新渲染





### 什么是高阶函数？

1.若A函数，接收的参数是一个函数，那么A就可以被称为高阶函数

2.若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数

两个中任意满足一个即可。

常见的，如Promise、setTimeout



### JS中sort的坑和sort源码

坑：https://segmentfault.com/a/1190000018076819

源码：https://zhuanlan.zhihu.com/p/33626637





React：https://juejin.cn/post/6844903985338400782#heading-22



### NestJS

文档：https://docs.nestjs.cn/7/firststeps

NestJS是一个高效，易于扩展的Nodejs框架。内置并完全支持TypeScript（eggjs就不能很好的支持，各种第三方库可能不受控制）。

Nest底层使用了强大的HTTP Server框架，如Express，Fastify。Nest在这些框架的基础上提供了一定程度的抽象，同时也将其API暴露给开发人员。这样**可以轻松使用每个平台的第三方模块**。



Nest通过**依赖注入(DI)的方式进行控制反转**。

只要声明模块中的依赖，Nest就会在启动的时候去创建依赖，然后自动注入到相应的地方。

依赖注入的最大作用就是依赖解耦，依赖的对象根据不同的情况可以有多种实现。

Nest遵从面向切面编程（AOP）的思想。

除了`Middleware`外，还有`Exception Filter`、`Pipes`、`Guards`和`Interceptors`几个预定义的切面，可以集中进行异常处理、数据验证、权限验证和逻辑扩展等功能。

Nest自带如数据验证等一些常用的基于切面的功能，也可以通过继承的方式来进行扩展。这些预定义的切面是代码架构的组成部分，按照这些约定来组织代码会大大降低日后的维护成本。

> 控制反转（IOC）与依赖注入（DI）
>
> 简单来说，a依赖b，但a不控制b的创建与销毁，仅仅使用b，那么b的控制权交给a之外处理，这叫控制反转（IOC），而a要依赖b，必然要使用b的instance，那么
>
> 1. 通过a的接口，把b传入；
> 2. 通过a的构造，把b传入；
> 3. 通过设置a的属性，把b传入；
>
> 这个过程叫依赖注入（DI）
>
> 那么什么是IOC Container？随着DI的频繁使用，要实现IOC，会有很多重复代码，甚至随着技术的发展，有更多新的实现方法和方案，那么有人就把这些实现IOC的代码打包成组件或框架，来避免人们重复造轮子。所以实现IOC的组件或者框架，我们可以叫它IOC Container。
>
> https://www.zhihu.com/question/32108444



### 面向切面编程 AOP

面向切面编程（Aspect-oriented programming，AOP）是一种编程范式。

**简单理解就是在目标方法执行的前后，执行我们想要执行的代码**。一般来说框架里面经常用到aop编程，而要做到aop，常常用到动态代理的技术。即会通过代理类，增强原有的目标类，加入方法执行前后需要执行的目标代码，这个过程不需要人为手动实现。

**从核心关注点中分离出横切关注点**，是 AOP 的核心概念。

AOP的经典应用之一就是**关注点分离**：分离业务代码和数据统计代码（非业务代码）。

在前端的常见需求中，有以下一些业务可以使用 AOP 将其从核心关注点中分离出来 - Node.js 日志log - 埋点、数据上报 - 性能分析、统计函数执行时间 - 给ajax请求动态添加参数、动态改变函数参数 - 分离表单请求和验证 - 防抖与节流



装饰器（Decorator），提到 AOP 就要说到装饰器模式，AOP 经常会和装饰器模式混为一谈，但我们经常用装饰器来实现AOP思想

> 在ES6之前，要使用装饰器模式，通常通过`Function.prototype.before`做前置装饰，和`Function.prototype.after`做后置装饰（见《Javascript设计模式和开发实践》）。
>
> Javascript 引入的 Decorator ，和 Java 的注解在语法上很类似，不过在语义上没有一丁点关系。Decorator 提案提供了对 Javascript 的类和类里的方法进行装饰的能力。（尽管只是在编译时运行的函数语法糖）
>
> 目前node以及各浏览器中均不支持Decorator提案。只能通过安装babel插件来转换代码，插件名叫这个：transform-decorators-legacy。也有在线试用](https://babeljs.io/repl/)，安装好transform-decorators-legacy之后，就能看到转义后的代码了



### 为什么很多Web项目还是使用px，而不是rem？

https://www.zhihu.com/question/313971223



### 副作用





### React中的生命周期

**Class中**

旧版本中：

生命周期的三个阶段（旧）

**初始化阶段 由ReactDOM.render()触发---初次渲染**

constructor()

componentWillMount()

**render()**

**componentDidMount()**

**更新阶段 由组件内部this.setSate()或父组件重新render触发**

shouldComponentUpdate()

componentWillUpdate()

**render()**

componentDidUpdate()

**卸载组件 由ReactDOM.unmountComponentAtNode()触发**

**componentWillUnmount()**



初始挂载时：

constructor ——> componentWillMount ——> **render** ——> **componentDidMount** ——>**componentWillUnmount**

重新渲染时：

componentWillReceiveProps/setState ——> shouldComponentUpdate ——> componentWillUpdate（forceUpdate） ——> **render** ——> componentDidUpdate ——>**componentWillUnmount**

使用的最多的还是 

**componentDidMount** 做初始化的事

**componentWillUnmount** 做一些收尾的事

**render**



新版本中：

**初始化阶段 由ReactDOM.render()触发---初次渲染**

constructor()

getDerivedStateFromProps

render()

componentDidMount()

**更新阶段 由组件内部this.setSate()或父组件重新render触发**

getDerivedStateFromProps

shouldComponentUpdate()

render()

getSnapshotBeforeUpdate

componentDidUpdate()

**卸载组件 由ReactDOM.unmountComponentAtNode()触发**

componentWillUnmount()

还是这三个最常用：render,componentDidMount,componentWillUnmount

以上的生命周期函数均适用于类式组件

函数式组件使用useEffect这个钩子函数去模拟生命周期函数

> 钩子函数：
>
> 钩子函数：钩子函数是在一个事件触发的时候，在系统级捕获到了他，然后做一些操作。一段用以处理系统消息的程序。
>
> “钩子”就是在某个阶段给你一个做某些处理的机会。
>
> 钩子函数： 1、是个函数，在系统消息触发时被系统调用 2、不是用户自己触发的
>
> 钩子函数的名称是确定的，当系统消息触发，自动会调用。例如react的componentWillUpdate函数，用户只需要编写componentWillUpdate的函数体，当组件状态改变要更新时，系统就会调用componentWillUpdate。



### React中的Diffing算法

逐层比较，最小粒度是标签

**react/vue中key有什么用？为什么遍历列表时，key最好不要用index**？

首先我们知道react、vue高效的原因之一就是使用了虚拟DOM，在虚拟DOM中，**key是虚拟DOM的对象的标识**，在更新页面时key起着极其重要的作用。

当页面中的数据发生变化时，react会根据**新数据**生成**新虚拟DOM**。随后react会将**新虚拟DOM**和**旧虚拟DOM**进行diff比较，总的来说比较规则如下：

key相同的情况：

1. 若虚拟DOM内容相同，直接使用之前的真实DOM
2. 若内容不同，则生成新的真实DOM，替换页面之前的真实DOM

key不同的情况：

1. 直接根据新虚拟DOM创建新真实DOM，随后渲染到页面上



当使用index作为key时，可能会引发的问题：

1. 当对数据进行逆序添加，逆序删除等破坏顺序的操作时：会产生没必要的页面更新，页面效果没问题，但效率低。
2. 如果结构中包含输入类DOM：会产生错误的DOM更新，界面有问题。



**在开发中如何选择key？**

1. 最好使用每条数据的唯一标识作为key，比如id、手机号、学生号等唯一值。
2. 如果不存在对数据的逆序添加，逆序删除等破坏顺序的操作，只是简单的数据展示，用index也可以。



### 受控组件与非受控组件

对于存在表单输入的组件来说，该类组件分为受控组件和非受控组件

受控与非受控是什么意思呢？就是我们**对某个组件状态的掌控，它的值是否只能由用户设置，而不能通过代码控制**。



受控组件：

在HTML的表单元素中，它们通常自己维护一套`state`，并随着用户的输入自己进行`UI`上的更新，这种行为是不被我们程序所管控的。而如果将`React`里的`state`属性和表单元素的值建立依赖关系，再通过`onChange`事件与`setState()`结合更新`state`属性，就能达到**控制用户输入过程中表单发生的操作**。

能被React控制数据取值等操作的组件就叫做**受控组件**。

相反的，**React只能被动接收DOM表单返回的信息，不受React状态操作的表单输入组件**，就叫非受控组件



### JS中onpropertychange事件,oninput事件和onchange事件区别

当一个HTML元素的属性用js改变的时候，都能通过 onpropertychange来捕获。例如一个 <input name="text1" id="text1" />对象的value属性被页面的脚本修改的时候，onchange无法捕获到，而onpropertychange却能够捕获。 
也就是说：onpropertychange事件在用键盘每改变一下文本框的值或用js改变其值便会触发一下，而onchange只有在用键盘改变其值，然后在失去焦点(onblur)后才触发，用js改变其值不能触发!onpropertychange和onchange都不管文本框中的实际值有没有变，只要有改的相应操作就可能触发。有时当上面两时间都不能满足需求时，可以考虑只用onblur。 

目前似乎已经没有propertychange这个事件了

**oninput事件**能实时监听input框里面的值变化，没有失去焦点也能触发，可以进行输入的实时判断

onpropertychange似乎是专门给IE浏览器使用的



### ES6新特性总结

1. let const
2. 解构赋值
3. 模版字符串
4. 函数默认参数
5. 箭头函数
6. for of
7. class 它只是原型链的语法糖表现形式
8. promise 更优雅的处理异步
9. async/await 更好的解决了回调地狱
10. Symbol
11. Set Map



### 关于useState

返回一个 state，以及更新 state 的函数。

在初始渲染期间，返回的状态 (`state`) 与传入的第一个参数 (`initialState`) 值相同。

`setState` 函数用于更新 state。**它接收一个新的 state 值并将组件的一次重新渲染加入队列**。

在后续的重新渲染中，`useState` 返回的第一个值将始终是更新后最新的 state。

> 注意
>
> React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。



### 关于useEffect

在写第二个参数时，如果有个数组元素是对象，那么不管对象里面有什么，数据是否变换，useEffect每次都会更新

```jsx
    useEffect(()=>{
        console.log('变化');
    },[{name:'c'}])
```

new {name:'c'} !== old {name:'c'}

这种写法vscode会直接警告



### 在useEffect中调用函数

在 useEffect 中调用用函数时，如果该函数依赖组件作用域的props或state，要把该函数在 useEffect 中申明，把用到的变量写在第二个参数数组中，不能放到外部申明，然后再在 useEffect 中调用。在外部申明，在内部调用。这样是不安全的。

当函数不依赖props、state或它们衍生而来的值时，才能安全的指定的第二个参数为[ ]

为什么不安全？目前不能很好的说明原因，但如果不写依赖，effect内则不会更新，如果有一些判断事件，则会出bug



### useCallback

useCallback接收一个回调函数，一个依赖项数组作为参数，返回一个memoized（具有记忆技术的）回调函数，只有在依赖数组中值变化后才会更新返回值。

> memoization是JavaScript中的一种记忆技术，通过缓存结果并在下一个操作中重新使用缓存来加速查找效率的操作。
>
> 什么叫记忆性技术？
>
> 每次调用函数把你的传参和结果记录下来，遇到相同的传参，就直接返回记录缓存的结果，不用再去调用函数处理数据！

**误区**:useCallback是解决函数组件过多内部函数的性能问题（因为每次重新渲染，都要重新构造内部函数，所以我用这个函数，那么每次是不是就不会重新创建内部数组了呢？这是一大误区）

使用函数组件时经常定义一些内部函数，总觉得这会影响函数组件性能。也以为`useCallback`就是解决这个问题的，其实并不是：

1. JS内部创建函数很快的，这点性能不是问题
2. 相对于class更轻量的函数式组件，避免了HOC, renderProps等额外层级，函数式组件的性能较好
3. 使用了useCallback会额外增加性能，因为增加了额外的deps数组变换判断
4. 最重要的一点，useCallback不能解决内部函数重新创建的问题。不管是否使用useCallback，都无法避免重新创建内部函数。虽然函数引用不会变（这点我无从证实）

useCallBack**解决的问题时利用momeize函数减少不必要的组件渲染**

当一个子组件只用了一个内部函数，没用到其他状态，但其他状态更新了后，整个组件都要重新渲染，重新生成一个函数，导致函数引用不一样，从而导致了这个子组件也跟着重新渲染，但实际上两次渲染没有什么差别，白白浪费了性能。

（这里有个疑问，React.memo的作用感觉很鸡肋，因为React原本的渲染机制就不会去重新渲染那些props不变的组件，是用memo更快吗？还是我理解的渲染机制有问题）



### useMemo

useMemo的作用和useCallback的作用很相似，传入一个值和依赖数组，返回一个memoized的值，依赖数组变化后才会更新返回值

与useCallback的区别：

- useCallback针对的是函数，传参和结果都是函数；而useMemo主要针对那些计算量较大的值，避免组件进行一些冗余计算
- useCallback可以看作是useMemo的一种特殊情况；传入useMemo的函数具有限制，因为传入 useMemo的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如**副作用这类的操作**属于 useEffect的适用范畴，而不是 useMemo

**可以把 useMemo作为性能优化的手段，但不要把它当成语义上的保证。**



### Memo

React.memo是高阶组件

> 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。
>
> 具体而言，**高阶组件是参数为组件，返回值为新组件的函数。**

如果组件在相同 props 的情况下渲染相同的结果，那么可以通过将其包装在 `React.memo` 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。

> `React.memo` 仅检查 props 变更。如果函数组件被 `React.memo` 包裹，且其实现中拥有 [`useState`](https://zh-hans.reactjs.org/docs/hooks-state.html)，[`useReducer`](https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer) 或 [`useContext`](https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext) 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。

默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。



以上三个可以理解记忆：useCallback针对函数Memoized,useMemo主要针对参与渲染的值Memoized，Memo针对组件进行Memoized

这三个都可以减少渲染次数，从而达到页面性能优化，但不要过多的使用，「记住」这个过程本来就会消耗一定的内存和计算资源，考虑不使用memoized情况的开销，考虑每次对比是浅比较的情况，再进行使用这三个API

> 参与页面性能优化的API还有很多，比如useRef,useReducer,creatContext等，后续再深入学



### React中的portal

> 官方解释：Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。

React中的portal，能让一个React组件存放在任意一个存在的DOM节点内，就像给这个React组件开了一个传送门，最后能渲染在任一一个存在的DOM树内。

 portal 的典型用例是当父组件有 `overflow: hidden` 或 `z-index` 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框

具体使用:

ReactDom.createPortal(child,container)

- 第一个参数（`child`）是任何[可渲染的 React 子元素](https://zh-hans.reactjs.org/docs/react-component.html#render)，例如一个元素，字符串或 fragment。
- 第二个参数（`container`）是一个 DOM 元素。

**关于使用了portal的元素的事件冒泡**

使用了portal后，该元素在DOM树中的位置和在React树中的位置不一致，也就是在React中编写该元素时的位置与其渲染出来在DOM树中的位置不一致（这是显而易见的）

那么该元素的事件冒泡会被**冒泡到React树的父级，而不是DOM树的父级**

参考：

- 官方文档 https://zh-hans.reactjs.org/docs/portals.html



### React组件间传参通信

1. props 父传子
2. Instance Methods 通过refs 回调 父传子
3. Callback Function 回调函数 子传父
4. Event Bubbling 元素dom冒泡机制
5. Parent Component 兄弟组件传信
6. Context Context.Provider 
7. Redux



### 为什么必须在组件的顶层使用 Hook & 在单个组件中使用多个 State Hook 或 Effect Hook，那么 React 怎么知道哪个 state 对应哪个 useState？

 **React依赖于Hook的调用顺序。**如果能确保Hook在每一次渲染中都按照同样的顺序被调用，那么React 能够在多次的 `useState` 和 `useEffect` 调用之间保持 hook 状态的正确性

**只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联**。

如果将一个Hook放入条件语句或者循环语句中，Hook的渲染顺序发生了改变，会导致bug的产生

如果我们想要有条件地执行一个 effect，可以将判断放到 Hook 的内部。




### 在腾讯实习这段时间做了什么？

首先我了解了我们组的业务，体验了我们组的产品。

我们中心是云开发产品中心，组内做的内容是微搭低码的控制台这一块。在我刚入职的那段时间，我在一边熟悉内部开发文档，一边体验产品，然后产出产品体验报告一份。

在体验完产品后，我开始了第一个项目需求，完成企业门户的用户鉴权。拿到项目后我开始阅读项目代码，项目是由React的框架antd pro这样一个企业级中后台作为前端框架，并用Nestjs作为中间转发层，搭配CONCENT作为react的数据状态管理框架，开发语言用的TS，JS的超集，更适合工程开发的语言，配上一些其他库如antd，tailwind，react-use进行开发。

因为之前没有接触过antd pro、concent和nestjs，所以我在边阅读项目边学习这些框架，浏览官方文档并代入公司项目中。学习差不多后开始编写代码，自测，填写自测报告，最后顺利完成该需求。

之后的任务就在项目联调，产品发布时跟进测试、交互的问题，随时进行代码修改。

完成的事有：在项目中编写代码把项目加入内部前端监控中；代码规范；对前端日志打印进行清除；发布前完成环境变更，修改运行态接口请求配置，改为prod发布现网环境；对页面进行响应式开发，完成移动端适配；对官方组件库的表单组件进行响应式适配，其实相当于写了个新的页面。

在这个过程中，还在学习扫码登录相关知识，为之后的需求做准备，但后续因为要准备秋招，于是换了其他需求给我做。

总结：这是我第一次的工作实习，感受最深是从一个学生变成一个公司开发人员的过程，学习到了大厂公司的开发模式，一个需求的开发流程，一个产品从开发到测试，到发布的过程，第一次在十分正式的工程里开发，这些都是在学校中学不到的。当然也有技术的提升，在公司做项目学到了很多我平时都没接触过的框架，库，如nestjs，tailwind这些技术前沿的东西，我去学习这些框架，阅读文档，了解一些思想，设计原理，这些都是对我技术的提升。

具体一点：

Git的操作。之前学校里做自己的项目，虽然也使用了Git，但因为人数较少，开发周期较短，遇到的问题不多，对git的使用仅限于拉取，推送，冲突的处理等小问题，在实习时对git有了更好的理解，也学到了更多的操作，如git rebase,git stash,git reset等，学会了如何提一个PR，MR，也在学习git可视化工具如Fork。

nestjs的学习。在做登录鉴权的时候，主要就是在nestjs里面进行开发。前端发送的请求是一步一步的通过nestjs的

客户端请求 -> Middleware中间件 -> Guard守卫 -> 请求拦截器 -> Pipe管道 -> Controllor层的路由处理函数 -> 响应拦截器 -> 客户端响应

中间件，拦截器都是在对前端请求做一些处理，进行一些日志的打印。我主要是在guard守卫处进行设置，首先要判断的是用户有无登录进入的权限，我在guard进行判断，如果没有权限则直接抛出错误，让异常过滤器进行处理。然后对于一些页面中的接口请求，我会通过自定义装饰器，nestjs内部接口SetMetadata来对services中的类中处理函数进行装饰，自定义时会用装饰器接收一个参数作为权限，如果用户要调用这个接口，那么在controllor层通过reflector取出这个自定义参数，用户的权限中必须包含这个自定义参数，没有的话就会抛出不存在权限的错误。**这样的写法耦合性较低，编写起来也十分方便，不用写过多的冗余代码**。当然也会对前端进行路由守卫，antd pro的路由守卫是通过在access文件和router文件里进行配置，首先返回的access对象中要有判断的变量，然后填入router配置中的access值，代表如果这个access为真，则能访问，为假则进入wrappers中配置的页面（错误边界？）

微搭这个项目是以云开发为基础的，我所做的登录有两次判断，首先是直接调用云开发的SDK进行账号密码的判断，之后是上述的访问登录权限判断。因为这个登录只与门户这一个系统有关，并不是单点登录。



### 什么是云开发？

云开发（Tencent Cloud Base，TCB）是腾讯云为移动开发者提供的高可用、自动弹性扩缩的后端云服务，包含计算、存储、[CDN](https://cloud.tencent.com/product/cdn?from=10680)、静态托管等能力（Serverless 化），可用于开发多种端应用（小程序，公众号，Web 应用，Flutter 客户端等，后续会陆续支持 iOS 和 Android 等移动应用开发），达到一站式后台服务构建多端应用，帮助开发者统一构建和管理后端服务和后端云资源，避免了应用开发过程中参与繁琐的服务器搭建及运维，开发者可以专注于业务逻辑的实现，开发门槛更低，效率更高。

**那云开发究竟是什么呢？**

1. 用一句话来讲，云开发是一个支持小程序、web、安卓等多端的应用服务中心。
2. 云开发为开发者提供完整的云端流程，简化后端开发和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代。

**云开发有什么内容？**

1. 云函数：无需自建服务器，云端代码，微信天然鉴权，可自行创建和编辑。
2. 云数据库：无需自建数据库，既可以直接通过下程序前端操作，也可以通过云函数读写的JSON数据库。
3. 云储存：无需自建储存和CDN，可以直接在前端上传和下载云端文件，云开发控制台可视化管理。
4. 云调用：可以基于云函数免鉴权使用小程序开放接口，包括服务调用和获取开放数据。
5. HTTP API：通过API接口，使用者可以在已有的服务器上访问云端资源，实现互通。
6. 云开发控制台：可以对云函数、云数据库、云储存以及网络状况等进行实时管理和监控。

**云开发的缺点**

1. 对云数据库的操作，所有的增删改查都需要通过API去执行HTTP接口调用。这对后台管理方面来说不是很有利。
2. 数据都在云端，[数据安全](https://cloud.tencent.com/solution/data_protection?from=10680)性全依赖于云服务器端。
3. 数据库在云端，对数据库的备份和数据潜移以及数据库同步等操作比传统方式略显困难。

**小结**

1. 云开发可以让开发更简单、开发高效快捷、运维更省事、成本更低。
2. 云开发可以最快速方便的通过SDK执行数据库操作。
3. 可以实现前端工程师的全栈式开发的梦想。
4. 云开发控制台可以很方便的进行全方面的管理。
5. 未来发展趋势之一，虽然目前也有一些不完善的地方，但是我们有理由相信，云的思维配合低成本全栈及各大优势，云开发的前景一片美好。





### Function hooks相比Class components有什么优势

类组件的不足（3点）：

1. **状态逻辑难以服用**：在组件之间复用状态逻辑很难，可能要用到 **render props** （**渲染属性**）或者 **HOC**（**高阶组件**），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素），**导致层级冗余**
2. **趋向复杂难以维护**：生命周期函数多，常常包含一些不相关的逻辑，相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。类组件中到处都是对状态的访问和处理，导致组件难以拆分成更小的组件。
3. **this的指向问题**：自身内部写方法时，需要注意this指向；父组件给子组件传递函数时，必须绑定 this，父组件给子组件绑定this的方法有多种，但如果写法不注意，会造成性能损耗。

而Hooks对上述问题进行了优化（4点）：

1. 能在无需修改组件结构的情况下复用状态逻辑（自定义 Hooks ）

2. 能将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）

3. 使用多个Effect来分离不同副作用关注点：以往这些副作用都是写在类组件生命周期函数中的，常常包含一些不相关的逻辑。而 我们可以使用多个useEffect来分离多个副作用关注点，一个副作用关注点属于一个Effect。也就是说**Hooks 允许我们根据代码的用途来分割代码** 。（业务代码更聚合）

   > 副作用指那些没有发生在数据向视图转换过程中的逻辑，如 `ajax` 请求、访问原生`dom` 元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志等
   >
   > 而useEffect在全部渲染完毕后才会执行，useLayoutEffect 会在浏览器 layout 之后，painting 之前执行。

4. 代码更简洁，可读性更好



Hooks的缺点（2点）：

1. 响应式的useEffect:有时候，你的useEffect依赖某个函数的不可变性，这个函数的不可变性又依赖于另一个函数的不可变性，这样便形成了一条依赖链。一旦这条依赖链的某个节点意外地被改变了，你的useEffect就被意外地触发了，如果你的useEffect是幂等的操作，可能带来的是性能层次的问题，如果是非幂等，那就糟糕了。
2. hooks存在旧引用的问题：函数的运行是独立的，每个函数都有一份独立的作用域。函数的变量是保存在运行时的作用域里面。当我们有**异步**操作的时候，经常会碰到异步回调的变量引用是之前的，也就是旧的（这里也可以理解成闭包）。这里可以用useRef来解决问题。

> useRef 返回一个可变的 ref 对象，其 `current` 属性被初始化为传入的参数（initialValue）
>
> useRef 返回的 ref 对象在组件的整个生命周期内保持不变，也就是说每次重新渲染函数组件时，返回的ref 对象都是同一个（使用 React.createRef ，每次重新渲染组件都会重新创建 ref）



### Redux 遵循的三个原则是什么

**单一数据源**

整个应用的 state 被储存在 **一棵 object tree** 中，并且这个 object tree 只存在于 **唯一一个 store** 中。

**State是只读的**

唯一改变state的方法就是触发action

这样确保了 视图 和 网络请求 都**不能直接修改 state**，相反它们只能表达想要修改的意图。因为所有的修改都被**集中化**处理，且严格按照一个接一个的顺序执行，因此不用担心 **竞态条件**的出现。

> 什么是竞态条件？
>
> 当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在**竞态条件**。
>
> 竞态条件（Race Condition）：计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件。
>
> 
>
> **导致竞态条件发生的代码区**称作**临界区**。
>
> 在临界区中使用适当的同步就可以避免竞态条件。
>
> 临界区实现方法有两种，一种是用synchronized，一种是用Lock显式锁实现。

**使用纯函数来修改State**

为了描述Action如何改变state tree，需要编写reducers

> 什么是纯函数？
>
> 1. 一类特别的函数: **只要是同样的输入(实参)，必定得到同样的输出(返回)**
>
> 2. 必须遵守以下一些约束 
>
>    不得改写参数数据
>
>    不会产生任何副作用，例如网络请求，输入和输出设备
>
>    不能调用Date.now()或者Math.random()等不纯的方法 
>
> redux的reducer函数必须是一个纯函数



### 能不能用全局变量替代Redux

首先我们要知道Redux是什么：

**Redux 是一个使用叫做“action”的事件来管理和更新应用状态的模式和工具库** 

它以集中式Store（centralized store）的方式对整个应用中使用的状态进行集中管理，其规则确保状态只能以可预测的方式更新。

![img](https://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg)

> Redux可以理解为：只是在单例模式基础上加了订阅机制、采用 reducer 约束修改，以及加上 middleware 机制保证扩展性。
>
> Redux关键在于数据流动，而不在于数据源头，所以无关全局变量与否。
>
> React 的核心价值观是：状态决定渲染结果，因此只有状态改变了才需要重新渲染。如果你用一个非状态的全局变量来保存状态，那任何一个 React 组件都不会因为这个全局变量的改变而重新渲染。

如果只是拿全局变量替换Redux store，这个没什么问题，但全局变量替换Redux，那么全局变量必须能出发更新通知到对应的组件，而这样其实就是实现了Redux selector



### Vue与React的区别

**Vue 使用的是 web 开发者更熟悉的模板与特性**，Vue的API跟传统web开发者熟悉的模板契合度更高，比如Vue的单文件组件是以模板+JavaScript+CSS的组合模式呈现，它跟web现有的HTML、JavaScript、CSS能够更好地配合。

**React 的特色在于函数式编程的理念和丰富的技术选型**。（不懂）

> 函数式编程是种编程方式，主要思想是把运算过程尽量写成一系列嵌套的函数调用。函数式编程一切皆为函数。函数式编程灵活性和执行效率很高，但是整体逻辑不太好捋。

从**使用习惯和思维模式**上考虑，Vue 比起 React 更容易被前端工程师接受，对于一个初学web开发的人来说Vue更友好，更符合他的思维模式。



更大的一个区别是**实现数据监听的原理不同**

Vue对数据的监听是通过getter/setter以及一些函数的劫持，精确知道数据的变化，当数据变化时，页面会自动更新。

而React需要调用setState方法来通知系统进行更新



**渲染过程不同**

Vue可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。

React在应用的状态被改变时，全部子组件都会重新渲染。通过shouldComponentUpdate这个生命周期方法可以进行控制，但Vue将此视为默认的优化。

如果应用中交互复杂，需要处理大量的UI变化，那么使用Virtual DOM是一个好主意。如果更新元素并不频繁，那么Virtual DOM并不一定适用，性能很可能还不如直接操控DOM。



**Vuex和Redux的区别**

从表面上来说，store注入和使用方式有一些区别。在Vuex中，$store被直接注入到了组件实例中，因此可以比较灵活的使用：使用dispatch、commit提交更新，通过mapState或者直接通过this.$store来读取数据。在Redux中，我们每一个组件都需要显示的用connect把需要的props和dispatch连接起来。另外，Vuex更加灵活一些，组件中既可以dispatch action，也可以commit updates，而Redux中只能进行dispatch，不能直接调用reducer进行修改。

从实现原理上来说，最大的区别是两点：Redux使用的是不可变数据，而Vuex的数据是可变的，因此，Redux每次都是用新state替换旧state，而Vuex是直接修改。Redux在检测数据变化的时候，是通过diff的方式比较差异的，而Vuex其实和Vue的原理一样，是通过getter/setter来比较的，这两点的区别，也是因为React和Vue的设计理念不同。React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。



**框架本质不同**

Vue本质是MVVM框架，由MVC发展而来；

React是前端组件化框架，由后端组件化发展而来。

参考文章

- [vue和react的区别是什么？](https://zhuanlan.zhihu.com/p/100228073)
- [谁能大致说下vue和react的最大区别之处？](https://www.zhihu.com/question/309891718)



### MVC MVP MVVM设计模式

MVC：Model-View-Controller设计模式

MVP：Model-View-Presenter设计模式

MVVM：Model-View-ViewModel设计模式

**MVC**

MVC是比较直观的架构模式。

用户进行操作——（View接收用户的操作）——传递给Controller进行业务逻辑处理——Model进行数据存储，并将结果返回给View

以上这是一次完整的MVC模式。

Model是数据模型。View是视图，或者说是我们要去展示的东西。Controller是用来控制Model的读取，存储，以及如何在View上展示数据，更新数据的逻辑控制器

缺点：

- MVC 框架的大部分逻辑都集中在 Controller 层，代码量也都集中在 Controller 层，这带给 Controller 层很大的压力，而已经有独立处理事件能力的 View 层却没有用到。
- 还有一个问题，就是 **Controller 层和 View 层之间是一一对应的，断绝了 View 层复用的可能，因而产生了很多冗余代码**。

**MVP**

MVP是把MVC中的Controller换成了Presenter（呈现），彻底隔绝了View层和Model层的通信

相对于MVC的修改：

- 首先是因为 Model 层和 View 层都必须通过 Presenter 层来传递信息，所以完全分离了 View 层和 Model 层，也就是说，View 层与 Model 层一点关系也没有，双方是不知道彼此存在的，在它们眼里，只有 Presenter 层。
- 其次，因为 View 层与 Model 层没有关系，所以 **View 层可以抽离出来做成组件，在复用性上比 MVC 模型好很多**。

总的来说就是耦合性降低，复用性好很多

缺点：

- 因为 View 层和 Model 层都需经过 Presenter 层，致使 Presenter 层比较复杂，维护起来会有一定的问题。（个人认为这也是MVVM的缺点）
- 而且因为没有绑定数据，所有数据都需要 Presenter 层进行“手动同步”，代码量比较大，虽然比 MVC 模型好很多，但也是有比较多的冗余部分。

**MVVM**

MVVM是把**数据模型数据双向绑定**的思想作为核心，因此在View和Model上没有联系，通过ViewModel进行交互，而Model和ViewModel之间的数据交互是双向的，ViewModel是一个**View 信息 的存储结构**，ViewModel和View上的信息是一一映射关系。

使用 MVVM 模式，程序的 UI 和其背后的展现与业务逻辑将被分离至三个类中

- 视图，封装 UI 与 UI 逻辑。

  负责界面和显示。

- 模型视图，封装展示逻辑和状态(数据、信息)

  负责协调视图与任何需要的模型类的交互。视图模型提供的属性和命令定义了提供给UI 的功能。但是视图定义了如何渲染的功能。

  视图模型是View和Model的桥梁，是对Model的抽象，比如：Model中数据格式是“年月日”，可以在ViewModel中转换Model的数据为“日月年”供View显示。

- 模型，封装程序的业务逻辑以及数据

  模型不关心会被如何显示或是如何被操作，模型也不能包含任何用户使用的与界面相关的逻辑。

使用MVVM的好处：

1. 低耦合。View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。
2. 可重用性。可以把一些视图逻辑放在ViewModel里面，让很多View重用这段视图逻辑。
3. 独立开发。开发人员可以专注业务逻辑与数据的开发（ViewModel）。设计人员可以专注于界面（View）的开发
4. 可测试性。可以针对ViewModel来对界面(View)进行测试

MVVM与MVP的区别：
两者差别不大，但ViewModel 层双向绑定了 View 层和 Model 层，因此，随着 View 层的数据变化，系统会自动修改 Model 层的数据，反之同理。而 Presenter 层是采用手动写方法来调用或者修改 View 层和 Model 层，需要更多的处理。

MVVM 模型中数据绑定方法一般有以下3种：

- 数据劫持
- 发布-订阅模式
- 脏值检查

Vue的MVVM实现是数据劫持

React，单向数据流。本身只是 一个函数 ui = render (data) 官方就这么简单一个公式。加上状态管理等，可以做 MVVM 风格的开发。

不管是 MVC 还是 MVVM ，具体到实际框架，组成成分之间都不会泾渭分明，几种组成成分之间常常有难以划分的模糊地带。如果忽略划分细节从整体来看，Vue 参考但没有完全遵循 MVVM，React 只是一个 View 层。

参考：

- http://c.biancheng.net/view/7743.html
- https://www.jianshu.com/p/9037026513a2



### 进程与线程的区别

进程：是对运行时程序的封装，是一个可拥有资源的独立单位，是**系统可进行资源调度和分配的的基本单位（在引入线程后，已经不是调度的基本单位了），实现了操作系统的并发**；

线程：是进程的子任务，**是CPU调度和分派的基本单位**，**用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位**。每个线程都独自占用一个**虚拟处理器**：独自的**寄存器组**，**指令计数器和处理器状态**。每个线程完成不同的任务，但是**共享同一地址空间**（也就是同样的**动态内存，映射文件，目标代码等等**），**打开的文件队列和其他内核资源**。**进一步提升了操作系统的并发性，因为进程在创建、撤销和切换中，系统会为之付出较大的时间开销，且进程切换不宜太频繁，从而限制了并发程度的进一步提高**

不同的进程拥有不同的内存空间，进程之间需要通信（IPC，进程间通信）

**区别：**

1.  **一个线程只能属于一个进程，而一个进程可以有多个线程**，但至少有一个线程。线程依赖于进程而存在。 
2.  **进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存**。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。） 
3.  **进程是资源分配的最小单位，线程是CPU调度的最小单位**； 
4.  系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／O设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，**进程切换的开销也远大于线程切换的开销**。 
5.  通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。**进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性**。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 
6.  **进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂**。 
7.  **进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉** 
8.  **进程适应于多核、多机分布；线程适用于多核**。



### 线程间通信的方法有哪些（用于同步，保持数据一致性）

**锁机制：包括互斥锁、条件变量、读写锁**

互斥锁提供了以排他方式防止数据结构被并发修改的方法。 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

**wait/notify 等待**

等待通知机制是基于wait和notify方法来实现的，在一个线程内调用该线程锁对象的wait方法，线程将进入等待队列进行等待直到被通知或者被唤醒。

**为什么要必须获取锁？** 因为调用wait方法时，必须要先释放锁，如果没有持有锁将会抛出异常。

wait: 使当前线程放弃同步锁并进入等待，直到其他线程进入此同步锁，并调用notify()方法，或notifyAll()方法唤醒该线程为止。
 notify(): 唤醒此同步锁上等待的第一个调用wait()方法的线程。
 notifyAll(): 唤醒同步锁上调用wait()方法的所有线程。

**Volatile 内存共享**

volatile有两大特性，一是可见性，二是有序性，禁止指令重排序，其中可见性就是可以让线程之间进行通信。

volatile语义保证线程可见性有两个原则保证

所有volatile修饰的变量一旦被某个线程更改，必须立即刷新到主内存 所有volatile修饰的变量在使用之前必须重新读取主内存的值 volatile保证可见性原理图

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/794e5af7d4f34b038e7d11c818479c9f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

工作内存2能够感知到工作内存1更新a值是靠的总线，工作内存1在将值刷新的主内存时必须经过总线，总线就能告知其他线程有值被改变，那么其他线程就会主动读取主内存的值来更新。

CountDownLatch 并发工具

CyclicBarrier 并发工具

**信号量机制(Semaphore)**

包括无名线程信号量和命名线程信号量。

**信号机制(Signal)**

类似进程间的信号处理。

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

参考文章:

1. [进程间和线程间的通信方式](https://juejin.cn/post/6969122698563682311)



### 进程间通信IPC有哪些方法

**管道/匿名管道pipe**

管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。

只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);

单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。

数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

**管道的实质**

管道的实质其实就是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。
 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。
 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。

**管道的局限：**
 管道的主要局限性正体现在它的特点上：

- 只支持单向数据流
- 只能用于具有亲缘关系的进程之间
- 没有名字
- 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）
- 管道所传送的是无格式字节流，这就**要求管道的读出方和写入方必须事先约定好数据的格式**，比如多少字节算作一个消息（或命令、或记录）等等



**有名管道FIFO**

匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。**为了克服这个缺点**，提出了有名管道(FIFO)。
 有名管道不同于匿名管道之处在于它提供了一个**路径名与之关联**，**该路径名以文件形式存在于文件系统中**，这样，**即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信**，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循**先进先出(first in first out)** 对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。**有名管道的名字存在于文件系统中，内容存放在内存中。**



**匿名管道和有名管道总结：**
 （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。
 （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
 （3）**无名管道阻塞问题：**无名管道无需显示打开**，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出**。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，**如果管道发现另一端断开，将自动退出**。
 （4）**有名管道阻塞问题：**有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。



**信号Signal**

信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。

系统消息从一个进程发送到另外一个进程，一般不用于传输数据，而是用于远程传输命令。

如果该进程当前并未处于执行状态，则该信号就有**内核**保存起来，知道该进程回复执行并传递给它为止

如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。

> 内核是一个操作系统的核心。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性。是连接应用程序和硬件的桥梁。



**消息队列Message**

消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。

与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。

另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达

特点：

（1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.
 （2）消息队列允许一个或多个进程向它写入与读取消息.
 （3）管道和消息队列的通信数据都是**先进先出的原则**。
 （4）消息队列可以实现消息的随机查询,消**息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。**
 （5）消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。
 （6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系**统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。**



**共享内存Share Memory**

使得多个进程可以直接读写同一块内存空间，**是最快的可用IPC形式，是针对其他通信机制运行效率较低而设计的**。

为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率

由于多个进程共享一段内存，因此需要依靠某种同步机制（如**信号量**）来达到进程间的同步及互斥

> **信号量(semaphore)**
>
> 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。
>  为了获得共享资源，进程需要执行下列操作：
>  （1）**创建一个信号量**：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。
>  （2）**等待一个信号量**：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。
>  （3）**挂出一个信号量**：该操作将信号量的值加1，也称为V操作。
>
> **信号量与普通整型变量的区别：**
>  （1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；
>  （2）操作也被成为PV原语（P来源于荷兰语proberen"测试"，V来源于荷兰语verhogen"增加"，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；
>
> **信号量与互斥量之间的区别：**
>  （1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。
>  **互斥：**是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
>  **同步：**是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。
>  在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源
>  （2）互斥量值只能为0/1，信号量值可以为非负整数。
>  也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。
>  （3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。

​	

**套接字Socket**

套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。**也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信**。

套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。

> 创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。
>
> “TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。”
>
> 实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。socket是对端口通信开发的工具,它要更底层一些。



### CPU GPU

首先我们要说的是计算机的大脑 - CPU（**C**entral **P**rocessing **U**nit）中央处理器。CPU是计算机里面的一块芯片，上面有一个或者多个核心（core）。我们可以把CPU的一个核心（core）比喻成一个办公室工人，他**功能强大**，上知天文下知地理，琴棋书画无所不能，**它可以串行地一件接着一件处理交给它的任务**。很久之前的时候大多数CPU只有一个核心，不过在现在的硬件设备上CPU通常会有多个核心，因为多核心CPU可以大大提高手机和电脑的运算能力。



图形处理器 - 或者说GPU（**G**raphics **P**rocessing **U**nit）是计算机的另外一个重要组成部分。和功能强大的CPU核心不一样的是，单个GPU核心只能处理一些简单的任务，不过它胜在数量多，单片GPU上会有很多很多的核心可以同时工作，也就是说它的**并行计算能力是非常强**的。图形处理器（GPU）顾名思义一开始就是专门用来处理图形的，所以在说到图形**使用GPU**（using）或者**GPU支持**（backed）时，人们就会联想到图形快速渲染或者流畅的用户体验相关的概念。最近几年来，随着**GPU加速概念**的流行，在GPU上单独进行的计算也变得越来越多了。



### CPU调度策略（CPU调用进程的方式）

首先，我们要明白我们的算法应该让什么更好呢？**面对客户**：银行调度算法的设计目标应该是**用户满意**；而**面对进程**：CPU调度的目标应该是**进程满意**。

那怎么才能让进程满意呢？那就是时间了。

进程希望**尽早地结束任务**，这就是**周转时间(从任务到达到任务结束)要短**，而且希望**用户的操作能够尽快地被响应**，这就是**响应时间(从操作发生到响应)要短**。而且**系统内耗时间要少，吞吐量(任务的完成量)要大**，系统需要把更多的时间用再任务的执行上，而不能老是去做无关紧要的事情，例如：频繁切换任务，切换栈，分配资源等事情。同时，系统还要去合理地调配任务。

**那么，CPU的调度策略如何做到合理呢？**

**首先得明白系统中有以下的几种矛盾。**

**1.吞吐量和响应时间之间有矛盾**

响应时间小=>切换次数多=>系统内耗大=>吞吐量小

由于需要较短的响应时间，那么就得频繁地切换任务，这样系统的很多时间都花在切换任务上面了，系统的内耗大了，吞吐量就小了。

**2.前台任务和后台任务的关注点不同**

前台任务关注响应时间，后台任务关注周转时间。

前台任务例如我们的word文档，我们打一个字，需要立马显示在文档中，这就是word文档这个任务关注的是响应时间；而后台任务中，例如我们的javac编译java代码，它的周转时间要小，即该任务从进入到结束所花的时间要小，即编译完成的时间要小。

**3.IO约束型任务和CPU约束型任务各有各的特点**

IO约束型任务就是使用CPU的时间较少，进行IO操作的时间较长，CPU约束型的任务就是使用CPU的时间较长。

**因此，要做到合理，需要折中、综合考虑以上的几种矛盾。**

**由此，产生了以下一些CPU的调度算法。**

各种CPU调度算法

**批处理时代**

**FCFS, First Come，First Served**

先来先服务的调度算法，哪个任务先进来，就为哪个任务先服务。

**SJF, Shot Job First**

短作业优先，就是哪个任务的服务时间短就先调度哪个

**HRRN，Highest Response Ratio Next**

**高响应比优先**

综合考量进程的两个属性：**等待时间**和**要求服务时间**——等待时间长，要求服务时间短（就是短进程）的进程更容易被选中。

为了量化，我们制定了一个公式：响应比 = （等待时间+要求服务时间）/ 要求服务时间。响应比高的算法会先执行。

**并发时代（伪并发）**

**RR算法,Round Robin**

**按时间片来轮转调度**

那按时间片轮转的调度算法是设置一个时间片，比如为10的CPU时间，然后不停地在A、B、C、D四个进程中切换，每个进程执行时间10，时间到了就切换到下一个进程执行时间10，直到全部执行完毕。

为每个进程分配10的CPU时间，轮转调度执行，这样每个进程的响应时间就变小了。

如果时间片设置过大，那响应的时间就会太长，如果时间片设置过小，那整个系统都在不停地切换进程，系统很多时间都浪费在切换进程上面了，造成系统的吞吐量小，折中考虑后，时间片设置为10~100ms，切换的时间为0.1~1ms.

**VRR算法，Virtual Round Robin**

虚拟轮转法，通过一个辅助队列，解决了I/O密集型进程性能响应问题

> I/O 密集型进程不这么认为，他对我说：“调度器大哥，时间片轮转没有照顾到我们这类进程啊！我们经常在 CPU 没呆到一半时间片，就遇到了阻塞操作，被你赶下去。而且我们在**阻塞队列**，往往要停留很长时间。等阻塞操作结束，我们还得在**就绪队列**排好长时间队。那些处理器密集型进程，使用了大部分的处理器时间，导致我们性能降低，响应时间跟不上”
>
> 考虑到这些进程的要求，我决定为他们创建一个新的辅助队列。阻塞解除的进程，将进入这个辅助队列，进行进程调度时，优先选择辅助队列里的进程。

**优先级调度算法**

每个进程将被赋予一个**优先级**，自己根据自己的情况确定优先级数值，但是，用户进程的优先级**不准高于**内核进程的优先级。

切换程序的时候，我会从优先级 1 的队列里选择一个进程，如果优先级 1 队列为空，才会选择优先级 2 中的进程，以此类推。

当然，为了保证低优先级进程不会**饥饿**，我会调高等待时间长的进程的优先级。

> 进程饥饿，即为Starvation，指当等待时间给进程推进和响应带来明显影响称为进程饥饿。当饥饿到一定程度的进程在等待到即使完成也无实际意义的时候称为饥饿死亡。



**总结：先来先服务算法，短进程优先算法，高响应比优先算法，时间片轮询调度算法，虚拟轮转算法，优先级调度算法。**

**还有一些比如最短剩余时间优先算法，多级队列调度算法等等**

以上算法还可以分类为**抢占式调度和非抢占式调度**

**抢占式调度**

在“抢先式调度”中，大多数任务都分配有其优先级。有时，即使较低优先级的任务仍在运行，在另一个较低优先级的任务之前运行具有较高优先级的任务也很重要。较低优先级的任务会保留一段时间，并在较高优先级的任务完成执行时恢复。

**非抢占式调度**

在这种调度方法中，已将CPU分配给特定的进程。使CPU保持繁忙的进程将通过切换上下文或终止来释放CPU。这是可用于各种硬件平台的唯一方法。那是因为它不需要抢先式调度之类的特殊硬件（例如计时器）。

| **抢占式调度**                                               | **非抢占式调度**                                             |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| 可以抢占处理器以在任何当前进程执行的中间执行不同的进程。     | 处理器开始执行后，必须先执行它，然后再执行另一个。它不能在中间暂停。 |
| 与非抢先式调度相比，CPU利用率更高。                          | 与抢先式调度相比，CPU利用率较低。                            |
| 抢占式调度的等待时间和响应时间更少。                         | 非抢占式调度方法的等待时间和响应时间较长。                   |
| 优先调度优先级高的进程。最高优先级的过程是当前使用的过程。   | 当任何进程进入运行状态时，该进程的状态永远不会从调度程序中删除，直到完成其工作为止。 |
| 抢占式调度非常灵活。                                         | 非抢占式调度是严格的。                                       |
| 示例：最短剩余时间优先，优先级调度算法，最短作业优先，高响应比优先算法等。 | 示例：先到先服务，时间片轮询调度算法等。                     |

> **调度是抢占式还是非抢占式？**
>
> 要确定调度是抢占式还是非抢占式，请考虑以下四个参数：
>
> 1. 进程从运行状态切换到等待状态。
> 2. 特定过程从运行状态切换到就绪状态。
> 3. 特定过程从等待状态切换到就绪状态。
> 4. 进程完成其执行并终止。
>
> **仅条件1和4适用，调度称为非抢先。**
>
> **所有其他调度都是抢占式的。**



参考文章：

​	几种CPU调度策略：https://cloud.tencent.com/developer/article/1472672

​	进程调度， 一个调度器的自白：https://segmentfault.com/a/1190000020525157



### 操作系统基础——进程管理之五状态模型

- 创建状态
- **就绪状态**
- **阻塞状态**
- **执行状态**
- 终止状态

详见：

操作系统基础(三)---进程管理之五状态模型 https://segmentfault.com/a/1190000023024872?hmsr=coffeephp.com&utm_medium=coffeephp.com&utm_source=coffeephp.com



### Restful 表现层状态转化

越来越多的人开始意识到，**网站即软件**，而且是一种新型的软件。

Restful是一种互联网软件架构风格。REST(Representational State Transfer)指的是一组**架构约束条件和规范**。

满足这些约束条件和规范的应用程序就是RESTful。

而Restful正得到越来越多网站的采用

RESTful的核心是**面向资源，降低开发复杂性，提高系统可伸缩性**

REST提出的设计概念和准则是：**网络上的所有事物都可以被抽象为资源，每一个资源都有唯一的资源标识URI（统一资源定位符），对资源的操作不会改变这些标识**

> **表现层（Representation）**
>
> "资源"是一种信息实体，它可以有多种外在表现形式。**我们把"资源"具体呈现出来的形式，叫做它的"表现层"（Representation）。**
>
> 比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。
>
> URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的".html"后缀名是不必要的，因为这个后缀名表示格式，属于"表现层"范畴，而URI应该只代表"资源"的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对"表现层"的描述。
>
>  
>
> **状态转化（State Transfer）**
>
> 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。
>
> 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，**如果客户端想要操作服务器，必须通过某种手段，让服务器端发生"状态转化"（State Transfer）。而这种转化是建立在表现层之上的，所以就是"表现层状态转化"。**
>
> 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：**GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。**

综合上面的解释，我们总结一下什么是RESTful架构：

　　（1）每一个URI代表一种资源；

　　（2）客户端和服务器之间，传递这种资源的某种表现层；

　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。

误区：

1. **最常见的一种设计错误，就是URI包含动词。**因为"资源"表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。
2. **另外一种错误，就是在URI中加入版本号**

参考文章：

- 理解RESTful架构 https://www.ruanyifeng.com/blog/2011/09/restful.html
- Restful https://segmentfault.com/a/1190000023014419



### 装饰器

在TypeScript中，装饰器分为四种：**类装饰器、属性装饰器、方法装饰器和参数装饰器**

**装饰器的本质上是一个函数，用来装饰已经存在对象，为它添加额外的功能**

**类装饰器**

```typescript
declare type classDecorator = <TFunctioin extends Function>(
	target: TFunction
)=>TFunction | void
```

接收一个参数：

- target: TFunction - 被装饰的类

**属性装饰器**

```typescript
declare type propertyDecorator = (
	target: Object,
	propertyKey: string | symbol
)=> void
```

接收两个参数：

- target: Object - 被装饰的类
- propertyKey: string | symbol - 被装饰类的属性名

**方法装饰器**

```typescript
declare type MethodDecorator = <T>(
  target:Object, 
  propertyKey: string | symbol,          
  descriptor: TypePropertyDescript<T>
) => TypedPropertyDescriptor<T> | void;
```

接收三个参数：

- target: Object - 被装饰的类
- propertyKey: string | symbol - 方法名
- descriptor: TypePropertyDescript - 属性描述符

> 属性描述符
>
> ES5之后，所有的属性都存在属性描述符这个属性。获取属性描述符的方法是：
>
> ```javascript
> Object.getOwnPropertyDescriptor
> ```
>
> 属性描述符实际上就是一个对象。属性描述符一共有 6 个属性，可以选择使用。
>
> - value：设置属性值，默认值为 undefined。
> - writable：设置属性值是否可写，默认值为 true。
> - enumerable：设置属性是否可枚举，即是否允许使用 for/in 语句或 Object.keys() 函数遍历访问，默认为 true。
> - configurable：设置是否可设置属性特性，默认为 true。如果为 false，将无法删除该属性，不能够修改属性值，也不能修改属性的属性描述符。
> - get：取值函数，默认为 undefined。
> - set：存值函数，默认为 undefined。

**参数装饰器**

```typescript
declare type ParameterDecorator = (
	target: Object, 
	propertyKey: string | symbol, 
  parameterIndex: number 
) => void
```

接收三个参数：

- target: Object - 被装饰的类
- propertyKey: string | symbol - 方法名
- parameterIndex: number - 方法中参数的索引值

符合面向切面编程的思想，可以方便的完成很多事，如打印日志，性能测试，事务处理等。

**有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。**

装饰器也能自己接收参数，不过写法有变动

```typescript
function decorator(param){
  console.log(`传给装饰器的参数${param}`);
  return function (target,propertyKey,...){
    ...
  }
}
```



### 移动端适配的几种方案

原则

1. 开发时方便，写代码时设置的值要和标注的 xxxpx 相关
2. 方案要适配大多数手机屏幕，并且无 BUG
3. 用户体验要好，页面看着没有不适感

思路

1. 写页面时，按照设计稿写固定宽度，最后再统一缩放处理，在不同手机上都能用
2. 按照设计稿的标准开发页面，在手机上部分内容根据屏幕宽度等比缩放，部分内容按需要变化，需要缩放的元素使用 rem, vw 相对单位，不需要缩放的使用 px
3. 固定尺寸+弹性布局，不需要缩放

**viewport适配**

根据屏幕大小，可以动态的设置meta标签 viewport 的content

缺点就是边线问题，不同尺寸下，边线的粗细是不一样的（等比缩放后），全部元素都是等比缩放，实际显示效果可能不太好

**视口单位vw vh**

1. 开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标注是基于此宽度标注）
2. 开始开发，对设计稿的标注进行转换，把px换成vw。比如页面元素字体标注的大小是32px，换成vw为 (100/750)*32 vw
3. 对于需要等比缩放的元素，CSS使用转换后的单位
4. 对于不需要缩放的元素，比如边框阴影，使用固定单位px

关于换算，为了开发方便，利用自定义属性，CSS变量

**rem适配**

根节点（html）的font-size决定了rem的尺寸，也就是说它是一个相对单位，相对于(html)。

通过动态设置font-size来改变rem尺寸

**弹性布局flex**

是关注的页面的元素的分配空间和对齐方式，是以缩放的比例来进行布局的，正好可以适应不同的屏幕大小来进行适配。

**媒体查询@media**

Media Queries能在不同的条件下使用不同的样式，使页面在不同在终端设备下达到不同的渲染效果。

```css
@media screen and (max-width:480px){
  .ads{
    display:none;
  }
}
当屏幕小于或等于480px时,页面中的广告区块（.ads）都将被隐藏。
```

这些方案都不是独立的，平常做移动端适配时可以多种结合起来使用



### 产品出现Bug的原因及解决方案

1. 前后端使用的框架问题

2. 开发人员经验问题/思维严谨性导致

3. 业务特点导致，需求设计遗漏

4. 上下业务耦合严重导致

5. 测试环境无法重现，可能是线上的环境造成的BUG或者是测试环境无法模拟的情况。

   解决方法：尽量完善测试方法，尽可能模拟仿真线上测试环境，以及增加上线后的复查确认测试。

6. 漏测

   A、测试用例裁剪过度：错误预估优先级或者时间过于紧迫裁剪了用例

   解决方法：在后续版本或者其他项目启动时重新评估测试时间，要求专家介入对优先级进行评估，避免此类事件再次发生。

   B、测试用例执行期间遗漏：由于测试人员疏忽造成测试用例执行遗漏

   解决方法：调查该名测试人员的整个测试过程的工作情况，并随机抽测其他模块，对该名测试人员进行综合评估，给出结论，是因为疏忽漏测，还是因为负责模块过多漏测，还是有其他原因。应该及时反馈给测试经理，并对该测试人员后面的工作进行调整和处理。

   C、测试用例覆盖不全：需求模糊导致的，由于用例评审的不严格造成的;中途需求变更造成的;由于某些其他因素造成的

   解决方法：找到原因，并进行记录，在以后的项目或者下一版本改进。并且要及时增加、补充用例。

https://new.qq.com/omn/20190814/20190814A0H8LZ00.html

https://cxyzjd.com/article/wodeyijia911/83990615



### 扫码登录流程

简述：

首先客户端向服务器发起请求，服务器生成一个随机字符串uuid，将随机字符串作为key值，保存在redis服务器，存储成功后，用这个key值和验证字符串合在一起，通过二维码生成接口，生成一个二维码的图片，将随机字符串和二维码返回给客户端。

>  二维码就是根据某种约定的编码方式将一段文本信息转换为一个能够被解码识别的图片。 其本质就是一段文本信息。
>
> redis是什么
>
> Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性：
>
> - 基于内存运行，性能高效
> - 支持分布式，理论上可以无限扩展
> - key-value存储系统
> - 开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API
>
> 相比于其他数据库类型，Redis具备的特点是：
>
> - C/S通讯模型
> - 单进程单线程模型
> - 丰富的数据类型
> - 操作具有原子性
> - 持久化
> - 高并发读写
> - 支持lua脚本
>
> [redis是什么？看这一篇就够了](https://www.cnblogs.com/powertoolsteam/p/redis.html)

此时客户端接收到二维码展现给用户，并向服务器进行轮询，登录是否成功的请求。请求中携带有uuid作为当前页面的标识符。

用户通过已登录的手机端进行扫码，就可以获得验证信息和uuid，由于手机端已经进行过了登录，在访问手机端的服务器的时候，参数中都会携带一个用户的token，手机端服务器可以从中解析到用户的userId（这里从token中取值而不是手机端直接传userid是为了安全，直接传userid可能会被截获和修改，token是加密的，被修改的风险会小很多）。手机端将解析到的数据和用户token一起作为参数，向服务器发送验证登录请求（这里的服务器是手机服务器，手机端的服务器跟网页端服务器不是同一台服务器）。**服务器收到请求后，首先对比参数中的验证信息，确定是否为用户登录请求接口。**如果是，返回一个确认信息给手机端。

手机端收到返回后，将登录确认框显示给用户（防止用户误操作，同时使登录更加人性化）。用户确认是进行的登录操作后，手机再次发送请求。服务器拿到uuId和userId后，将用户的userid作为value值存入redis中以uuid作为key的键值对中。

这样客户端的轮询时，浏览器端的服务器就可以通过redis得到userid，并调用内部登录的方法，声成一个浏览器端的token，将用户信息返回给浏览器，登录成功。

> 这里存储用户id而不是直接存储用户信息是因为，手机端的用户信息，不一定是和浏览器端的用户信息完全一致。

https://cloud.tencent.com/developer/article/1347341



### 为什么取余数是取余1000000007？

1000000007是最小的十位数质数，这样永远保持范围在int的范围内



### 排序

![](https://www.runoob.com/wp-content/uploads/2019/03/sort.png)

