# 变量提升

变量的赋值可以分为三个阶段：

1. 创建变量，在内存中开辟空间
2. 初始化变量，将变量初始化为undefined
3. 真正赋值



关于`let` `var` 和`function`:

- `let` 的「创建」过程被提升了，但是初始化没有提升。
- `var`的「创建」和「初始化」都被提升了。
- `function`的「创建」「初始化」和「赋值」都被提升了。



例题：

```text
function sayHi() {
  console.log(name);
  console.log(age);
  var name = "Lydia";
  let age = 21;
}

sayHi();
```

- A: `Lydia` 和 `undefined`
- B: `Lydia` 和 `ReferenceError`
- C: `ReferenceError` 和 `21`
- D: `undefined` 和 `ReferenceError`

```
参考答案 D
```

在函数中，我们首先使用`var`关键字声明了`name`变量，这意味着变量在创建阶段会被提升（`JavaScript`会在创建变量创建阶段为其分配内存空间），默认值为`undefined`。直到我们实际执行到使用该变量的行，我们还没有为`name`变量赋值，所以它仍然保持`undefined`的值。

使用`let`关键字（和`const`）声明的变量也会存在变量提升，但与`var`不同，初始化没有被提升。 在我们声明（初始化）它们之前，它们是不可访问的，这被称为“暂时死区”。 当我们在声明变量之前尝试访问变量时，`JavaScript`会抛出一个`ReferenceError`。

关于`let`的是否存在变量提升，我们何以用下面的例子来验证：

```js
let name = 'ConardLi'
{
  console.log(name) // Uncaught ReferenceError: name is not defined
  let name = 'code秘密花园'
}
```

`let`变量如果不存在变量提升，`console.log(name)`就会输出`ConardLi`，结果却抛出了`ReferenceError`，那么这很好的说明了，`let`也存在变量提升，但是它存在一个“暂时死区”，在变量未初始化或赋值前不允许访问。



综上，变量提升不是指直接把创建变量的这句话提到代码最上面，可能指只有第一阶段，可能只有第一、二阶段，还可能三个阶段都有。