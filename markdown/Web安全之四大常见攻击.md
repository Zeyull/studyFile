# Web安全

##  前言

用户信息泄露、网站被黑甚至网银被盗用的事件屡见不鲜，Web安全问题理应得到前端的更多的重视，大前端要“把手伸得更远一点”。

## DoS攻击

拒绝服务攻击DoS（Denial of Service）：使系统过于忙碌不能响应正常有用的业务服务并且占尽关键系统资源。

它是基于这样的思想：**用数据包淹没本地系统，以打扰或严重阻止捆绑本地的服务器响应外来合法的请求，甚至使本地系统崩溃。**

常见的方式有：

- TCP SYN泛洪
- ping泛洪
- UDP泛洪
- 分片炸弹
- 缓冲区溢出
- ICMP路由重定向炸弹

### TCP SYN泛洪

TCP SYN泛洪（SYN Flood）是**利用TCP建立连接时需要进行三次握手的过程，并结合IP源地址欺骗实现的**。

> 攻击者将其自身的源地址伪装成一个私有地址向本地系统的TCP服务发起连接请求，本地TCP服务回复一个SYN-ACK作为响应，然而该响应发往的地址并非攻击者的地址(真实地址)，而是攻击者伪装的私有地址。由于该私有地址是不存在的于本地服务器所在的网络的，所有本地系统将收不到RST消息(以结束这个半打开连接)。本地TCP服务接下来要等待接收一个ACK回应，但是该回应永远不会到来，该半打开连接会保持打开状态直至连接尝试超时，因此有限的连接资源被消耗了。攻击者连接请求的到来比TCP超时释放资源更快，利用一次又一次的连接请求淹没本地连接资源(如通过listen()创建的大小有限的连接队列等)，以致本地服务无法接收更多的连接请求。
>
> Linux操作系统中的SYN cookie模块能显著的延缓SYN泛洪造成的网络资源缺失现象：在TCP服务接收到TCP SYN包并返回SYN-ACK时，不分配一个专门的数据区，而是根据这个SYN包计算一个cookie值。cookie值是一个基于SYN中的原始序列号、源地址、目的地址、端口号、密值而产生的序列号。cookie作为将要返回的SYN-ACK的初始序列号，当客户返回一个ACK包，TCP服务在根据cookie值检查该ACK包的合法性，再分配专门的数据区进行处理接下来操作。cookie的超时时间很短暂，客户端必须在很短时间内进行应答。
>
> 还可以通过控制队列大小和队列满时应做的处理来**抵御SYN攻击**
>
> echo 1 > /proc/sys/net/ipv4/tcp_syncookies 命令可以打开Linux内核的SYN cookie保护功能；需要注意一些发行版需要配置内核才能打开。
>
> 
>
> 正常流程：存在SYN队列和Accept队列，只有接收到了客户端的ACK报文后才能把SYN队列里的内容放在Accept队列中

### ping泛洪

ping泛洪（ping-Flood），攻击者通过ping发送的ICMP的echo请求消息也是常见的DoS攻击方式之一，其原理是**强制让系统消耗大多数时间进行无用的应答，降低系统网络质量**。

> 主要实现的方法有：
>
> ①将ping包的源地址伪装成受害者的地址并向整个主机所在的网络广播echo请求，这样的请求消息能够造成很多的响应发送的受害者机器；
>
> ②通过互联网在受害者机器安装木马程序并在某时刻向某主机发送大量echo请求；
>
> ③攻击者发送更多简单的ping泛洪来淹没数据连接。
>
> 一种更为古老的攻击方式叫做死亡之ping，攻击者会发送巨大的ping数据包给受害机器，易受攻击的系统可能因此崩溃，Linux等类UNIX系统并没有此漏洞。对于受害主机来说，丢弃ping请求并不是一个很好的解决方案，因为不论是对到来的ping包做什么反应，系统或者网络依旧会被淹没在检测/丢弃数据包的过程中。

### UDP泛洪

UDP泛洪（UDP-Flood），不同于TCP，UDP是**无状态**的，没有任何信息被维护以指明下一个期望到来的数据包，所以UDP服务更易受这些类型攻击的影响，许多站点都禁止用所有非必要的UDP端口。

> 无状态协议（Stateless Protocol）是指浏览器对于事物的处理没有记忆功能

### 缓冲区溢出

缓冲区溢出（buffer overflow），缓冲区溢出攻击是无法通过过滤防火墙进行保护的，通过覆盖程序的数据空间或者运行时的堆栈导致系统或者服务崩溃，这需要专业技术以及对硬件、系统软件的了解。

> 举个例子，早期有服务器程序使用了sprintf()函数而被攻击者攻击，因为缓冲区溢出而使得程序崩溃，所以更为妥当的做法是使用**snprintf**()代替sprintf()。

### ICMP路由重定向炸弹

ICMP路由重定向炸弹(ICMP routeing redirect bomb)，

> 我们知道ICMP的消息类型中的类型5是告知目标系统改变内存中的路由表以获得更短的路由，以通知主机有更多的路径可用。重定向很少发源主机附近的路由器，对于连接到ISP(运营商)的住宅或商用站点来说，主机附近的路由器产生一个重定向的ICMP消息可能性非常小。如果我们主机使用静态路由且收到了重定向消息，这可能是有人在攻击我们系统，欺骗主机以转发所有流量到另一远处主机处。

### 分片炸弹

分片炸弹(fragmentation bombs)，

> 我们知道数据包从一个路由器沿路径(源计算机到目的计算机的路径)到下一个路由器时，网关路由器可能需要在它们进行传递到下一个网络前将数据包分切为更小的片段(超过MTU值会被分片)，在这些片段里第一个分片会包含UDP或者TCP报头中的源端口号和目的端口号，接下来的分片并不包含。当数据包被分片时中间路由器不会重组数据包，数据包到达目的主机或邻近路由器时才会重新组装。
>
> 分片炸弹的实现是构造一种非常小的数据包导致系统或者程序崩溃的操作：比如构造一个最初的分片使得UDP或者TCP的源端口和目的端口被包含在第二个分片中。许多防火墙并不检查第一个分片之后的分片，然而第一个分片由于防火墙所要过滤的信息还未呈现，所以得以通过，那么最终所有分片都在主机中得以组装。
>
> 另外，因为中间进行分片基本上比发送更小的无需分片的数据包代价更高，所以一般会在发送在IP报头中设置了不分片标志，设置后系统会向目标主机发起连接前进行MTU发现，如果中间路由器必须对数据包进行分片那么它会丢弃数据包并赶回ICMP 3错误消息，即“需要分片”。

### DDOS攻击

分布式拒绝服务攻击（Distributed Denial of Service）

> 简单说就是发送大量请求是使服务器瘫痪。DDos攻击是在DOS攻击基础上的，可以通俗理解，dos是单挑，而ddos是群殴，因为现代技术的发展，dos攻击的杀伤力降低，所以出现了DDOS，攻击者借助公共网络，将大数量的计算机设备联合起来，向一个或多个目标进行攻击。

### 针对DoS攻击的防御

- 缩短SYN超时时间，以减少缓冲区中保留的半连接个数。
- 限制同时打开的半连接个数，当半连接个数已经达到上限时，后面未成功的TCP连接将被丢弃而不会保存在缓冲区中。
- 设置SYN Cookie，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被一概丢弃。
         一般来说，第三种方法在防范该类问题上表现更佳。同时可以在Web服务器端采用分布式组网、负载均衡、提升系统容量等可靠性措施，增强总体服务能力。


## CSRF攻击

跨站请求伪造CSRF（Cross-site request forgery）是一种挟持用户在当前已登录的Web应用程序上执行非本意的操作的一种攻击方式。CSRF攻击的本质在于**利用用户的身份，执行非本意的操作。**根据CSRF的全名，可以得出的结论是：**CSRF的请求是跨域且伪造的。**

> **跨域**指的是请求来源于其他网站。比如说，目标网站上的删除文章功能接收到来自其他网站的删除文章的请求，那么这个请求就是跨域的。
>
> **伪造**指的是如果这个请求不是用户自身的意愿，那么这个请求就是伪造的。
>
> 简单的说，跨站请求伪造的攻击是攻击者通过一些技术手段欺骗用户的浏览器去访问用户曾经认证过的网站并执行一些操作（如发送邮件、发消息、甚至财产操作如转账和购买商品等）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web登录身份认证的一个漏洞：**简单的身份认证只能保证请求来自用户的浏览器，但不能识别请求是用户自愿发出的。**

CSRF分类有：.

- GET CSRF
- POST CSRF

假如有这么一个场景，目标网站A的url：www.a.com。恶意网站B的url：www.b.com。

### GET CSRF

两个网站的域名不一样，目标网站A上有一个删除文章的功能，通常是用户单击’删除文章‘链接时才会删除指定的文章。这个链接是www.a.com/blog/del?id=1, id代表不同的文章。实际上就是发起一个GET请求。

如何攻击呢？

1.无法使用Ajax发起GET请求。因为CSRF请求是跨域的，而Ajax有同源策略的限制。

2.可以通过在恶意网站B上静态或者动态创建img,script等标签发起GET请求。将其src属性指向www.a.com/blog/del?id=1。通过标签的方式发起的请求不受同源策略的限制。

 3.最后欺骗已经登录目标网站A的用户访问恶意网站B，那么攻击就会发生。此时恶意网站B的请求是身份认证后的。

CSRF攻击有以下几个关键点

1. 请求是跨域的。可以看出请求是从恶意网站B上发出的
2. 通过img, script等标签来发起一个GET请求。因为这些标签不受同源策略的限制
3. 发出的请求是身份认证后的。这一点是CSRF中最重要的一点。



恶意网站B发出的删除文章的GET请求的请求头

```
GET /blog/del?id=1 HTTP/1.1
Host: www.a.com
* Referer: http://www.b.com/csrf.html
Connection: Keep-Alive
Cookie: name=kk
Other-Request-Name: Other-Request-Value:
```

目标网站A发出的删除文章的GET请求的请求头

```
GET /blog/del?id=1 HTTP/1.1
Host: www.a.com
* Referer: http://www.a.com/blog/
Connection: Keep-Alive
Cookie: name=kk
Other-Request-Name: Other-Request-Value:
```

对比以上的代码可以看出，只有Referer字段不同。也就是说，只有请求来源不相同，而发送删除文章的请求时都会带上相同的cookie信息。这样的请求就是身份认证后的，CSRF攻击就会成功。

### POST CSRF

与GET CSRF类似，POST请求实际上就是在恶意网站B上发起一个POST请求，同样的，这个请求也是跨域和身份认证后的。如静态或动态的创建一个form表单，当用户访问到这个恶意网站B时，就会提交这个表单。



### CSRF欺骗流程

以上说了GET和POST的CSRF攻击。本质上都是欺骗用户以自己的身份去执行非本意的操作。欺骗流程大致如下

首先欺骗用户登录目标网站， 然后欺骗用户登录恶意网站。这种恶意的网站有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。

### CSRF危害

1. 模拟表单提交盗取用户资金。实际上就是上面所说的POST CSRF攻击
2. 篡改目标网站上的用户数据。
3. 盗取用户隐私数据

### CSRF防范

1. 检测请求头中的Referer字段
2. 非GET请求中添加验证token

## XSS漏洞

跨站脚本攻击XSS（Cross Site Scripting）XSS的原理是黑客向Web页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中Web里面的脚本代码会被执行，从而可以达到黑客盗取用户信息或其他侵犯用户安全隐私的目的。

XSS攻击方式：

- 反射型XSS
- 存储型XSS
- DOM XSS

### 反射型XSS

反射型XSS，也叫非持久型XSS，是指发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后浏览器解析并执行。

从概念上可以看出，反射型XSS代码是**首先**出现在URL中的，**然后**需要服务端解析，**最后**需要浏览器解析之后XSS代码才能够攻击。

### 存储型XSS

存储型XSS，也叫持久型XSS，主要是将XSS代码发送到服务器（不管是数据库、内存还是文件系统等），然后在下次请求页面的时候就不用带上XSS代码了。

最典型的就是留言板XSS。用户提交了一条包含XSS代码的留言到数据库。当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。XSS攻击就发生了。

### DOM XSS

DOM XSS攻击不同于反射型XSS和存储型XSS，DOM XSS代码不需要服务器端的解析响应的直接参与，而是通过浏览器端的DOM解析。这完全是客户端的事情。

DOM XSS代码的攻击发生的可能在于我们编写JS代码造成的。我们知道eval语句有一个作用是将一段字符串转换为真正的JS语句，因此在JS中使用eval是很危险的事情，容易造成XSS攻击。避免使用eval语句。

### XSS危害

- 通过document.cookie盗取cookie
- 使用js或css破坏页面正常的结构与样式
- 流量劫持（通过访问某段具有window.location.href定位到其他页面）
- DoS攻击
- 利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。
- 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。

### XSS防御

从以上的反射型和DOM XSS攻击可以看出，我们不能原样的将用户输入的数据直接存到服务器，需要对数据进行一些处理。以上的代码出现的一些问题如下

1. 没有过滤危险的DOM节点。如具有执行脚本能力的script, 具有显示广告和图片的img, 具有改变样式的link, style, 具有内嵌页面的iframe, frame等元素节点。

2. 没有过滤危险的属性节点。如事件, style, src, href等

3. 没有对cookie设置httpOnly。

   

   解决方法：

   cookie设置httpOnly。

   对用户输入的数据进行处理

   1. 编码，不能对用户输入的内容都保持原样，对用户输入的数据进行字符实体编码。
   2. 解码，原样显示内容的时候必须解码，不然显示不到内容了。
   3. 过滤，把输入的一些不合法的东西都过滤掉，从而保证安全性。如移除用户上传DOM属性，如onerror，移除用户上传的Style节点，iframe,script节点等。

## SQL注入

SQL注入是比较常见的网络攻击方式之一，主要是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，实现无帐号登录，甚至篡改**数据库**。

### SQL注入攻击的总体思路

 1.寻找到SQL注入的位置

 2.判断服务器类型和后台数据库类型

 3.针对不通的服务器和数据库特点进行SQL注入攻击

### SQL注入的危害

- 数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。
- 网页篡改：通过操作数据库对特定网页进行篡改。
- 数据库被恶意操作：数据库服务器被攻击
- 服务器被远程控制，被安装后门
- 删除和修改数据库信息

### 防止SQL注入的方式

　　通常情况下，SQL注入的位置包括：

　　（1）表单提交，主要是POST请求，也包括GET请求；

　　（2）URL参数提交，主要为GET请求参数；

　　（3）Cookie参数提交；

　　（4）HTTP请求头部的一些可修改的值，比如Referer、User_Agent等；

​	防止SQL注入的解决方案

　　1）对用户的输入进行校验，使用正则表达式过滤传入的参数，字符串过滤

　　2）使用参数化语句，不要拼接sql，也可以使用安全的存储过程

　　3）不要使用管理员权限的数据库连接，为每个应用使用权限有限的数据库连接

　　4）检查数据存储类型

　　5）重要的信息一定要加密

​	总之就是既要做好过滤与编码并使用参数化语句，也要把重要的信息进行加密处理，这样sql注入漏洞才能更好的解决。

参考链接：

- 常见的DoS攻击：https://blog.csdn.net/qq_29344757/article/details/86658936

- 前端安全之CSRF攻击：https://www.cnblogs.com/unclekeith/p/7788057.html

- 前端安全之XSS：https://www.cnblogs.com/unclekeith/p/7750681.html

- 详解Web安全攻防战：https://blog.csdn.net/weixin_41631970/article/details/88908482

- Web安全漏洞防御详解：https://www.cnblogs.com/xulinmei/p/10271315.html

- web前端安全——常见的web攻击方法：https://www.cnblogs.com/zhaoxinran997/p/12146579.html