# 面试Q&A

字节的一个面试题，一个东西，settime就出一个，可以随时终止，利用异步的思想。

赛马问题。



### 编译性语言和解释性语言

高级语言若想被计算机执行，都必须将其转换为计算机语言，也就是机器码。而转换的方式有两种：

**编译**与**解释**

所以高级语言也分为**编译型语言（C C++）和解释性语言（Python JS）** 

> JS是脚本语言，脚本语言不需要编译，是由js解释器逐行解释并执行的

**主要区别在于，前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。**

**编译性语言**

特点：

在编译型语言写的程序执行之前，**需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可**，如直接运行exe文件。**因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。**

总结：

1.一次性的编译成平台相关的机器语言文件，**运行时脱离开发环境，运行效率高**；

2.与特定平台相关，一般无法移植到其他平台；

**解释性语言**

特点：

解释型语言**不需要事先编译，其直接将源代码解释成机器码并立即执行**，所以只要**某一平台提供了相应的解释器即可运行该程序。**

总结：

1.解释型语言每次运行都需要将源代码解释称机器码并执行，**效率较低**；

2.只要平台提供相应的解释器，就可以运行源代码，所以可以**方便源程序移植**；

**两者各有利弊**

前者由于**程序执行速度快，同等条件下对系统要求较低**，因此像**开发操作系统、大型应用程序、数据库系统**等时都采用它

而一些网页脚本、服务器脚本及辅助开发接口这样的**对速度要求不高、对不同系统平台间的兼容性有一定要求**的程序则通常使用解释性语言

> JAVA即是编译的，也是解释的。非要归类的话，从概念上来讲，应该会定义到解释性语言中
>
> JAVA先编译，但编译后不能直接运行，要通过JVM来解释运行，所以是解释语言（但现在的JVM有一些有JIT优化，它又会把.class的二进制代码编译为本地的代码直接运行，就又是编译语言了）



### 说几个Git常用的命令

git clone 克隆仓库内容到本地

git init + git remote add origin + 仓库地址 	初始化&配置仓库地址

git add 从工作区保存到暂存区

git commit 从暂存区提交到本地仓库

git push 将本地仓库的代码传到远程仓库

git pull 拉取/同步远程仓库的代码

git status -s 查看工作区状态



### 提交时发生冲突，解释下开发中冲突是如何产生的，你是如何解决的

我们小组开发过程中，我们都有自己的分支，所以冲突发生的并不多，但也碰到过。

**修改公共文件的时候，一个人先提交一个人再提交就会产生冲突的错误**

发生冲突时，我会和同学沟通，将远程仓库中的内容手动修改到本地，提交冲突文件保证与远程的文件一致，这样才会消除冲突，然后再提交自己的部分

通过一些命令进行解决

1. git stash命令，把工作区的修改提交到栈区，目的是保存工作区的修改
2. git pull命令，拉取远程上的文件合并到本地，目的是消除冲突
3. git stash pop命令，把保存在栈区的修改部分合并到最新的工作区

> 什么时候会使用git stash命令？
>
> - 解决冲突文件时，会先执行git stash，然后解决冲突
> - 遇到紧急开发任务但目前任务不能提交时，会先执行git stash，然后进行紧急任务的开发，然后通过git stash pop取出栈区的内容继续开发
> - 切换分支时，当前工作空间内容不能提交时，会先执行git stash再进行分支切换



### Git的撤销与回滚

**在git commit之前**

在git commit之前，未添加添加到暂存区的撤销：git checkout -- filename来撤销修改

在git commit之前，已添加到暂存区的撤销：git reset HEAD file

**在git commit之后**

使用git revert + commit id(通过git log 查看记录，用reset也行)

> 还有就是如果想回到之前某个版本，可以用reset命令，可以回退到某次提交，那该提交之后的提交都会回滚，不过这种覆盖是不可逆的，之前的提交记录都没有了(但git revert 不会)。所以平时开发中尽量注意，避免使用reset。
>
> 用法：git  reset --hard  commit_id



### 网页加载慢，如何进行前端的性能优化

答5点

**减少HTTP请求次数**，每次HTTP请求都有成本的，既包含时间成本也包含资源成本。另外浏览器进行并发请求的请求数量是有上限的，请求数增多，浏览器会进行分批次请求。如何实现减少HTTP请求呢？

1. 从设计层面简化页面，保持页面简洁，减少资源是最直接的方法
2. 设置合理的HTTP缓存。对于很少变化的图片资源可以设置很长的过期时间，对于变化不频繁的资源可以使用Last-Modified或者E-tag进行验证，尽可能让资源在缓存中呆的久一点
3. 资源的合并与压缩，尽量把外部脚本、样式进行合并，多个合为一个。响应的图片、视频、JS文件、CSS文件都可以使用相应的工具压缩
4. 使用CSS 精灵图 CSS Sprites，合并CSS请求的图片，是减少请求次数的一个好办法，background-position
5. 使用懒加载图片，这种情况下能减少页面初始化时HTTP请求数，只有在用户向下滚动屏幕时才会再次请求加载
6. 使用更高版本的HTTP，在HTTP2中会采用多路复用，浏览器推送等优化机制

**在渲染页面时的优化**，解析html时，遇到一些链接资源，会单独开启下载线程去下载资源

1. 对于CSS资源，虽然下载时异步，不会阻止浏览器构建DOM树，但是会阻塞渲染，在构建render树时，要等待CSS下载完毕后才执行（这里是浏览器自带的优化，避免了重复构建），但声明了media query的CSS不会阻塞渲染
2. 对于JS资源，会阻塞浏览器的解析，只有等待脚本下载完并执行后才会继续解析HTML，但加上了async和defer后，脚本就变成异步的了，可以等HTML解析完毕后再执行

> defer和async是有区别的： **defer是延迟执行，而async是异步执行。**但只要是JS执行，就会暂停HTML解析
>
> - `async`是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在`onload`前，但不确定在`DO会MContentLoaded`事件的前或后
> - `defer`是延迟执行，在浏览器看起来的效果像是将脚本放在了`body`后面一样，等待HTML解析完毕后才执行脚本（虽然按规范应该是在`DOMContentLoaded`事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）

**通过原生JS的技巧来进行性能优化**

1. 在JS代码解析过程中减少**回流和重绘**，每次回流和重绘会造成额外的计算消耗，通过减少回流和重绘，可以提升页面性能
   1. 最小化重绘和回流，多次修改CSS样式可以改成采用cssText和修改css class；
   2. 批量修改DOM，先让DOM脱离文档流，对其进行多次修改，再将元素带回到文档流中。如隐藏文档，拷贝文档
   3. 使用CSS3硬件加速（GPU加速），让一些动画不会引起回流和重绘
   4. 使用虚拟DOM，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。
2. **事件委托**，通过事件委托减少内存消耗，因为访问的DOM减少了，设置事件处理程序所需时间更少, 加快了整个页面的交互就绪时间，还可以动态绑定事件，减少重复的工作

**使用CDN加速**，能够使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率，就算一个服务器或者源服务器宕机了，还有其他CDN缓存服务器可以提供资源。

​	如何做到加速的呢？CDN 网站的内容缓存在网络边缘。不同地区的用户就会访问到离自己最近的相同网络线路上的CDN节点。当请求达到CDN节点后，节点会判断自己的内容缓存是否有效，如果有效，则立即响应缓存内容给用户，从而加快响应速度。

​	CDN是在DNS解析的过程中起作用的，当给一个域名开通了CDN，要先给**这个域名的DNS解析设置的后台**添加一条CDN专用的解析记录，这条解析记录会让域名被解析后指向**一个CDN网络专用的处理DNS请求的服务器**，这个CDN专用的处理DNS请求的服务器会给浏览器返回**一台专门用来给各个请求分配合适CDN服务器的服务器的IP**地址，这种服务器叫负载均衡系统服务器。然后浏览器就会去访问这台负载均衡系统浏览器，负载均衡服务器会根据你浏览器的网络地址，在CDN网络中找**一台在各种条件下都比较适合给你设备提供服务的服务器**，将这个服务器的IP返回给你的浏览器，那么浏览器在收到这个IP地址后，就会去访问这台CDN服务器了，去请求文件资源了

> 不同地区的用户会访问到离自己最近的相同网络线路上的CDN节点，当请求达到CDN节点后，节点会判断自己的内容缓存是否有效，如果有效，则立即响应缓存内容给用户，从而加快响应速度。如果CDN节点的缓存失效，它会根据服务配置去**一层一层的向上**获取最新的资源响应给用户，并将内容缓存下来以便响应给后续访问的用户，这就意味着一个地区的用户只需要访问一次服务器，后续的用户都能因此受益。

**预解析DNS**。通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以尽快地完成 DNS 解析。

​	通过设置X-DNS-Prefetch-Control头控制浏览器的DNS预解析功能。先在meta信息告诉浏览器开启X-DNS-Prefetch-Control，再在link里面强制对DNS进行预解析

> 浏览器会对 a 标签的 href 自动启用 DNS Prefetching，所以 a 标签里包含的域名不需要在 head 中手动设置 link。但是在 HTTPS 下不起作用，需要 meta 来强制开启功能



### 什么是负载均衡

负载均衡是一种策略，将外部发来的请求均匀分配到某一台服务器中，接收到请求的服务器独立地回应客户的请求

优点：

1. 解决网络拥塞问题，服务就近提供，实现地理位置无关性；
2. 为用户提供更好的访问质量；
3. 提高服务器响应速度；
4. 提高服务器及其他资源的利用效率。

常见的软件负载均衡技术有：

1. 基于DNS的负载均衡
2. 反向代理负载均衡
3. 基于NAT的负载均衡

> Nginx的负载均衡常用算法
>
> 1. 轮询
> 2. 加权轮询
> 3. IP哈希
> 4. URL_hash



### Cookie与Session的区别：

1. Cookie与Session都是会话技术（跟踪会话），Cookie保存在客户端上，Session保存在服务器端上，当服务器访问量增多，Session会比较占服务器的性能
2. Cookie有大小限制（3K）以及浏览器存在的Cookie的个数也有限制；理论上来说Session是没有大小限制的，Session大小与服务器内存大小有关
3. Cookie存在安全隐患，通过拦截或本地文件能找到受害者的cookie并利用攻击，所以重要的用户数据存储在session中，cookie可以存储其他数据
4. 若未设置过期时间，cookie的生命周期为浏览器会话时间，若设置了有效期的cookie不会随着浏览器的关闭而消失，而是到了有效期才会消失。Session的默认有效期是30min，服务器可以自己配置。

> 存储的位置
>
> cookie：设置了失效时间的话，存在本地；如果没有设置，就存在浏览器里，可以在设置里面找到存储的cookie
>
> localStorage：每个浏览器都会把localStorage存储在自己的UserData中



### 关于Token

token的意思是“令牌”，是服务器生成的一串字符串，**作为客户端进行请求的一个标识**

> 当用户第一次登录后，服务器生成了一个token并返回这个token给客户端，客户端之后只需要带上这个token前来请求数据即可，无需再带上用户名和密码
>
> 简单的token的组成：
>
> uid（用户唯一的身份标识符），time（当前时间的时间戳），sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串，为防止token泄露）

为什么要使用token？

- Token是无状态、可扩展的，可以在多个服务器之间共享
- Token完全由应用管理，所以它可以避开同源策略
- Token可以避免CSRF攻击

因为http协议是无状态的，为了区别每个用户的信息，现在一般网页用户登录使用Token机制进行区别，如果使用session辨别用户，当用户数量过大时，这是对服务器巨大的开销，而且严重限制了服务器的扩展能力。所以使用token让用户自己存储，每次请求携带，服务器通过Hash算法和密钥进行解析判断，这样服务器的资源开销减小了，也更容易进行扩展。



### HTTP1.0 1.1 2

**HTTP/1.1相比HTTP/1.0性能上的改进：**

1. 长连接(Persistent Connection)： HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。
2. 节约带宽：HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。
3. HOST域：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。
4. 缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
5. 错误通知的管理： 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
6. 支持管道(pipeline)网络传输，只要第一个请求发送出去了，**不必等其回来**，就可以发第二个请求出去，可以减少整体的响应时间

HTTP/1.1的**性能瓶颈**

- 请求/响应头**未经过压缩就发送**，首部信息越多延迟越大。只能压缩body部分
- **发送冗长的首部。**每次互相发送相同的首部造成的浪费较多
- 服务器是按请求的顺序响应的，如果服务器响应不到数据，会导致客户端一直请求不到数据，也就是**队头阻塞**
- **没有请求的优先级控制**
- **请求只能从客户端开始，服务器只能被动响应**



**HTTP2基于HTTP1.1的优化**：

HTTP2协议是基于HTTPS的，所以HTTP2的安全性是有保证的。

1. 多路复用：HTTP/2**是在一个连接中并发多个请求或回应，而不用按照顺序一一对应**。移除了HTTP/1.1中串行请求，不需要排队等待，也不会出现队头阻塞问题，降低了延迟，大幅度提高了连接的利用率。

2. 头部数据压缩：HTTP1.1不支持header数据的压缩，HTTP2.0使用**HPACK算法**对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。

   > 如果你同时发送多个请求，它们的头是一样或者相似的，那么协议会帮你**消除重复的部分**。
   >
   > HPACK算法：在客户端和服务器同时维护一张头信息表，所有的字段都会存入这张表，生成一个索引号，以后就不发同样的字段了，**只发索引号**，这样就提高速度了

3. 服务器推送：**服务端推送是一种在客户端请求之前发送数据的机制**。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。**因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的**。为了改善延迟，HTTP2引入了**server push**，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。

4. 二进制协议：HTTP2不再像HTTP/1.1里的纯文本形式的报文，而是全面采用了**二进制模式**，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。虽然这样对人友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，**无需再将明文的报文转成二进制，而是直接解析二进制报文，这样增加了数据传输的效率**

5. 数据流：HTTP/2的数据包不是按顺序发送的，同一个连接里面连续的数据包，**可能属于不同的回应**。因此必须要对每个数据包做标记，指出它属于哪个回应。所以每个请求或者回应的所有的数据包，被称为一个**数据流**，每个数据流都有独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。**客户端还能指定数据流的优先级。优先级高的请求，服务器就先响应**。



### HTTP/2有哪些缺陷？HTTP/3做了哪些优化？

HTTP/2的主要问题在于，**多个HTTP请求在复用一个TCP连接**，下层的TCP协议是不知道有多少个HTTP请求的。如果**一旦发生了丢包现象**，就会触发TCP的重传机制，这样在一个TCP连接中的**所有的HTTP请求都必须等待这个丢了的包被重传回来**。

- HTTP/1.1中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了
- HTTP/2多个请求复用一个TCP连接，一旦发生丢包，就会阻塞所有的HTTP请求

**优化**

这是基于传输层的问题，所以**HTTP/3把HTTP下层的TCP协议改成了UDP协议！！！**

因为UDP发送不管顺序，也不管丢包的，所以不会出现上述的阻塞问题

虽然UDP是不可靠传输，但基于UDP的**QUIC协议**可以实现类似TCP的可靠性传输

- QUIC有自己的一套机制可以保证传输的可靠性。当某个流发生丢失时，只会阻塞这个流，**不会影响其他流**
- TLS3**升级成了最新的1.3版本**，头部压缩算法**也升级成了QPack**
- HTTPS要建立一次连接，要花费六次交互，先是建立三次握手，然后是TLS/1.3的三次握手。QUIC直接把以前的六次交互合并成了3次，减少了交互次数

> QUIC是一个新协议，是一个在UDP之上的伪TCP+TLS+HTTP/2的多路复用的协议
>
> 对于很多网络设备来说，根本不知道什么是QUIC，只会被当做UDP来处理，所以现在HTTP/3的普及进度非常慢



### HTTP请求的方法有哪些

HTTP/1.0定义了三种请求方法：GET，POST和HEAD方法

HTTP/1.1新增了五种请求方法: OPTIONS,PUT,DELETE,TRACE和CONNECT方法

- GET: **请求指定的页面信息**，并返回实体主体
- HEAD: 类似于get请求，只不过返回的响应中**没有具体的内容**，只用于获取报头
- POST: **向指定资源提交数据进行处理请求**（如表单提交和上传文件）数据被包含在请求体中。POST请求可能会导致新的资源建立或修改已有的资源
- PUT: 从客户端向服务器传送的数据**取代指定文档的内容**
- DELETE: 请求服务器**删除指定页面**
- CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器？
- OPTIONS: 允许客户端**查看服务器性能**
- TRACE: **回显服务器收到的请求，主要用于测试或诊断**

> 注意：
> 1）**方法名称是区分大小写的**，当**某个请求所针对的资源**不支持对应的请求方法的时候，服务器应当返回状态码405（Mothod Not Allowed）；当**服务器**不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented）
> 2）HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持**扩展自定义的方法**。



### Get和Post的区别

Get和Post实质上没有区别，只是报文格式的不同。

Get和Post只是HTTP协议中两种请求方式，而HTTP协议是基于TCP/IP的关于数据如何在网络上通信的协议。

所以GET和Post的底层也是TCP/IP，能做的事是一样的，要给Get加上request body或者要给post带上url参数，技术上是可以实现的（服务端要能处理）。**HTTP只是个行为准则，规定了Get，Post的语法，而TCP才是GET和POST怎么实现的基本**。

> 注意：
>
> 有些说法说的是Get只产生一个TCP数据包，而Post要产生两个数据包。对于get请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于post，浏览器会先发送header，服务器响应100 continue，浏览器才会再次发送data，服务器响应200
>
> 但是不是说post性能就比get差，在网络好的情况下，一次与两次的区别并不大，而网络不好的情况下，两次TCP都会验证数据完整性，是个非常大的优点。而且不是所有的浏览器都会分开发送，比如firefox chrome就不会，这不是post的必然行为
>
> 注意：
>
> Get方法参数写法不是固定的，在?后面写&只是约定中的写法。服务端解析TCP报文，用正则等工具获取Header和Body，从里面获取参数，所以我们可以自定义约定参数的写法

但是Get和Post在使用时确实是有区别的，但这些区别要么是协议规定的，要么是浏览器、服务器约束的：

- Get的请求在参数在URL上，而Post在Request Body上，所以Get不能用来传递敏感信息（但实际上都不是安全的）
- Get的请求参数有长度限制，而Post的没有（这是个错误的说法，Get和Post都没有限制，只是浏览器有限制）
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
- Get在回退时是无害的，而Post会再次提交请求
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

.....等等 之类的（后面可答可不答）

- GET产生的URL地址可以被Bookmark，而POST不可以
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。



GET和POST方法都是安全和幂等的吗？

- 在HTTP协议里，所谓的`安全`是指请求方法不会`破坏`服务器上的资源
- 所谓的`幂等`，意思就是**多次执行相同的操作，结果都是相同的**

很明显**GET**方法就是**安全且幂等**的，只是因为它是只读操作，无论操作多次，服务器上的数据都是安全的，且每次结果都是相同的

POST因为是**新增或是提交数据**的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以是不幂等的 



### 详解一下Event Loop事件循环工作机制

首先我们说JS是个单线程的语言，在浏览器的单个Tab页，也就是单个**浏览器渲染进程**中**JS引擎线程**只有一个。

然后JS的代码分为**同步任务**和**异步任务**，同步任务都在主线程（JS引擎线程）上，形成一个**执行栈**。

主线程之外，**事件触发线程**管理着**任务队列**，只要异步任务有了结果，就在**任务队列**之中放置该事件。

而任务队列分为**宏队列**（macrotasks）和**微队列**（microtasks），微任务优先级高于宏任务。

所以

首先执行栈中执行一个宏任务（如果没有就去宏任务队列（事件队列？）中获取）

执行过程中，遇到微任务就添加到微任务队列，遇到宏任务就添加到宏任务队列

执行栈中的任务执行完成后，立即开始执行微任务队列中所有的微任务（调入执行栈中执行）

执行完毕后，开始检查渲染，由GUI线程接管渲染

渲染完毕后，JS引擎线程接管，从宏任务队列中取出下一个宏任务，然后开始执行，没有就开始休眠

以上就是Event Loop事件循环机制

> 有哪些任务会放在microtasks，有哪些会放在macrotasks呢？
>
> - microtasks
>   - process.nextTick
>   - promise
>   - Object.observe (废弃)
>   - MutationObserver（用于监听DOM树结构变化的事件，与Mutation Events不一样）
> - macrotasks
>   - 主代码块
>   - setTimeout
>   - setImmediate
>   - setInterval
>   - I/O
>   - UI 渲染
>
> 上述的事件循环的核心是：JS引擎线程和事件触发线程
>
> 然而还会用到一个线程，定时器触发线程。
>
> 什么时候会用到定时器线程？当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。
>
> 注意，是当读到定时器代码后，定时器线程就开始计时推入，而不是说执行栈执行完了之后才开始计时。



### 防抖和节流

防抖和节流都有一个共同的概念：通过限制调用次数来进行**性能优化**

**防抖**

触发事件一定时间后才会执行，如果在这段时间内再一次触发了这个事件，则重新计时这段时间

```javascript
function debounce(fn,delay = 3000){
	let timer = null;
    return (...args) => {
		if(timer) clearTimeout(timer); 
        timer = setTimeout(() => {
            fn(...args);
        },delay);
    }
}
```

> 代码一步一步、一行一行的说，说的过程中可以提及一些已经改进的代码，比如timer私有变量写在内部，使用扩展运算符，箭头函数

**节流**

每隔一段时间内，事件只触发一次

节流会稀释事件执行频率

```javascript
function throttle(fn , delay = 3000){
	let timer = null;
    return (...args) => {
        if(timer) return;
        timer = setTimeout(() =>{
            fn(...args);
            timer = null;
        },delay);
    }
}
```

相同点：目的都是降低回调次数，节省资源；

不同点：防抖关注一定时间内连续执行的事件，只执行最后一次；节流侧重于一段时间内，只执行一次

**应用场景**：

防抖：手机号，邮箱号的输入；窗口大小的调整，防止重复渲染

节流：滚动加载；表单的多次提交



### 事件委托

事件委托，就是把一个元素的响应事件委托到另外一个元素

一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。

关键点，使用e.target

e.target属性返回事件对象的目标结点（也就是触发该事件的节点）

```javascript
var ul = document.querySelector('ul');
ul.addEventListener('click',function(e){
    Array.from(ul.children).forEach(element => {
        element.className = '';
    });
    e.target.className = 'bk';
})
```

当需要精准匹配的时候，使用Element.matches

Element.matches(selectorString)   selectorString 既是 CSS 那样的选择器规则，比如本例中可以使用 target.matches('li.class-1')，他会返回一个布尔值，如果 target 元素是标签 li 并且它的类是 class-1 ，那么就会返回 true，否则返回 false。

```javascript
var ul = document.querySelector('ul');
ul.addEventListener('click',function(e){
    if(e.target.matches('li.c1'))
        e.target.className += ' bk';
})
```

这种方法存在兼容性问题，需要IE9及以上的现代化浏览器版本

可以使用**Polyfill**来解决兼容性上的问题

**好处**：

1. 减少内存消耗，不用一个函数一个元素的绑定，对列表每一个元素都绑定，对于内存消耗较大
2. 因为访问的DOM减少了，设置事件处理程序所需时间更少, 加快了整个页面的交互就绪时间
3. 动态绑定事件，减少重复的工作

**局限性**：

1. 事件委托基于冒泡，不冒泡的事件不支持事件委托，如focus、blur之类的事件本身并没有冒泡机制，无法委托
2. 层级过多的情况下，冒泡过程可能被中间层阻止
3. 当事件委托过多时，可能会出现事件误判，即不该触发该事件的元素被绑定了



### 闭包

闭包就是指**有权调用另一个函数作用域中变量的函数**（外面的这个函数，不是返回的函数）

**闭包的主要作用是**

- 延伸了变量的**作用范围**
- 隐藏变量，避免了**全局污染**

**闭包的危害**

- 不恰当的使用闭包可能会造成内存泄露的问题

为什么会发生内存泄露？

JS规定在一个函数作用域中，程序执行完后变量就会被销毁，这样可以节省内存（JS的垃圾回收机制）。而使用闭包时，由于作用域链的特点，变量一直不会被销毁，因为会被函数一直调用，从而造成了内存泄露

> 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。



### JS的垃圾回收机制（GC）

JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理

一般来说，垃圾回收器有自己的回收策略

譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）

JS常用的两种垃圾回收规则是：

- 标记清除
- 引用计数

JS引擎基础GC方案是**mark and sweep**（标记清除）,简单的解释如下：

1. 遍历所有可访问的对象
2. 回收已不可访问的对象

> 当变量进入环境时，例如声明一个变量，就将这个变量标记为“进入环境”
>
> 从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们
>
> 而当变量离开环境时，则将其标记为“离开环境”
>
> GC会在运行的时候会给存储在内存中的所有变量加上标记
>
> 然后它会去掉环境中的变量和被环境中变量引用的变量（相关应用变量）的标记（比如闭包）
>
> 在此之后被加上标记的变量就会视为准备被删除的变量，原因是环境中的变量已经无法访问到这些变量了
>
> 最后垃圾回收期完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间
>
> （和可达性分析算法类似）



关于**引用计数**

跟踪记录每个值被引用的次数，当一个值被引用时，次数`+1`，减持时`-1`，下次垃圾回收器会回收次数为`0`的值的内存（当然了，容易出循环引用的内存泄露）

> 什么是循环引用？
>
> 当对象 1 中的某个属性指向对象 2，对象 2 中的某个属性指向对象 1 就会出现循环引用，（当然不止这一种情况，不过原理是一样的）
>
> 如果出现上述情况，代码执行完后，会将变量赋值为null，引用完后变量计数都为1，并不为0，并不会进行垃圾回收，就会造成内存泄露



**GC的缺陷**

和其他语言一样，JS的GC策略避免一个问题：**GC时，停止响应其他操作**

这是为了安全考虑。

而JS的GC在**100ms甚至以上**

对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。

这就是引擎需要优化的点： **避免GC造成的长时间停止响应。**

> 只要采用标记清除方法，就会产生内存碎片，需要对内存碎片进行处理（内存调整，或者说是用空链表记录）这里我还不知道JS怎么处理这个内存碎片。



**GC优化策略**

这里要用到：**分带回收**

目的是通过区分“临时”与“持久”对象：

- 多回收“临时对象”区
- 少回收“持久对象”区
- 减少每次需要遍历的对象，从而减少每次GC的耗时



### JS内存泄露的四种方式及如何解决？

内存泄露是很多问题的根源：反应迟钝，崩溃，高延迟以及其他应用问题

**常见的JS内存泄露**

- 意外的全局变量，如在函数里不用var 就声明变量，或者直接用this.param声明变量

> 在 JavaScript 文件头部加上 `'use strict'`，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。
>
> 尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于 临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，**确保用完以后把它设置为 null 或者重新定义**。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。

- 被遗忘的计时器或回调函数（不懂）
- 脱离DOM的引用（不懂）
- 闭包

**解决方法**

- 优化代码逻辑，避免出现上述的JS泄露情况，及时将不需要的变量赋为null或者重新引用
- Chrome内存剖析工具概览Timeline和Profiles
- 使用ES6推出的新的数据结构：WeakSet和WeakMap。它们对值的引用是弱引用，不计入垃圾回收机制（这里针对引用计数机制）



### 简述一些操作数组的函数

简单的、常见的有

- concat 连接两或者更多的数组
- push 数组末尾添加元素
- pop 删除数组最后一个元素
- shift 删除数组第一个元素
- unshift 数组开头添加元素
- sort 排序
- toString 转换成字符串
- for...of   for...in（一般不用）  forEach() item index arr

等等一堆函数

ES6新增的有

- from 把类数组转换成真正的数组
- find 用于找出第一个符和条件的成员，里面是个回调函数 item index  arr
- findIndex 在find的基础上变成了找位置
- includes 是否包含给定的值

**for...of 和for...in有什么区别**

for in是遍历对象的属性名（键名），所以用for in遍历数组时，拿到的是每个元素的索引。一般不用在数组里，用于对象的遍历。

for of是遍历对象的属性的值（键值），只能用于可迭代的数据（涉及迭代器知识），包括数组，set，map，字符串，不包括对象。



### Node.js 和 JS的区别

> Node.js是基于V8引擎的运行环境，是一个能让JS**运行在服务器端的平台**，让JS成为PHP、Python等服务端语言平起平坐的脚本语言
>
> Node.js就是把浏览器的解释器封装起来作为服务器运行平台，用类似JavaScript的结构语法进行编程，在Node.js上运行

1. Node.js是平台，JS是编译语言

2. JavaScript组成：ECMAScript, DOM, BOM

   Node.js组成：ECMAScript, OS, file, net, database

3. 顶层对象不同，JS的顶层对象是window，node的顶层对象是global



### 数组与字符串的一些常用方法

都有的方法有：

param.concat 给param连接一个或多个，不改变param，返回新的字符串（字符串可以使用 + ，更方便，但大量的+拼接字符串比较耗时）









### 设计模式

**工厂模式**

不暴露创建对象的具体逻辑，而是将逻辑装在一个函数中，这个函数被视为一个工厂

分类：简单工厂模式，工厂方法模式，抽象工厂模式

**简单工厂模式**可以解决多个相似的问题，一个工厂对象来创建某一类产品的实例

**工厂方法模式**是创建多类产品的实例，写在原型对象上

**抽象工厂方法**是对类的工厂的抽象，用于创建工厂和工厂中的类

应用：AJAX的封装

**单例模式**

保证一个类仅有一个实例，并且提供一个可以访问它的访问点

只能被实例化(构造函数给实例添加属性与方法)一次

用一个变量（锁）来实现

应用：模态框，弹窗

**安全沙箱模式**

将一个函数放在立即执行函数里，用变量接收闭包暴露的接口。这样才能调用里面的值

沙箱里面不会受到外界影响，全局污染，相对来说算是安全的

应用：只受函数调用的计数器

**观察者模式（发布者订阅模式）**

当一个对象的状态发生改变时，所有依赖它的对象都会得到通知

定义一个发布者，为发布者添加一个列表，里面存放要通知的对象的回调函数，当发布者变动时，遍历这个列表，触发里面的函数

记得修改this指向

应用：JS很多的事件如onclick，vue（一般不要回答）

**构造函数模式**

就是最常使用的构造函数

应用：很多，ES6之前的继承就可以通过构造函数和原型对象来实现

**代理模式**

为一个对象提供一个代用品或占位符，以便控制对它的访问

某一个开销很大的操作，可以通过虚拟代理的方式延迟到**需要它的时候才创建**

应用：图片懒加载



### 原型链和原型链继承	

首先，JS规定每个一个构造函数都有一个prototype属性，指向一个对象，这个对象被称为原型对象，该对象上的方法和属性，都会被其构造函数所拥有，每一个构造函数都有一个原型对象。

每一个构造函数所创建的实例对象，都有一个__proto属性指向构造函数的原型对象，这样每个对象也可以访问prototype上的方法和属性。三者的关系就如同一个三角形一般。

而原型链，简单的说就是用原型组成的链。

因为构造函数的prototype里也有一个__proto属性，它指向的是创建prototype这个对象的构造函数的原型对象，一般来说也就是Object构造函数的原型对象。

Object，Object的原型对象，某个对象的原型对象，这三者的关系与前面提到的关系是一样的。

Object的原型对象的__proto则指向null。而这一系列属性的指向，如同链一样把原型给链接起来了，这就形成了一个原型链。

**原型链继承**

在ES6之前，没有class和extends，只能用构造函数和原型对象**模拟实现继承**，也叫组合继承

首先要用到call或者apply函数，这两个函数可以修改执行某个函数的this指向

在构建子类的构造函数时，用call或者apply调用父类构造函数，再通过修改子类构造函数的原型对象，将其构造成父类的原型方法（new Father()  改constructor），这样就获得了父类的属性方法，而自己的属性方法照常实现，这样就模拟了继承

从**本质上**来看ES5的继承实质就是在创建子类实例对象后，再把父类的方法属性添加到新建的这个this上

> ES6的继承机制完全不同，**实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this**。要用到super方法
>
> static不能被子类的实例继承，也不能被自身实例继承，但可以直接通过构造函数（子类父类但可以）来调用
>
> 如何像JAVA一样通过设置私有方法让子类不能继承到父类的某些方法呢？



### 简述一下浏览器获得URL，到页面加载的过程

1.首先

输入URL后，会对URL进行解析。浏览器解析出的协议，开辟一个**网络请求线程**去请求资源

2.然后

如果输入的是域名，需要用DNS去查询IP

- 如果浏览器有缓存，直接使用浏览器缓存，否则使用本地缓存
- 如果本地没有，就向DNS域名服务器查询，（中间可能经过路由，也有缓存），查询到对应的IP

> **浏览器缓存（chrome://net-internals/#dns查看） -> 系统缓存（一般存放在C盘里hosts.sam文件里面） -> 路由器缓存 -> ISP（互联网服务提供商） DNS缓存 -> 递归搜索**

3.查询到对应的IP后

拿最常见的http协议举例，通过80端口，在传输层与服务器端建立三次握手，建立成功后才开始正式传输数据。经过网络层**IP封装**，数据链路层**封装成帧**，物理层**物理传输**

4.服务器接收到请求后，内部进行处理，返回一个http响应包，这个包也是经过多层封装发送到客户端

> 前后端交互时，http报文作为信息的载体，http十分重要，这里不详细讲

5.浏览器获取到html文件，然后开始

- 解析HTML，生成DOM树
- 解析CSS，生成CSS规则树
- 合并DOM树和CSS规则，生成render树
- 布局render树，绘制页面像素信息
- 浏览器会将各层的信息发送给GPU，GPU会将各层合成，显示在屏幕上

> 在解析HTML中，会遇到一些需要请求的外链资源，会单独开启一个下载线程去下载资源
>
> 如CSS样式资源，JS脚本资源，img图片类资源，各有特点，此处不详细讲

6.开始JS引擎解析过程

7.执行完后页面渲染结束，在浏览器中显示给用户



### DNS为什么即使用TCP又使用UDP？

首先UDP报文最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节后，协议的TC标志出现删除标志，这时则使用TCP发送。

我了解的，DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议

域名解析时使用UDP协议：

客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器**负载更低，响应更快**。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，**很多DNS服务器进行配置的时候，仅支持UDP查询包**。

> 区域传输：DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中**主DNS服务器从自己本机的数据文件**中读取该区的DNS数据信息，而辅助DNS服务器则**从区的主DNS服务器中**读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就交区域传输



### HTTP报文格式

**HTTP请求报文**

- 请求行（request line）：请求方法  URL 协议版本
- 请求头部（header）：许多key-value的值，如Accept-Encoding，User-Agent
- 空行(CR+LF) ：请求报文中空行表示header和请求数据的分割
- 请求数据（request data） ： GET方法不会携带数据，POST方法会携带一个body

**HTTP响应报文**

- 状态行：HTTP版本号 状态码 状态值组成
- 响应头类似请求头，是一系列的key-value值
- 空行：同上，响应报文也用空白行来分隔header和数据
- 响应体：响应的data



### HTTP常见字段有哪些？

**Host字段：**客户端发送请求时，用来指定服务器的域名

> Host：www.A.com

**Content-Length字段：**服务器在返回数据时，会有Content-Length字段，表明本次回应的数据长度

> Content-Length:1000

**Connection字段：**最常用于客户端要求服务器使用TCP持久连接，以便其他请求复用，HTTP/1.1默认连接都是持久连接，但为了兼容老版本，需要制定Connection字段值为Keep-Alive

> Connection:Keep-Alive

这不是一个标准的字段

**Content-Type字段：**用于服务器回应时，告诉**客户端本次数据是什么格式**

> Content-Type:text/html;charset = utf-8
>
> 发送的是网页，编码是utf-8

客户端请求的时候，可以用**Accept**字段声明自己可以接受哪些数据格式

> Accept:*/*
>
> 客户端声明自己可以接受任何格式的数据

**Content-Encoding：**说明**数据的压缩方法**。表示服务器返回的数据使用了什么压缩格式

> Content-Encoding:gzip
>
> 表示服务器返回的数据采用了gzip方式压缩，告诉服务端需要采用此方式解压

客户端在请求时，可以用Accept-Encoding字段说明自己可以接受哪些压缩方法

> Accept-Encoding：gzip,deflate

**User-Agent ：**用户代理，一个特殊字符串头，是一种**向访问网站提供**你所使用的浏览器类型及版本、操作系统及版本、浏览器内核等信息的标识。

> 但是我们可以人为的修改或者添加一些信息在这里面。标记当前所在的环境，比如在哪一个客户端环境下，是在QQ里，还是微信，还是钉钉下。一般用于镶嵌在客户端或者小程序里的h5页面里



### Content-Type具体有什么格式类型

常见的媒体类型格式：

1. text/html HTML格式
2. text/plain 纯文本格式
3. text/xml XML格式
4. image/gif gif图片格式
5. image/jpeg jpeg图片格式
6. image/png png图片格式

以application开头的媒体格式类型：

1. application/json JSON数据格式
2. application/x-www-form-urlencoded 最常见的 POST 提交数据的方式了，浏览器的原生 form 表单，提交的数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码
3. application/pdf pdf格式
4. application/msword word文档格式
5. application/xml XML数据格式
6. application/octet-stream 二进制流数据（如常见的文件下载）

另一种常见的媒体格式是上传文件的时用到的

multipart/form-data 需要在表单中进行文件上传，就需要使用该格式

> charset = utf-8 后面还可以跟个charset，表示编码是什么，比如这里就表示编码是utf-8



### HTTP特点

HTTP最凸出的优点是：简单，灵活和易于扩展、应用广泛和跨平台

1. HT3TP基本报文就是header+body，头部信息也是key-value简单文本格式，易于理解，**简单**易懂
2. HTTP协议里各类请求方法，状态码，头文字等每个组成都没有被固定死，**允许开发人员自定义和扩充**
3. HTTP的应用范围非常广泛，天然具有跨平台的优越性
4. 支持B/S及C/S模式？

缺点：

1. HTTP是无状态的协议
2. HTTP信息是明文传递，虽然在调试时提供了极大的便利性，但存在安全问题



### HTTP和HTTPS的区别

1. HTTP是超文本传输协议，信息是明文传输，存在信息安全风险问题。HTTPS解决了HTTP不安全的缺陷，在TCP和HTTP之间加入了SSL/TLS安全协议，使得报文能够加密传输
2. HTTP连接建立相对简单，TCP三次握手后便可以进行HTTP的报文传输。而HTTPS在TCP三次握手后，还要进行SSL/TLS的握手过程，才能进行加密的报文传输
3. HTTP的端口号是80，HTTPS的端口号是443
4. HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的



### HTTPS是如何解决HTTP的安全问题的？

HTTP存在的安全问题：**窃听风险，篡改风险，冒充风险**

HTTPS很好的解决了上述风险：**信息加密，校验机制，身份证书**

1.**混合加密的方式实现信息的机密性，解决了窃听的风险**

HTTPS采用的是**对称加密**和**非对称加密**结合的混合加密方式：

- 在通信建立前采用非对称加密的方式交换会话秘钥，后续就不再使用非对称加密。
- 在通信过程中全部使用对称加密的会话秘钥的方式加密明文数据

采用混合加密的方式原因：

- 对称加密只使用一个密钥，虽然运算速度快，但密钥必须保密，无法做到安全的密钥交换
- 非对称加密使用公钥和私钥，公钥可以任意分发而私钥保密，虽然解决了密钥交换的安全问题，但运算速度慢

HTTPS就结合这个两种加密方式，先使用非对称加密保证密钥交换的安全，等生成了会话密钥后因无需进行密钥交换，这时候就使用对称加密

> 对称加密：就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。
>
> 如DES,AES,3DES等
>
> 非对称加密：加密和解密使用不同的秘钥，一把作为公开的秘钥（公钥），另一把叫做私钥。公钥加密的信息，只有私钥能解密；私钥加密的信息，只有公钥能解密。
>
> 如RSA,ECC等

2.**摘要算法的方式来实现完整性，它能够为数据生成独一无二的`指纹`，指纹用于校验数据的完整性，解决了篡改的风险**

客户端在发送明文前会通过摘要算法算出明文的指纹，然后把`指纹 + 明文`一同加密发送，服务器解密后，用相同的摘要算法算出发送过来的明文的指纹，通过比对指纹判断数据是否完整

3.**将服务器公钥放入数字证书中，解决了被冒充的风险**

客户端向服务器索要公钥，然后用公钥加密，服务器收到密文后，用自己的私钥解密。

为了保证客户端索要的公钥没有被篡改，需要借助第三方权威机构CA，服务器将自己的公钥放在数字证书里，只要证书可信（本地的CA公钥来判断），公钥就是可信的。



### SSL/TLS协议建立的详细流程

1. 首先客户端要向服务器发起加密请求（**ClientHello**），发送以下信息：

   - 客户端支持的SSL/TLS协议版本
   - 客户端生成的随机数A
   - 客户端支持的密码套件列表，如RSA加密算法

2. 服务器收到客户端请求后，向客户端发出响应（**SeverHello**），响应以下信息：

   - 确认SSL/TLS协议版本，如果浏览器不支持，则关闭加密通信
   - 服务器生成的随机数B
   - 确认密码套件列表
   - 服务器的数字证书

3. 客户端收到这些信息后，首先通过浏览器或者操作系统中**早已备好**的CA公钥，确定**数字证书的真实性**。如果证书没问题，客户端会从数字证书中取出公钥，**用这个公钥来加密报文**，向服务器发送这些信息：

   - 一个被服务器公钥加密随机数C
   - 加密通信算法改变的通知，表示之后的信息都会用会话密钥加密通信
   - 客户端握手结束的通知，同时把之前所有的内容数据发个摘要，用于服务端校验

   这样整个握手阶段就有三个随机数ABC了，接着就**用双方协商的加密算法，各自生成本次通信的会话密钥**

4. 服务器收到客户端的第三个随机数C后，通过加密算法，生成会话密钥。然后向客户端发送最后的信息：

   - 加密通信算法改变的通知，表示之后的信息都会用会话密钥加密通信
   - 服务器握手结束的通知，同时把之前所有的内容数据发个摘要，用于客户端校验

至此，整个SSL/TLS的握手阶段全部结束。接下来服务器和客户端进入加密通道，就是完全使用普通的HTTP，只不过用**会话密钥加密内容**



### HTTP缓存

缓存可以分为两种类型：**强缓存和协商缓存**

区别：

- 强缓存时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求  200 from cache
- 协商缓存，浏览器会向服务器发起http请求，然后服务器告诉浏览器文件未改变，让浏览器使用本地缓存 304

缓存头部简述：

属于**强缓存控制**的：

http1.0  Pragma/Expires

Pragma严格来说不是专门缓存控制头部，但它设置no-cache时可以让本地强缓存失效

Expires是服务器端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存。



http1.1 Cache-control/Max-Age

Cache-control,存控制头部，有no-cache、max-age等多种取值

Max-Age,服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部

属于**协商缓存控制**的：

http1.0 If-Modified-Since/Last-Modified

If-Modified-Since/Last-Modified成对出现，属于协商缓存的内容，在发起请求时，如果`If-Modified-Since(浏览器的头部)`和`Last-Modified(服务器的头部)`**匹配**，**那么代表服务器资源并未改变，因此服务端不会返回资源实体**，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified 顾名思义，指的是文件最后的修改时间



http1.1 If-None-Match/E-tag

If-None-Match/E-tag，这两个是成对出现的属于协商缓存的内容，其中浏览器的头部是`If-None-Match`，而服务端的是`E-tag`，同样，发出请求后，如果`If-None-Match`和`E-tag`匹配，则代表内容未变，通知浏览器使用本地缓存。

**区别**

- Max-Age相比Expires的话，Expires使用的是服务器端的时间，而Max-Age使用的是客户端时间。如果出现客户端和服务器时间不同步，使用Expires会造成浏览器本地缓存无效或一直无法过期
- E-tag和Last-Modified？
  - Last-Modified表示服务端文件最后何时改变，只能**精确到1s**，有的服务器的文件会周期改变，导致缓存失效
  - E-tag是一种指纹机制，代表文件的相关指纹，**没有时间限制**，只要文件一遍，E-tag立马改变



如何明确禁止缓存？Cache-Control: no-store,no-store, must-revalidate

> Cache-Control还有哪些参数？public表示一些中间代理,CDN等可以缓存，但max-age信息已经明确告知可以缓存了。
>
> private明确告知了资源只能单个用户可以缓存，其他中间代理不能缓存



### Vue2.x和Vue3的区别

1. **数据的双向绑定原理不同**

   2.x使用的是Object.defineproperty()进行数据劫持，结合发布订阅者模式实现的

   而3使用的是es6提供的proxy API进行数据代理

   > 使用proxy的好处：
   > Object.defineproperty()只能监听对象的某一个属性，不能全对象监听，需要使用遍历，递归的方式处理对象，而proxy可以直接绑定整个对象，且不用对数组进行特异性处理，proxy可以监听数组内部数据变化

2. **使用了懒观察模式**

   在2.x中不管数据有多大，都会在一开始为其创建观察者。当数据很大的时候，这可能会在页面载入时造成明显的性能压力。

   在3版本中，只会对用于页面初始加载的数据创建观察者，所以3版本的观察者更高效

3. 重写了**虚拟DOM的实现和Tree-Shaking**

4. **新增了一些特性**

   生命周期钩子函数出现了很大的不同，2.x中的beforeCreate和created都变成了setup，后续的生命周期钩子也发生了改变。

   新的Composition（组合）API，新的一些组件，比如文档碎片Fragment，还有语法上的更新等等



### Vue工作原理

比如 一个输入框 输入文本后 怎么更新数据呢



### Vue-router有哪些模式

vue-router有三种模式：

1. hash模式：后面hash值的变化，浏览器既不会向服务器发出请求，浏览器也不会刷新，每次hash的值的变化会触发hashchanged事件
2. history模式：利用了HTML5中新增的pushState和replaceState方法，这两方法应用于浏览器的历史记录栈，提供对历史记录修改的功能。只是当它们修改时，虽然改变了当前的URL，但浏览器不会立即向后端发送请求
3. abstract模式：适用于所有JavaScript环境，例如服务器端和Node.js. 如果没有浏览器API，路由器将自动强制进入此模式。



### 项目中的亮点

**大文件的断点续传**

首先利用**Spark-md5**插件获取每个文件唯一的hash表示码，把文件解析为**buffer**数据类型。

> 通过FileReader进行解析，用FileReader.readAsArrayBuffer把文件转换成buffer格式数据（这是异步的）
>
> 再返回FileReader.onload的事件对象的e.target.result，这就是我们要的文件buffer数据

然后使用Math.ceil函数对文件进行切片，创建一个切片列表，将所有切片push进去。

然后根据切片列表，创建一个请求列表，列表里面每一个函数都是发送一个切片的请求，每次请求都会带上每一片的序号（按需），和整个文件的hash标识

存在文件上传状态的变量，根据这个变量判断是否上传，这样能实现文件上传暂停功能

存在文件片上传片数的记录变量，只有切片请求列表每一次上传成功后，变量才会累加，防止文件切片丢失

在开始上传前会对这个文件（利用唯一hash表示码）在服务端的状态进行判断（发送请求），会返回这个文件是否存在，如果存在，则片数记录变量直接等于切片数，通知服务器合并文件，实现秒传效果；如果不存在或者只传了n片，则从0片或者从n+1片开始传，实现断点续传的效果

**RBAC权限管理**

RBAC是基于角色的权限控制，这个模式的核心在于用户和权限之间引入了角色的概念。用户和权限没有直接的关联，而是给用户赋角色，管理角色的权限来间接地给用户赋权限。

我的项目中是使用的是最基础的RBAC0的模式，用户和角色是**一对多**的方式，一个用户只能是一个角色，一个角色可以有多个用户。

具体的实现，首先我项目中有个后台系统，在这个页面系统中有个权限管理页面，里面有我的角色列表，固定的有老师、学生、管理员三种角色。

后台可以对角色进行增删改查，比如为角色添加新的用户，增添新的角色，删除存在的角色，移除角色中的某个用户的功能。

每一个角色有修改权限的按钮，点进去是一排一排分类的权限开关，可以修改开关来修改角色的权限。**比如~~~**

前端对于某些功能做了处理，有这个权限的才会渲染出这个功能相关的东西。

并且关于一些页面做了路由守卫，根据router.beforeEach的第一个参数to ，即将进入的路由对象的path属性来进行操作，通过next函数进行路由的调整，有这个权限才能访问这个页面。

这些是前端对于权限的控制，当然我们后端同学也会对请求进行权限管理，如果请求的用户没有这个权限就并不会处理并返回错误信息

> 对于权限的处理还有可以优化的地方



### 项目中下载文件是如何实现的

首先我采用Get请求，请求时修改了responseType的值为blob，也就是说我请求了一个类似文件的二进制数据对象。responseType设置的特定类型需要确保服务器所返回的类型和设置的返回值的类型是兼容的。

然后我新建了Blob对象，参数就是response.data。然后创建了新的a元素，调用window.URL.createObjectURL创建了下载链接，而参数就是新建的Blob对象。然后把创建的下载链接赋给了新的a元素的href，将新的a标签添加到页面文档中。

最后下载完成后移除元素，调用window.URL.revokeObjectURL释放掉刚刚创建的下载链接



Blob对象表示一个不可变，原始数据的类文件对象。

它的数据可以按文本或二进制的格式进行读取，也可以转换成 `ReadableStream`来用于数据二进制流操作。 

> 流操作API中，ReadalbeStream接口呈现了一个可读取的二进制流操作
>
> ReadableStream() 构造器创建并返回包含处理函数的**可读流**实例



URL.createObjectURL()静态方法会创建一个 DOMString，DOMString包含一个参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document绑定，但为了获得最佳性能和内存使用情况，还是及时使用URL.revokeObjectURL来释放



### 项目为什么要选择这些技术栈

为什么使用Vue？

首先当初是写项目是刚接触前端不久，学完基础后听学长同学介绍Vue**上手比较简单，对初学者比较友好**，刚好我们小组的前端人员也是初学者。

而且**Vue具有更好的性能**，学习生态较好，遇到问题的能很好的解决。

**老师的要求**也是要求我们使用Vue。



### Webpack

Webpack是一个前端资源加载/打包的工具。

它根据模块间的依赖关系进行静态分析，按照指定规则生成对应的静态资源。

简单多说，可以将多种静态资源JS,CSS,LESS转换成一个静态文件，减少了页面的请求



Webpack本身只能处理JS模块，要处理其他类型的模块，要使用loader进行转换

> 所以如果我们需要在应用中添加 css 文件，就需要使用到 css-loader 和 style-loader，他们做两件不同的事情，css-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们，style-loader 会把原来的 CSS 代码插入页面中的一个 style 标签中。



当然，我们可以将一下编译的配置放在配置文件webpack.config.js文件中

> 自己理解的 ，后续需要改动
>
> entry：要编译的
>
> output：打包出来的文件
>
> module：有哪些编译的模块
>
> plugins：配置插件信息的地方



### Vue中的key有什么作用

**key的作用主要是为了高效的更新虚拟DOM**，在diff算法中，key可以管理可复用的元素，减少不必要的元素的重新渲染，让有必要的元素重新渲染。有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误。

它也可以用于强制替换元素/组件而不是重复使用它。

另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们。



> vue应用 **in-place patch（就地复用）策略**。列表里的顺序发生改变的时候比如shuffle（列表打乱）的时候，vue为了提升性能，不会移动dom元素，只是更新相应元素的内容节点。



### 常见的HTTP状态码

- 1xx 是信息类状态码，表示收到了http请求，正在进行下一步处理
  - 100 客户端继续请求
  - 101 切换协议
- 2xx 是成功类状态码，表示用户被正确接收，处理
  - 200 请求成功
  - 201 成功请求并创建了新的资源
  - 202 已接收请求，但未处理完成
- 3xx 是重定向类状态码，表示没有请求成功，必须采取进一步的动作
  - 301 永久移动，请求的资源已被永久移动到新的URL，浏览器会自动定向到新的URL，今后请求也会用新的URL
  - 302 临时移动，与301类似
  - 304 所请求的资源未修改，不会返回任何的资源。客户端通常会去缓存访问过的资源
- 4xx 是客户端错误类状态码，表示客户端提交的请求包含错误或不能正确执行
  - 400 客户端请求语法错误
  - 401 要求认证用户身份
  - 403 服务器理解客户请求，但拒绝此请求
  - 404 服务器无法根据请求找到资源
  - 405 客户端请求的方法被这个资源禁止
- 5xx 是服务端错误类状态码 表示服务器不能正确执行一个正确的请求
  - 500 服务内部错误
  - 501 服务器不支持该请求的功能，无法完成请求
  - 503 服务器超载或者系统维护，暂时无法处理客户端请求

> 哪些情况需要用到301重定向？
>
> 1. 一个站点绑定了多个域名的时候
> 2. 同一个页面存在多个URL路径
> 3. 已有页面URL发生变化时，当一个页面被收录后，若是改变该页面的url路径，那么之前的路径就会成为网站死链，这个页面上的关键词排名与收录将会消失。那么就需要做301定向，将老链接跳转到新链接
> 4. 域名改版  当我们想换个域名的时候，除了域名以外，其余内容完全一样的情况下，想把老域名的收录于排名全部过渡到新域名上，这就需要做301定向。每个页面的链接需要一一对应。





### instanceof，typeof和Object.prototype.toString的用法和区别

**instanceof**

定义： instanceof运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上

语法：

```javascript
object instanceof constructor

object：某个实例对象     constructor：某个构造函数

用来检测  constructor.prototype 是否存在于参数  object 的原型链上。
返回结果是布尔值
```

能判断基本数据类型，数组，函数，判断对象的话需要结合起来判断（用多个）

**typeof**

定义：typeof用来判断数据类型，但只能判断出五种：number，string，undefined，boolean，object

对于对象，数组来说，统一返回'obejct'；

语法：

```javascript
typeof param
typeof(param)

返回的结果是字符串，上面五种类型的小写
```

**toString**

定义：默认情况下，`toString()` 方法被每个 `Object` 对象继承，但是不同的数据类型会覆盖默认的方法，如果未覆盖，toString()方法返回[object type]字符串，type是对象的类型。

可以利用call,apply来判断变量的类型

语法：

```javascript
Object.prototype.toString.call(param)
```



### 浅拷贝和深拷贝

浅拷贝和深拷贝是针对复杂数据类型来说的。

浅拷贝只拷贝一层，只会把栈里面变量的引用地址拷贝过来，而非堆里的值，对象的变化相互影响。

深拷贝会每一层都拷贝，每一级别的数据都会拷贝，通常使用递归来实现，两个对象的改变不会相互影响。

```JavaScript
function deepCopy(newObj,oldObj){
  for(let k in oldObj){
    var tmp = oldObj[k];
    if(tmp instanceof Array){
      newObj[k] = [];
      deepCopy(newObj[k],tmp); 
    }else if(tmp instanceof Function){
      newObj[k] = tmp;
    }else if(tmp instanceof Object){
      newObj[k] = {};
      deepCopy(newObj[k],tmp);
    }else{
      newObj[k] = tmp;
    }
  }
}
```

Object.assign(target,sources) es6新增方法可以实现拷贝，target拷贝给谁，sources拷贝来源。

Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

因为Object.assign()拷贝的是属性值。

假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。

也就是说，如果对象的属性值为简单类型（如string， number），通过Object.assign({},srcObj)，得到的新对象为深拷贝；**如果属性值为对象或其它引用类型**，那对于这个对象而言其实是**浅拷贝**的。

数组方法concat和slice与这个原理一样

```javascript
进阶版：考虑了其他类型和循环引用
let obj = {
    test_obj:'obj'
}
let set = new Set([11,12,obj]);
let map = new Map([[12,13],[14,obj]])
let a = [1,2,3,[4,5,6,[7,8]],{'9':9,'10':10,'15':set},set,map]
let reg = /\w/;
let oldObj = {
    oldObj:a,
    b:1,
    reg_test:reg
}

function deepClone(target,hash = new WeakMap()){
    let result;
    if(typeof target === 'object'){
      if(hash.has(target))  return hash.get(target);
      if(target instanceof RegExp || target === null || target instanceof Function){
        result = target;
        hash.set(target, result);
    }else if(target instanceof Set){
        result = new Set();
        hash.set(target, result);
        for(let item of target){
            result.add(deepClone(item,hash));
        }
      }else if(target instanceof Map){
        result = new Map();
        hash.set(target, result);
        hash.set(target, result);
        for(let item of target){
            result.set(deepClone(item[0],hash),deepClone(item[1],hash));
        }
      }else if(target instanceof Array){
        result = [];
        hash.set(target, result);
        for(let item of target){
          result.push(deepClone(item,hash));
        }
      }else{
        result = {};
        hash.set(target, result);
        for(let item in target){
          result[item] = deepClone(target[item],hash);
        }
      }
    }else{
      result = target;
    }
    return result;
}

let newObj = deepClone(oldObj);
console.log(newObj);
obj.test_obj = "??????";
console.log(oldObj);
console.log(newObj);    
```



### 子网掩码

子网掩码是另外一种划分网络号与主机号的形式。（子网掩码为1的位数就是网络号的位数）

将子网掩码和IP地址按位计算AND，就可以得到网络号

更重要的我们要通过子网掩码进行**划分子网**

子网划分实际上是将**主机地址分成了两个部分：子网网络地址和子网主机地址**

**子网划分的优点**

1. 有效利用IP地址，不浪费IP地址
2. 限定了广播的传播，通过子网隔离用户，保证了网络的安全



### TCP与UDP的区别

**TCP与UDP都位于网络模型中的传输层，负责传输应用层产生的数据**

1. 最基础的，TCP是**面向连接的**、**可靠的**、**有状态**的传输协议，而UDP是**无连接的，不可靠、无状态**的传输协议。TCP提供可靠的服务，先建立三次握手连接，支持差错检验，拥塞控制等实现不丢失、不重复、不失序的数据传输；UDP没有三次握手的连接建立，尽最大努力可靠交付交付
2. TCP是点对点的传输；UDP可以一对多，多对多的传输
3. TCP对系统资源要求较多，UDP对系统资源要求较少
4. TCP允许的报文长度超过512字节，UDP报文的最大长度为512字节
5. TCP提供可靠的服务，应用在一些对安全性、数据传输量大的场景，如HTTP，FTP文件传输；而UDP工作效率高，应用在实时性要求高的场景，如视频，音频等多媒体

> 无状态的含义：指协议对于事务处理没有记忆能力，服务器不知道客户端的状态。



### TCP三次握手的过程

1. 首先，一开始客户端和服务器都是处于**CLOSED状态**。服务端主动监听某个端口，服务器处于LISTEN状态
2. 客户端会随机初始化序列号（client_isn），将这个序号置于TCP首部的序号字段中，同时把SYN标识位设为1，发送这个**SYN**报文给服务端，表示向服务器**发起连接**，该报文不包含应用层数据，之后客户端处于**SYN-SENT状态**
3. 服务器收到客户端的SYN报文后，服务端也随机初始化自己的序号（server_isn），将此序号填入TCP报文中序号字段中，其次在TCP首部的**确认应答号**字段中填入之前收到的SYN报文中的序列号**（client_isn）+ 1**，并且把**SYN和ACK标志位设为1**。最后把该报文发送给客户端，该报文也不含应用层数据，之后服务端处于**SYN-RCVD(同步收到 SYN-RECEIVED)状态**
4. 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，**ACK标识为1**，**确认应答号是client_isn + 1**，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，然后**客户端处于ESTABLISHED（建立）状态**
5. 服务器收到客户端的应答报文后，也**进入ESTABLISHED状态**。此时已完成建立，客户端和服务端就可以相互发送数据了。

> 第三次握手是可以携带数据的，前两次握手是不可以携带数据的



### 为什么TCP要三次握手，不是两次握手？不是四次握手？

首要原因是TCP为了**防止已经失效的连接报文突然又传到了服务端**，因而产生了错误。

client发送的第一个连接请求因为网络问题延时了，成为了一个已失效的报文段，但是server后续收到了这个已失效的，误认为client要建立新的连接，于是向client发送确认报文段，同意建立连接。如果不采用三次握手，那么只要server发出确认请求了，连接就建立了，而client不会理会server端，这样server端的**资源就白白浪费了**，而采用三次握手就能防止上述现象出现。

还有个原因是**TCP需要seq序列号来做可靠传输，需要双方同步ISN（初始seq序列号）**。当client发送携带初始序列号的SYN报文时，需要server回一个ACK应答报文，同理，server发送携带初始序号的SYN报文时，需要client的应答报文。这样一来一回，**两次往返，才能确保双方的初始序列号同步，确保了双方都有发送和确定的过程**。这样看来四次握手也可以实现，但由于server的应答报文和SYN报文**可以优化成一步**，这样节约资源，所以就成了三次握手

> 顺带一提的是：
>
> 两次握手更容易受到SYN Flood洪水攻击。
>
> 
>
> 三次握手的原则设计是防止旧复用链接的初始化导致问题，为了解决此问题，我们设计了`reset`这个特别的控制信号来处理。
>
> 如果接收中的 TCP 在一个未同步状态如 `SYN-SENT, SYN-RECEIVED`，它会返回 `reset` 给对方，对方又变成listen状态。



### TCP头部报文格式

**序列号**：在建立连接时生成一个**随机数作为其初始值**，通过SYN包传给接收端，每发一次数据，就累加一次该数据字节大小，用来**解决网络包乱序问题**

**确认应答号**：指下一次**期望**收到的数据的序列号，发送端收到这个确认应答号后可以认为在这个号之前的数据都被正常接收（累积回应）。用来**解决不丢包的问题**

**控制号**：

- ACK: 该位为1时，**确认应答号**有效，TCP规定除了最初建立连接时的SYN包之外该位必须设置为1
- RST: 该位为1时，表示TCP连接出现异常必须**强制断开连接**
- SYN: 该位为1时，表示希望建立连接，并在其**序列号**的字段进行序列号初始值的设定（建立连接的前两次握手）
- FIN:  该位为1时，表示今后不会再有数据发送，希望断开连接。当通信双方希望断开连接时，通信双方的主机之间就可以**相互交换FIN位为1的TCP报文**



### 详解一下四次挥手过程

1. 客服端打算关闭连接，此时会发送一个TCP首部FIN为1的报文，即**FIN报文**，此时客户端**进入FIN_WAIT_1状态**
2. 服务端收到该报文后，就向客户端发送**ACK应答报文**，接着服务端**进入CLOSED_WAIT状态**
3. 客户端收到ACK应答报文后，之后**进入FIN_WAIT_2状态**
4. 此时只是客户端向服务端断开了连接，但服务端还可以向客户端发送数据
5. 等待服务器处理完数据后，也向客户端发送**FIN报文**，之后服务端进入**LAST_ACK状态**
6. 客户端收到FIN报文后，**回应ACK应答报文**，**之后进入TIME_WAIT状态**
7. 服务器收到了ACK应答报文后，就进入了**CLOSED状态**，**至此服务端已经完成了连接的关闭**
8. 客户端在经过了2MSL一段时间后，就自动进入CLOSED状态，**至此客户端已经完成了连接的关闭**

> 挥手的过程中每个方向都需要一个FIN和一个ACK
>
> 只有主动关闭连接的一方，才有TIME_WAIT状态
>
> 为什么会有TIME_WAIT状态（和下面的等待2msl原因一样）？
>
> 1. 防止旧连接的数据包被使用相同端口的新连接正常接收，造成数据错乱
> 2. 保证连接的正确关闭



### 为什么挥手需要四次？

- 关闭连接时，客户端向服务端发送FIN报文，**仅仅代表客户端不再发送数据，但是还能接收数据**
- 服务器收到FIN报文后，先回一个ACK报文，**但服务端可能还有数据需要处理和发送**，等服务端不再发送数据时，才发送FIN报文

综上，服务端通常还需等待完数据的处理和发送，所以ACK报文和FIN报文会分开发，**从而比三次握手多了一次**



### 四次挥手会等待2msl，为什么？

首先理解到什么是MSL，MSL是**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

2msl的时间是从客户端**接收到FIN后发送ACK开始计时的**,如果最后的ACK应答报文丢失了，被动关闭方（服务器端）会**触发超时重发FIN报文**，另一方接收到这个超时重发的FIN后，就会重发ACK给被动关闭方，并重新计时，这段时间正好是2msl

这样就**确保了连接的关闭**

还有个原因，经过2msl时间，**足以让两方向上的数据包都被丢弃，使得原来连接的数据包在网络中自然消失，防止客户端正常接收过期的报文，产生数据错乱等严重的问题**







### Web安全之四大常见攻击

见已经整理了的MarkDown



### 应用层其他协议

**文件传送协议FTP**，是基于TCP的互联网上使用得最广泛的文件传送协议，使用的是客户服务器模式。

**简单文件传送协议TFTP**，是基于UDP（需要有自己的差错改正措施）的很小且容易实现的文件传送协议，使用的是客户服务器模式。

**远程终端协议TELNET**是简单的远程终端协议，也是互联网的正式标准，也是使用的是客户服务器模式。

**电子邮件的一些标准：**

- 发送邮件的协议：SMTP
- 读取邮件的协议：POP3和IMAP



### 让一个div盒子水平垂直居中的方法

1.grid方法

> Grid布局（网格布局）
>
> grid布局与flex布局有一定的相似性，都可以指定内部多个项目位置。Flex布局是轴线布局，只能指定“项目”针对轴线的位置，是一维布局。Grid布局则是将容器划分成“行”和“列”，产生单元格，然后指定“项目”所在的单元格，可以看做是二维布局

```css
.father{
    display:grid;
}

.son{
    justify-self:center;
    align-self:center;
}


也可以这么写
        body{
            background-color: turquoise;
            height: 600px;
            display: grid;
            justify-items: center;
            align-items: center;
            grid-template-columns: repeat(3,33.3%);
            grid-template-rows: repeat(3,200px);
        }

        .box{
            width: 200px;
            height: 200px;
            background-color: tomato;
            grid-row: 2/3;
            grid-column: 2/3;
        }
```

2.absolute + 负margin

```css
.father{
	position:relavtive;
}

.son{
	position:absolute;
	left:50%;
	top:50%;
	margin-left:-50px;
	margin-right:-50px;
}
```

3.absolute + transform

对第二种方法的改良

```css
.father{
	position:relative;
}
.son{
	postioin:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
}
```

4.absolute + margin

这类方法的另一种变形

```css
.father{
	position:relative;
}

.son{
    position:absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin:auto;
}
```

5.flex布局

```css
.father{
    display:flex;
	justify-content:center;
    align-items:center;
}
```

6.margin + transform

```css
.father{
	overflow:hidden;
    //也可以使用padding:1px; box-sizing:content-box;
}
.son{
	margin: 50% auto;
    transform:translateY(-50%);
}
```

7.table-cell

```css
.father{
	display:table-cell;
    text-align:center;
    vertical-align:middle;
}
.son{
    display:inline-block;
}
```

8.inline-block + vertical-align

```css
.father{
    text-align:center;
    line-height:300px;
}
.son{
    display:inline-block;
    vertical-align:middle;
}
```



### 为什么要清除浮动？

由于父盒子很多情况下不方便赋值高度，但子盒子浮动又不占有位置，最后父盒子高度就为0，就会影响下面的标准流盒子，影响整个页面布局

清除浮动本质？**本质是清除浮动元素脱离标准流造成的影响**

清除浮动的策略是？闭合浮动，只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子

**有哪些方法？**

1. **额外标签法**。末尾的新标签添加clear:both，且必须是块级元素。缺点：添加许多无意义的标签，结构化比较差。不常用
2. 给父元素**添加overflow**。缺点：无法显示溢出的部分
3. :after伪元素法。在after里添加clear:both，缺点：需要照顾低版本浏览器
4. 双伪元素清楚浮动。代码更简洁，但也需要照顾低版本浏览器

（3、4也被称为.clearfix方法，相对前两个是比较好的方法）



### CSS属性书写顺序

建议遵循以下顺序：

1. 布局定位属性
2. 自身属性
3. 文本属性
4. 其他属性



### 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景

从结构上来讲：

- display:none **会**让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击
- visibility:hidden**不会**让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击
- opacity:0 **不会**让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击(透明度)

从继承上来讲：

- display:none是**非继承属性**，子孙结点的消失是由于该元素从渲染数消失造成的，通过修改子孙结点属性仍无法显示
- visibility:hidden是**继承属性**，子孙节点消失由于继承了hidden，通过设置visibility: visible可以让子孙节点显式。
- opacity:0是**继承属性**，且子孙结点无法通过修改opacity来改变这个继承属性。父节点可以通过rgba间接设定opacity的值，这个不会向下继承；或者把opacity属性放到同级元素实现透明

从性能方面来讲：

- display:none修改元素会造成文档**回流**，性能消耗较大，读屏器不会读取display:none元素内容
- visibility:hidden修改元素只会造成元素本身**重绘**，性能消耗较少，读屏器会读取visibility:hidden元素内容
- opacity:0修改元素造成**重绘**，性能消耗较少，读屏器会读取opacity:0元素内容

共同特点：它们都能让元素不可见



### CSS：画一个三角形

等腰直角：宽高设置为0，只设置border宽度，且颜色设置为透明色，需要哪个朝向的三角形，就设置哪个朝向的颜色为需求颜色

中心交汇点到每一个边的距离就是每一个方向上border的宽度

需要其他类型的三角形，可以自定义修改border

```css
边长为3 4 5的三角形
.triangle{
            height: 0;
            width: 0;
            border-top:20px solid transparent;
            border-bottom:30px solid yellow;
            border-left:40px solid transparent;
            /* border-right:20px solid red; */
}
```



### CSS：画一个0.5px边框

详见0.5px边框.md



### CSS如何解决图片底部默认空白间隙

为什么会有空白间隙？因为行内块元素要和文字的基线对齐，文字会多出部分内容，哪怕没有文字，也会多出这点空隙

解决方法：

1. 给图片添加vertical-align，改变它与文字垂直对齐的方式，不让它与文字的基线对齐。
2. 把图片转换为块级元素，display:block;

提倡使用第一种，第二种可能会影响布局

> vertical-align只针对行内块和行内元素



### 溢出文本省略号显示

单行文本溢出显示省略号

```css
{
    /*先强制一行内显示文本 ,默认是normal自动换行*/
    white-space:nowrap;
    /*超出的部分隐藏*/
    overflow:hidden;
    /*文字用省略号代替超出的部分*/
    text-overflow:ellipsis;
}
```

多行文本溢出显示省略号（有较大的兼容性问题，适用于webKit浏览器）

```css
{
    overflow:hidden;
    text-overflow:ellipsis;
    /*弹性伸缩盒子模型显示*/
    display:-webkit-box;
    /*限制在一个块元素显示的文本的行数*/
    -webkit-line-clamp:2;
    /*设置或检索伸缩盒对象的子元素的排列方式*/
    -webkit-box-orient:vertical;
}
```

更推荐让后台人员写这个效果,	后台人员显示多少字，操作更简单。（感觉不是这样的）



### HTML5新特性

1.新增的带有语义化的标签：

1. header 头部
2. nav 导航
3. article 内容
4. section 定义文档某个取余（大号div标签）
5. aside 侧边栏
6. footer 尾部

2.新增的多媒体标签：

1. audio 音频 支持MP3 Wav Ogg格式 
2. video 视频 只支持MP4，WebM，Ogg格式

3.新增了input类型：email,url,date,number,tel,search,color......

4.新增的表单属性（写在input里面）

1. required表单内容不能为空
2. placeholder 表单提示信息
3. autofocus 自动聚焦
4. autocomplete 是否显示已经键入过的值
5. multiple 可多选文件



### CSS3的新特性

**CSS3新增选择器**

1. **属性选择器**

   ```css
   input[value]{
   	xxxxxx
   }
   
   <input type="text" value="请输入用户名">
   <input type="text">
   
   E[att=val]
   E[att^=val]开头
   E[att$=val]结尾
   E[att*=val]包含
   ```

   类、属性、伪类的权重一样

2. **结构伪类选择器**

   ```css
   E:first-child{
   
   }
   还可以写成 ul li:first-child  ul里第一个li标签
   
   :last-child
   :nth-child(n) 第n个 n可以是数字，关键字，公式 even（偶数） odd（奇数） 如果n是公式,会从0开始累加，但第0个元素和超出元素的个数会被忽略掉，公式里的变量只能是n。
   :first-of-type 指定类型E的第一个
   :last-of-type
   :nth-of-type(n)
   
   nth-child还比较特殊，在特定情况下还选不出来指定的标签
   <div>
   	<p>
   	<div>
   </div>
   div p:nth-child(1)这时候选不出来，但nth-of-type就能选出来（观测顺序不一样）
   ```

   

3. **伪元素选择器**

   可以帮助我们利用CSS新建标签（是行内元素），而不需要HTML标签，可以简化HTML结构（CSS3采用双冒号）

   新建的这个元素在文档树里是找不到的，所以被称为伪元素

   权重和标签选择器一样

   必须有content属性

**CSS3动画**

详见CSS动画.md

**其他特性**

让图片变模糊：滤镜filter CSS属性将模糊或颜色偏移等图形效果应用于元素 如 filter:blur(5px)

calc函数，此CSS函数能在声明CSS属性时执行一些计算，+ - * /都可以,运算符前后都需要保留一个空格，任何长度值都可以使用calc()函数进行计算



### CSS line-height = height为什么能让文字居中

首先来说，line-height是行高，指的是文本行之间基线的垂直距离。

基线是什么？在文本行中，从上到下依次是**半行距，顶线，中线，基线，底线，半行距**。基线所在的位置是除了j g f这类的小写字母的末端，像英文四行格子的第三行

又因为文本间的半行距是相等的，所以行高又可以看成是一行文本的上半行距到下半行距

font-size的大小就是从**顶线到底线**的距离。

在没有给div盒子设置height的时候，div的高度随line-height的变化而变换，且文字居中

当div盒子有高度时，如果line-height = height，文字就是在中间显示；如果大于，文字偏下；如果小于，文字偏上



### CSS3盒子模型

所有的HTML元素在页面上都可以看做是一个盒子，一个盒子包括:外边距margin，边框border，内边距padding和元素实际内容content

CSS3可以通过设置box-sizing来指定盒子模型，有2个值，content-box和border-box，**这样我们计算盒子大小的方式就进行了改变**

box-sizing:content-box 盒子大小为width + padding + border（默认）

box-sizing:border-box 盒子大小为width(也被称为怪异盒模型，IE盒模型)

如果盒子模型我们改为了box-sizing:border-box，那么padding和border就不会撑大盒子（前提padding和border不会超过width宽度）

与盒模型相关的属性：border-image、box-shadow



### CSS中的BFC和IFC

什么是FC？ FC是Fomatting Context，是页面中的一块渲染区域，并且有一套渲染规则。

BFC和IFC都是常见的FC

**BFC**是Block FC  也叫块级格式化上下文

BFC就是一个页面上隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也是如此

一个元素如何触发产生BFC呢？

1. 根元素本身就是BFC
2. float属性不为none;
3. position为absolute或fixed
4. display为inline-block，table-cell,table-caption,flex
5. overflow不为visible

**BFC布局规则**

1. 内部盒子会在**垂直方向**一个一个的摆放
2. 盒子垂直方向的距离由margin决定，**属于同一个BFC的两个相邻BOX的上下margin会发送重叠**（也就是外边距塌陷）
3. 每个元素的左边与包含的盒子的左边相接触，即使存在浮动也是如此
4. BFC区域不会和float重叠
5. 计算BFC高度时，**浮动元素也参与其中**

能解决什么问题：**能完成自适应的两栏布局，清除内部浮动引起的高度塌陷，解决外边距塌陷问题**



**IFC**是Inline FC，也被叫为内联格式化上下文

一个元素如何触发产生IFC呢？

IFC由不包含块级盒的块容器盒子建立（块容器盒中只有内联级盒子）

**IFC布局规则**

1. 盒子是一个接一个水平摆放的
2. 摆放这些框，它们的水平方向的margin,border,padding所占的空间都会被计算在内
3. 行盒的高度由内部最高的inline box决定
4. 垂直方向可以由vertical-align设置文本基线
5. 当内部盒子太多，会折行变成两个或多个line box，在垂直方向无间隔堆叠，但不能重叠
6. 浮动后IFC内部的浮动元素宽高参与IFC的line-box宽高计算并且从换行后的行开始排列

能影响IFC内部布局的CSS属性：font-size,line-height,height,vertical-align



### CSS常见布局

**两列布局**（可以根据具体要求改变代码）：

利用浮动实现

```html
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        .main{
            width: 95%;
            margin: 0 auto;
        }

        .left{
            float: left;
            width: 200px;
            height: 600px;
            background-color: red;
            margin-right: 20px;
        }

        .right{
            display: flex;//如果里面没有溢出的元素，也可以使用overflow 目的是构建BFC，BFC区域不会和float重叠
            //这里自适应宽度，如果是inline-box，就不能自适应宽度
            height: 600px;
            background-color: blue;
        }
    </style>

<body>
    <div class="main">
        <div class="left"></div>
        <div class="right"></div>
    </div>
</body>
```

利用flex布局实现：

```html
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        .main{
            width: 95%;
            margin: 0 auto;
            display: flex;
        }

        .left{
            width: 200px;
            height: 600px;
            background-color: red;
            margin-right: 20px;
        }

        .right{
            flex: auto;
            height: 600px;
            background-color: blue;
        }
    </style>
```

**三列布局**：

使用定位

```html
   <style>
        * {
            padding: 0;
            margin: 0;
        }

        .main {
            width: 95%;
            margin-left: auto;
            margin-right: auto;
            /* 左右居中 */
            height: 300px;
            /* *zoom: 1; */
            position: relative;
        }


        /*左边固定元素定位*/
        .left {
            position: absolute;
            top: 0;
            left: 0;
            width: 200px;
            height: 100%;
            background-color: cyan;
        }


        /* 中间自适应，设置的margin左右距离为左右二边固定宽度元素的 大小*/
        .center-fa {
            width: 100%;
            height: 100%;
        }

        .center {
            height: 100%;
            margin-left: 210px;
            margin-right: 210px;
            background-color: chocolate;
        }


        .right {
            position: absolute;
            top: 0;
            right: 0;
            width: 200px;
            height: 100%;
            background-color: rgb(255, 0, 221);
        }
    </style>

<div class="main">
        <div class="left"></div>
        <div class="center-fa"> <div class="center"></div></div>
        <div class="right"></div>
    </div>
```

使用flex布局

```html
<style>
        * {
            padding: 0;
            margin: 0;
        }

        .main {
            width: 95%;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            display: flex;
            justify-content:space-between;
        }

        .left {
            width: 200px;
            height: 100%;
            background-color: cyan;
        }

        .center {
            flex:auto;
            height: 100%;
            margin-left: 20px;
            margin-right: 20px;
            background-color: chocolate;
        }

        .right {
            width: 200px;
            height: 100%;
            background-color: rgb(255, 0, 221);
        }
    </style>

    <div class="main">
        <div class="left"></div>
        <div class="center"></div>
        <div class="right"></div>
    </div>
```

**圣杯布局**

> 要求：
>
> - header和footer各自占领屏幕所有宽度，高度固定。
> - 中间的container是一个三栏布局。
> - 三栏布局两侧宽度固定不变，中间部分自动填充整个区域。
> - 中间部分的高度是三栏中最高的区域的高度。
> - 中间部分在DOM结构上优先，以便先行渲染

实现方法：浮动

**双飞翼布局**

>  [圣杯布局](https://blog.csdn.net/qq_38128179/article/details/86533976)和[双飞翼布局](https://blog.csdn.net/qq_38128179/article/details/86542447)达到的效果基本相同，都是**侧边两栏宽度固定，中间栏宽度自适应。**主要的不同之处就是在解决中间部分被挡住的问题时，采取的解决办法不一样，圣杯布局是在父元素上设置了padding-left和padding-right，在给左右两边的内容设置position为relative，通过左移和右移来使得左右两边的内容得以很好的展现，而双飞翼则是在center这个div中再加了一个div来放置内容，在给这个新的div设置margin-left和margin-right 。

> 共同要求：
>
> - 两侧宽度固定，中间宽度自适应
> - 中间部分在DOM结构上优先，以便先行渲染
> - 允许三列中的任意一列成为最高列
> - 只需要使用一个额外的div标签



### 手写一个Promise.all Promise.race

考虑了可迭代对象，包括Array,String,Map,Set

```javascript
	function myPromiseAll(iterableParam){
        if(typeof iterableParam[Symbol.iterator] !== 'function'){
            throw new TypeError('参数必须是可迭代对象');       
        }
        const resArr = [];
        let count = 0;
        const length = iterableParam.length || iterableParam.size;
        return new Promise((resolve,reject) => {
            let i = 0;
            for(let item of iterableParam){
                let index = i++;
                Promise.resolve(item).then(
                    (data) => {
                        resArr[index] = data;
                        count++;
                        if(count === length){
                            resolve(resArr);
                        }
                    }
                ).catch(
                    (err) => {
                        reject(err);
                    }
                );
            };
        });
    }

    function myPromiseRace(iterableParam){
        if(typeof iterableParam[Symbol.iterator] !== 'function'){
            throw new TypeError('参数必须是可迭代对象');
        }

        return new Promise((resolve,reject) => {
            for(let item of iterableParam ){
                Promise.resolve(item).then(
                    (data) => {
                        resolve(data);
                    }
                ).catch(
                    (err) => {
                        reject(err);
                    }
                );
            };
        });
    }
```



### 理解一下Promise对象

新建一个Promise对象，参数会是一个回调函数，回调函数会携带两个参数resolve和reject，此时这个两个参数还没什么意义

在这个回调函数里可以写各种逻辑的代码，同步的，异步的都可以，此时把刚刚传入的resolve和reject当成函数来使用，resolve当成逻辑成功时的return，reject当成逻辑失败时的return，传入的这两个`return`的参数也是自定的。

其实当没执行到resolve和reject的时候，Promise是一个未确定的状态pending，当执行到某一个`return`后Promise会根据到底是resolve还是reject来选择变成是fulfilled或者说是rejected状态，而PromiseResult（在浏览器里看见的）就是传入这两个`return`函数的参数

> 但这个return还是不一样的，这个return只是决定了promise的状态，其他的代码还是要执行的
>
> 也就是说
>
> 无论是先resolve或reject ，并不会像return一样停止执行代码，所有的都会执行，如果p后面有then/catch，那么执行到resolve/reject会立即执行then/catch，但并不会影响Promise内其余代码执行
>
>  如果有两个resolve/reject，那么第二个运行到的不会执行

重点就是then方法

如果不调用这个Promise的then方法，这个两个`return`函数就没啥用，此时我们要把早就定义好的resolve和reject变成真正的函数，也就是传入then方法的第一二个回调函数，或者只给then传一个函数，另一个给catch，传入then或者catch里面的参数（也就是回调函数）的参数就是刚刚`return`的返回值，也就是说then方法里面的回调函数顶替了resolve，catch里面的回调函数顶替了reject



### 理解一下Promise.resolve与Promise.reject

**Promise.resolve**

给定一个参数，返回Promise对象

首先说参数：分为四类（对Promise存疑）

一类是空，什么都不传，返回fulfill状态，PromiseResult是undefined

一类是普通的没有then方法的参数，此时返回的Promise是成功态，PromiseResult是该参数（无论是对象还是基本类型）

一类是 本身不是Promise但有then方法的参数，如果then方法没有参数，或者有参数没有当成函数执行，**那么返回的是pending undifened**；如果有两个函数（onFulfill onReject），一个就不用考虑那么多

- Fulfill 在最前面的话，状态就是fulfill，参数是then函数里面的onFulfill里面的参数
- 如果抛出异常或onReject在前面的话，必须在resolve后面跟有处理失败状态的回调函数（then的第二个参数或者catch），否则报错，此时返回的就是then处理过的新的Promise对象了

>   都会执行then里面的其他代码

一类是 传入Promise对象，则原样返回（没有深入研究）



**Promise.reject**

**调用后除了fuifill状态，其他必须跟catch捕捉错误，否则会报错**

给定一个参数，返回Promise对象

首先说参数：

如果是普通的没有then方法的参数时，reject状态和（数据是）数据本身

如果是普通异常，reject状态和（数据是）异常本身

（不正常的情况）如果传入有then方法但没有参数之类的话，**此时返回的Promise是失败态，PromiseResult是该参数（无论是对象还是基本类型）**，但会报错（没有捕捉），如果加上捕捉，不会报错但只会返回pending undifiened且不会执行then和catch的回调

（正常的情况）但then如果有两个函数（onFulfill onReject） 

- **Fulfill 在最前面的话，状态就是fulfill，参数是then函数里面的onFulfill里面的参数！！！很重要**

- 如果抛出异常或onReject在前面的话，必须在resolve后面跟有处理失败状态的回调函数（then的第二个参数或者catch），否则报错，此时返回的就是then处理过的新的Promise对象了

- **这里和resolve的处理方法一样！！！！**

  会执行自身的then

方法可能太复杂，没有统一的规律，日后再理解



### ES6的Map和Set

不能像数组或者对象一样访问（不能通过. 或 []访问），只能通过方法来访问，因为那样访问的是对象的属性，而Map和Set的值都不是属性存储的，存在这个*[[Entries]]*东西里面

**Map**，结构和对象相似，也是键值对的形式存储。

但是和对象很很多地方不同

1. Map的键可以是任意值，甚至可以是NaN；Object只能是字符串或者Symbol
2. Map的key是有序的；Object的key是无序的
3. Map是可以迭代的；而Object是不可以迭代的（Map迭代的item是数组形式的键值对）
4. Map在频繁增删键值的场景下表现更好，而Object不行

可以使用instanceof和toString来进行判断类型

使用

```javascript
let a = new Map();
let b = new Map([[1,2],[3,4]])或者是一个可迭代对象（这里数组迭代出来就是一个个数组）

a.set(key,value)//任意类型
a.get(key)//返回对应值，没有就undifined
b.delete(key)//存在元素返回true，不存在返回false
b.size//多少个键值对
b.has(key)//是否存在，返回布尔值

可以使用...进行扩展，扩展出来是一个个长度为二的数组，也是因为这个特性，可以对多个Map或数组进行合并

//使用for of遍历
for(let i of b) 每一个i是个长度为二的数组
//使用forEach遍历
b.forEach(function(value, key) {
  console.log(key + " = " + value);
})
一个参数是value 第二个参数是key 注意！！！

如果value或者key没有引用类型，则可以直接使用new Map(另一个Map)进行拷贝，是深拷贝
但如果value或者key有引用类型，就要对其进行处理，不然拷贝过来的是引用地址
```

**Set**，允许你存储任何类型的**唯一值**，无论是原始值还是对象引用，可以**按照插入的顺序迭代**它的元素

`NaN`和`undefined`都可以被存储在Set 中， `NaN`之间被视为相同的值（NaN被认为是相同的，尽管 NaN !== NaN）

一些情况下可以用来对数组的去重

没有像数组一样的索引调用，也没有像Map一样的用get调用，单独调用一个值出来好像只能遍历

可以用instanceof 和 toString来进行类型判断

```javascript
let a = new Set();
let b = new Set([1,2,3,44,4,4,5]);或者是一个可迭代对象（这里数组迭代出来就是一个个数组）,不重复的添加到Set里面

大部分和Map类似
a.add(val)//返回该Set对象
let setIter = b.values();//返回新的迭代器对象，
setIter.next().value //1

也可以用扩展运算符...扩展，得出的是一个个值

for of的item是values

b.forEach(callback,[,thisArg])
callback必选
为集合中每个元素执行的回调函数，该函数接收三个参数：
	currentValue, currentKey可选
	currentValue 是正在被操作的元素。并且由于集合没有索引，所以 currentKey 也表示这个正在被操作的元素。
set可选 调用当前 forEach 方法的集合对象
thisArg可选 回调函数执行过程中的 this 值。

关于拷贝，和Map的情况一样
```



### 获取URL中的参数

```javascript
function getUrlParam(sUrl, sKey) {
    sUrl = sUrl.slice(sUrl.indexOf('?') + 1);
    var reg = /(\w+)=(\w+)/g
    var res_obj = {};
    sUrl.replace(reg,function(str,g1,g2){
        if(res_obj[g1] !== void 0){
            res_obj[g1] = [].concat(res_obj[g1],g2);
        }else{
            res_obj[g1] = g2;
        }
    });
    if(sKey === void 0){
        return res_obj;
    }else{
        return res_obj[sKey] || '';
    }
}
```



### 正则表达式

限定符

1. *表示0次或多次
2. +表示1次或多次
3. ?表示0次或1次
4. {6}6次
5. {2,6}2-6次
6. {6,}6次以上

或运算符

1. a|b 匹配a或b

元字符

1. \d 数字 \D 非数字
2. \w 单词字符（英文、数字、下划线） \W 非单词字符
3. \s 匹配空白符（包含换行和Tab） \S非空白符
4. . 任意字符（除了换行符）
5. ^行首 $行尾

转义符号: \

标志：

1. i 忽略大小写
2. g 全局匹配
3. m 多行修饰符：锚点元字符 `^` `$` 工作范围在每行的起始

JS创建正则表达式:

1.  var a = new RegExp(/表达式/)
2.  var a = /表达式/

> RegExp.test(str) 返回布尔值
>
> str.replace(regexp/str,replacement/callback) 
>
> callback(str,p1,p2...,offset,string,NameCaptureGroup)
>
> 第一个参数是匹配到的字符串
>
> p1,p2..表示正则表达式里面的括号
>
> offset表示偏移量
>
> string表示原字符串
>
> NameCaptureGroup命名组匹配的对象 不知道有是没用，普通打印出来的是undifined



### offset,client,scroll区别及联系

首先 offset所涉及的Widht和Height是包括了border,padding和实际内容的

而client所涉及的Widht和Height只包括了padding和实际内容

而scroll所涉及的Widht和Height只包括了实际内容

三者所返回的数值都不带单位，一个比一个包含的内容少，且会涉及清空浏览器渲染队列



其次三者涉及的Top和Left也是不一样的

offset涉及的Top，是元素距离带有定位的父元素上方的距离，left同理

而client涉及的Top，是元素上边框的大小，left同理

而scroll涉及的Top，是被卷去的上侧的距离，left同理

三者区别还是很大的，特别是client与另外两个的区别



### innerHTML和createElement的效率测试

不同浏览器下，innerHTML的效率要比createElement效率高，但这是在innerHTML采用数组拼接的方法的情况，如果采用`+`拼接字符串，效率就会大幅下降

> 还有种动态创建元素的方法
>
> document.write('<div></div>')
>
> 它是把内容直接写入页面的内容流，当文档流执行完毕再执行这个函数的时候，会把原本的内容替换掉，引起页面回流





### 说一些常用的BOM对象

首先BOM是浏览器对象

常用的对象：location对象，history对象，Navigator对象

**location对象**

1. location.href 返回或设置当前文档的URL
2. location.search 返回URL中的查询字符串部分
3. location.hash 返回URL中#的部分
4. location.host 返回URL中的域名部分
5. location.assign 设置当前文档的URL
6. location.replace() 设置当前文档的URL，并且在**history对象**的地址列表中移除这个URL location.replace(newUrl)
7. location.reload() 重载当前页面

**history对象**

1. history.go() 前进或后腿指定的页面数（正数或负数，0是刷新页面）
2. history.back() -- 后退一页
3. history.forward() -- 前进一页

**Navigator对象**

1. navigator.userAgent 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)也就是HTTP头部的user-agent字段的信息
2. navigator.cookieEnabled 返回浏览器是否支持(启用)cookie



### export和export default的区别

`export`命令对外接口是**有名称的**且`import`命令从模块导入的变量名与**被导入模块对外接口的名称相同**,可以用as来进行更改名字，可以export多个变量，或者用一个export {param1,param2}，接收时也是{param1,param2}

```javascript
export function multiply(x, y) {
  return x * y;
};

import {multiply} from './profile.js'
```



而export default命令对外输出的**变量名可以是任意的，不需要知道原本的变量名**，这时`import`命令后面，**不使用大括号**。

```javascript
export default function(){
}

import param from './profile.js'
```



换一个角度来看，export default就是输出一个default的变量和方法，所以可以用export输出一个default的变量，但实际效果与export default相比我也不是很清楚

> `export default`命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此`export default`命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应`export default`命令。



### JS迭代器

**迭代器是**什么？迭代器就是为实现**对不同集合进行统一遍历操作**的一种机制

什么是**迭代器模式**？提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部元素。

为什么要**使用迭代器**？JS对于遍历聚合对象中各个元素（Array，Set，Map，Object），会采用不同的遍历方式，如果后端返回的数据结构发生变化，会导致前端大量代码重写，所以使用迭代器，就是要**标准化迭代操作**



**在JavaScript中**，**迭代器**就是一个**对象**（这个对象中有next方法），这个对象定义一个序列，并在终止时可能返回一个返回值。

更具体的说，迭代器这个对象通过next()方法返回具有两个属性的对象：**value**（这是序列中的 next 值）和**done**（如果已经迭代到序列的最后一个值，则它就是true），这个有value和done的对象就是迭代器的返回值

>  只能迭代一次的Iterables（例如Generators）通常从它们的**@@iterator**方法中返回它本身，其中那些可以多次迭代的方法必须在每次调用**@@iterator**时返回一个新的迭代器。
>

**迭代协议**分为两个部分：

1. 可迭代协议
2. 迭代器协议

**可迭代协议**规定了，运行JS对象定义或定制它们的迭代行为。

如何定制呢？要成为可以迭代的对象，对象必须有**@@iterator方法**（[Symbol.iterator]）

**迭代器协议**规定了，产生 **迭代的一系列的值**的标准方式。

当值为有限个时，所有的值都被迭代完毕后，则会返回一个**默认返回值**。

也就是规定了拥有特殊写法的next方法（包括规定返回值，value，done的内容等等），拥有这个next方法，对象才能成为可迭代的对象



**生成器函数**

用**function***这种声明方式表示这个函数是个**生成器函数**，返回一个Generator对象，也就是生成器对象，这对象有**next方法**，满足上述的迭代协议。

> **生成器对象**，既是一个迭代器，也是一个可迭代对象（@@iterator方法返回本身（本身这个迭代器））
>
> 生成器函数最多有255个参数

**生成器函数**在执行时能暂停，后面又能从暂停处继续执行。

调用 `next()`方法时，如果传入了参数，那么这个参数会传给**上一条执行的 yield语句左边的变量**

当在生成器函数中显式 `return `时，会导致生成器立即变为完成状态，即调用 `next()` 方法返回的对象的 `done `为 `true`。如果 `return `后面跟了一个值，那么这个值会作为**当前**调用 `next()` 方法返回的 value 值

不能当构造函数来使用



给对象定制迭代行为

```javascript
两种方法    
var obj = {
        a:1,
        [Symbol.iterator]:function(){
            let index = 0;
            let next = () =>{
                return {
                    value:index++,
                    done: index > 10 ? true : false
                }
            }
            return {
                next
            }
        }
    }

    var obj = {
        a:1, 
        [Symbol.iterator]:function*(){
            yield 1;
            yield 2;
            yield 3;
        }
    }

    for(let i of obj){
        console.log(i);
    }
```



### DOM事件流

JS代码只能执行捕获或者冒泡其中的一个阶段

onclick和attachEvent只能得到冒泡阶段，也就是说是冒泡开始的

addEventListener(type,listener[,options,userCapture])

第四个参数为true,表示在**捕获阶段调用事件处理程序**；

如果是false(默认为fasle)，表示在**冒泡阶段调用事件程序**。

> 其实第三个参数是一个指定有关listener属性的对象。
>
> 属性分别是capture,once,passive
>
> - `capture`:  Boolean，表示 `listener` 会在该类型的事件捕获阶段传播到该 `EventTarget` 时触发。
> - `once`:  Boolean，表示 `listener 在添加之后最多只调用一次。如果是` `true，` `listener` 会在其被调用之后自动移除。
> - `passive`: Boolean，设置为true时，表示 `listener` 永远不会调用 `preventDefault()`。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。



### 如何阻止事件发生

三种方法：

标准的：e.preventDefault();

非标准，兼容IE低版本：e.returnValue

特殊的：return false(之后的代码都没用了)



### 如何阻止事件冒泡

标准方法：e.stopPropagation()

兼容IE低版本的方法：e.cancelBubble = true



### 什么是高阶函数？

1.若A函数，接收的参数是一个函数，那么A就可以被称为高阶函数

2.若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数

两个中任意满足一个即可。

常见的，如Promise、setTimeout