# 防抖与节流

概念：通过限制调用次数来进行性能优化

## 防抖

触发事件后的一段时间后才执行函数，如果在在这段时间内再次触发该事件，则重新计时

```javascript
//防抖第一版：
    let timer = null;
    function debounce(fn){
        clearTimeout(timer);
        timer = setTimeout(() =>{
            fn();
        },3000);
    }
    function testDebounce(){
        console.log('测试防抖');
    }

    document.onmousemove = function(){
        debounce(testDebounce);
    }
```

1.为什么要用clearTimeout?
	清除之前已经存在的debounce，也就是清除之前将要执行的setTimeout，如果不清除则会执行之前的setTimeout，做不到防抖效果。
2.执行多个debounce会有什么问题？
	设置多个debounce会导致需要多个timer，否则不同函数会覆盖同一个timer导致程序出错。
函数应该实现单一功能原则，保证其自身的高内聚低耦合性，所以这个版本设计不合理。

```javascript
//防抖第二版：
    function debounce(fn,delay = 3000){
        let timer = null;
        return function(){
            let _this = this,
                args = arguments;
            if(timer) clearTimeout(timer);
            timer = setTimeout(function(){
                fn.apply(_this,args);
            },delay);
        }
    }
	//args类数组里面的值一个一个对应到该形参中
    function testDebounce(e,content){
        console.log(e,content);
    }
    var testDebounceFn = debounce(testDebounce)
    document.onmousemove = function(e){
        testDebounceFn(e,'debounce');
    }

    var testClick = debounce(testDebounce)
    document.onclick = function(e){
        testClick(e,'click');
    }
```

该代码成功解决了多个函数需要防抖的问题，实现了函数的单一功能原则，保证其自身的高内聚低耦合性，重点在于闭包，arguments，fn.apply。
1.为什么能解决多个函数防抖问题？
	每当要为一个函数或事件设置防抖时，var创建语句会通过函数debounce创建一个私有的作用域，里面有私有的变量timer，所以每创建一个防抖，就会对应创建一个timer，解决了多个函数事件防抖重合问题。
2.为什么要设置_this?为什么要将apply设置到新写的_this上？
	在apply中，会将调用的函数绑定到对应的this里，所以如果不使用先前创建的_this，而是直接使用this，而箭头函数的this是固定的，是创建箭头函数的环境。（比如调用者此时为input，如果使用this，因为fn是在全局中调用的，则会将调用者指向window，调用apply会将当前的上下文显示的绑定this上）

```javascript
//防抖第三版：
    function debounce(fn,delay = 3000){
        let timer = null;
        return (...args) => {
            if(timer) clearTimeout(timer);
            timer = setTimeout(() =>{
                fn(...args);
            },delay);
        };
    };
```


对第二版的简化，有个和第二个版本不一样的地方在args上，args不会一个一个对应的放入形参了，而只赋给第一个形参。



## 节流

每隔一段时间内，只执行一次函数，节流会稀释函数的执行频率

节流：根据定义，在timer存在的时候直接return，不存在的时候执行setTimeout

```javascript
function throttle(fn,delay = 3000){
        let timer = null;
        return (...args) =>{
            if(timer) return;
            timer = setTimeout(() =>{
                fn(args);
                timer = null;
            },delay);
        };
    };

function testThrottle(val){
    console.log(val);
}

var testThrottleFn = throttle(testThrottle);
document.onmousemove = function(e){
    testThrottleFn(e,'move');
}
```

针对节流，除了可以使用setTimeout之外，还可以使用时间戳写代码。

优化:

```javascript
    function throttle(fn,delay = 3000){
        let timer = 0;
        let index = 0;
        return function(){
            if(timer != index) return;
            timer = setTimeout(()=>{
                fn(arguments);
                clearTimeout(timer);
                index = timer;
            },delay);
        }
    }

//2021-03-23 感觉这个优化没屁用
```

上一个代码不会销毁setTimeout。clearTimeout销毁而timer的返回值应该是定时器的引用个数，虽然是个全局的计数器，但事件之间不会互相影响。

## 防抖和节流异同比较

相同点：1.都使用setTimeout.2目的都是降低回调执行频率，节省资源
不同点：1.防抖关注一定时间内连续触发的事件，只执行最后一次触发；节流则侧重于一段时间内只执行一次

## 防抖和节流的使用场景

防抖的使用场景：连续的事件，只执行最后一次触发的场景
1.搜索框搜索输入，最后一次输入完成，再次发送请求。
2.手机号、邮箱号的输入验证。
3.窗口大小的调整，在调整完成后才计算窗口的大小，防止重复渲染。
节流的使用场景：间隔一段时间执行一次回调的场景
1.滚动加载，加载更多操作
2.表单的多次点击提交，最后这段时间内只提交一次信息



# 面试技巧

1.性能优化
当面试官在提出性能优化的点时，我们不光可以从框架，webpack，关键路径渲染等的角度回答，也可以从原生JS中的技巧上来回答，比如这个。
2.答题技巧
针对防抖&节流的问题根据我们所说的步骤一步一步讲解，延伸，可以给面试官一个逻辑清晰的印象。

